#|==============================================================================


String Library - v1.05

Copyright 2022 Alec Dee - MIT license - SPDX: MIT
alecdee.github.io - akdee144@gmail.com


--------------------------------------------------------------------------------
Notes


string.sico currently only provides the print function. In the future, it will
also provide string manipulation functions.


--------------------------------------------------------------------------------
Index


Printing
string.print char0 char1 char2 ... 0

String formatting escape codes
string.uint    [num]
string.uintfmt [num], [base], [padding], [padchar]
string.uintinl [num], base, padding, padchar
string.int     [num]
string.intfmt  [num], [base], [sign], [padding], [padchar]
string.intinl  [num], base, sign, padding, padchar


--------------------------------------------------------------------------------
Version History


1.00
     Initial version.
     Created print function.
1.01
     Reorganized integer printing constants.
1.02
     Replaced built-in integer printing with uint.print and int.print.
     Library now handles strings instead of just printing.
1.03
     Renamed print to string.print for consistency.
1.04
     Updated comments.
1.05
     Modified string.print to use uint.writestring instead of uint.print.


--------------------------------------------------------------------------------
ASCII Reference Table


  0  00  NUL |  26  1a      |  52  34   4  |  78  4e   N  | 104  68   h
  1  01      |  27  1b  ESC |  53  35   5  |  79  4f   O  | 105  69   i
  2  02      |  28  1c      |  54  36   6  |  80  50   P  | 106  6a   j
  3  03      |  29  1d      |  55  37   7  |  81  51   Q  | 107  6b   k
  4  04      |  30  1e      |  56  38   8  |  82  52   R  | 108  6c   l
  5  05      |  31  1f      |  57  39   9  |  83  53   S  | 109  6d   m
  6  06      |  32  20  SPC |  58  3a   :  |  84  54   T  | 110  6e   n
  7  07  BEL |  33  21   !  |  59  3b   ;  |  85  55   U  | 111  6f   o
  8  08  BCK |  34  22   "  |  60  3c   <  |  86  56   V  | 112  70   p
  9  09  TAB |  35  23   #  |  61  3d   =  |  87  57   W  | 113  71   q
 10  0a  LF  |  36  24   $  |  62  3e   >  |  88  58   X  | 114  72   r
 11  0b  VTB |  37  25   %  |  63  3f   ?  |  89  59   Y  | 115  73   s
 12  0c      |  38  26   &  |  64  40   @  |  90  5a   Z  | 116  74   t
 13  0d  CR  |  39  27   '  |  65  41   A  |  91  5b   [  | 117  75   u
 14  0e      |  40  28   (  |  66  42   B  |  92  5c   \  | 118  76   v
 15  0f      |  41  29   )  |  67  43   C  |  93  5d   ]  | 119  77   w
 16  10      |  42  2a   *  |  68  44   D  |  94  5e   ^  | 120  78   x
 17  11      |  43  2b   +  |  69  45   E  |  95  5f   _  | 121  79   y
 18  12      |  44  2c   ,  |  70  46   F  |  96  60   `  | 122  7a   z
 19  13      |  45  2d   -  |  71  47   G  |  97  61   a  | 123  7b   {
 20  14      |  46  2e   .  |  72  48   H  |  98  62   b  | 124  7c   |
 21  15      |  47  2f   /  |  73  49   I  |  99  63   c  | 125  7d   }
 22  16      |  48  30   0  |  74  4a   J  | 100  64   d  | 126  7e   ~
 23  17      |  49  31   1  |  75  4b   K  | 101  65   e  | 127  7f  DEL
 24  18  CAN |  50  32   2  |  76  4c   L  | 102  66   f  |
 25  19      |  51  33   3  |  77  4d   M  | 103  67   g  |


--------------------------------------------------------------------------------
TODO


rename string.print to io.print
io.readline
string.create
string.free
string.length
string.getchar
string.setchar
string.split
string.strip
string.padleft
string.padright
string.padsign   # pad's left but skips +-, so "-31" becomes "-0031"

string structure
	0 ptr
	1 len
char[i] = [[string.ptr] + i]

|#


string.print:
	# Call  : 0 ? string.print char0 char1 char2 ... 0
	# Effect: Prints a zero terminated ASCII string. If an escape code is used,
	#       : the next value(s) are expected to be numbers or formatting.
	# Use [0] to get the calling address.
	.ptr    .ptr    ?+1
	.ptr    0       ?+1
	.ptr    .z-2    ?+1
	0       0       .loop
.ret:
	0 ? mem.free .mem
	.mem    .mem    ?+1
	.memlen .memlen ?+1
	.tmp
.loop:
	# Get the next character.
	.tmp    .ptr:0  ?+1
	.ptr    .z-1    ?+1
	.char   .char   ?+1
	.char   .tmp    ?+1
	# If [char]=0, we've reached the end of the string.
	.char   .z      .ret
	# If [tmp]<=[escape], then we want to print a non-character.
	.tmp    .esc    .escprint
	# Print [char].
	0-2     .char   ?+1
	.tmp    .tmp    .loop
.escprint:
	# Print something other than a character.
	0       .ptr    ?+1
	0       .z-2    ?+1
	.padchr .padchr ?+1
	.padchr .paddef ?+1
	.retry  .retry  ?+1
	# Determine what type of value we're printing.
	.tmp    .z      .str
	.tmp    .nesc   .invalid
	.tmp    .z+1    .intinl
	.tmp    .z+1    .intfmt
	.tmp    .z+1    .int
	.tmp    .z+1    .uintinl
	.tmp    .z+1    .uintfmt
	.tmp    .z+1    .uint
	.tmp    .z+1    .strfmt
.invalid:
	# Print "INVALID FORMAT"
	.tmp    .tmp    ?+1
	0       0       ?+1
	0 ? string.print 73 78 86 65 76 73 68 32 70 79 82 77 65 84 10 0
	0-1     0       ?-2
.str:
	# Reserved for string printing.
	0-1     0       ?-2
.strfmt:
	# Reserved for string printing.
	0-1     0       ?-2
.uint:
	.retry  ?+2     ?+2  0-uint.writestring-36
	mem.getargs.0 ? mem.getargs ?+12 1 .ptr 0 0
	0 ? uint.writestring .mem .memlen .z .retlen 0 .base
	.tmp    .tmp    .write
.uintfmt:
	.retry  ?+2     ?+2  0-uint.writestring-36
	mem.getargs.0 ? mem.getargs ?+18 1 ?+17 1 .pad 2 .padchr 2 .ptr 0 0
	0 ? uint.writestring .mem .memlen .z .retlen 0 0
	.tmp    .tmp    .write
.uintinl:
	.retry  ?+2     ?+2  0-uint.writestring-36
	mem.getargs.0 ? mem.getargs ?+18 1 ?+17 0 .pad 1 .padchr 1 .ptr 0 0
	0 ? uint.writestring .mem .memlen .z .retlen 0 0
	.tmp    .tmp    .write
.int:
	.retry  ?+2     ?+2  0-int.writestring-39
	mem.getargs.0 ? mem.getargs ?+12 1 .ptr 0 0
	0 ? int.writestring .mem .memlen .z .retlen 0 .base .z
	.tmp    .tmp    .write
.intfmt:
	.retry  ?+2     ?+2  0-int.writestring-39
	mem.getargs.0 ? mem.getargs ?+20 1 ?+19 1 ?+18 1 .pad 2 .padchr 2 .ptr 0 0
	0 ? int.writestring .mem .memlen .z .retlen 0 0 0
	.tmp    .tmp    .write
.intinl:
	.retry  ?+2     ?+2  0-int.writestring-39
	mem.getargs.0 ? mem.getargs ?+20 1 ?+19 0 ?+18 0 .pad 1 .padchr 1 .ptr 0 0
	0 ? int.writestring .mem .memlen .z .retlen 0 0 0
	.tmp    .tmp    .write
.write:
	# If [retlen]<[memlen] we need to resize [mem] and retry.
	.retlen .memlen .lenok
	.tmp    .retlen ?+1
	.memlen .tmp    ?+1
	0 ? mem.realloc .mem .mem .memlen
	.mem    .z      .invalid
	.tmp    .tmp    .retry:0
.lenok:
	.tmp    .memlen ?+1
	.retlen .tmp    ?+1
	# Print padding.
	.pad    .retlen ?+10
	0-2     .padchr ?+1
	.pad    .z+1    ?+7
	0-2     .padchr ?-5
	.pad    .pad    ?+1
	# Print [mem].
	.tmp    .tmp    ?+1
	.tmp    .mem    ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+4
	.retlen .z+1    ?+7
	0-2     .p0:0   ?+1
	.p0     .z-1    ?-8
	.tmp    .tmp    .loop
	# Variables
	0-2 0-1 .z:0 1
	.tmp:0
	.char:0
	.esc:0-string.escstart
	.nesc:string.escstart-string.escend
	.mem:0
	.memlen:0
	.retlen:0
	# Formatting defaults
	.base:10
	.pad:0
	.padchr:0
	.paddef:0-32


# String formatting escape codes. Define here so string.escstart >= 256.

string.escstart:
string.str:     0  # Reserved
string.strfmt:  1  # Reserved
string.uint:    2  # [num]
string.uintfmt: 3  # [num], [base], [padding], [pad char]
string.uintinl: 4  # [num], base, padding, pad char
string.int:     5  # [num]
string.intfmt:  6  # [num], [base], [padding], [pad char], [sign]
string.intinl:  7  # [num], base, padding, pad char, sign
string.escend:


