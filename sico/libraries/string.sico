#|==============================================================================


String Library - v2.00

Copyright 2022 Alec Dee - MIT license - SPDX: MIT
alecdee.github.io - akdee144@gmail.com


--------------------------------------------------------------------------------
Notes


string.sico provides functions for basic string manipulation and console IO.

Do not include this library first. It needs to start at address 256 or later for
the escape code constants to work.

This library depends on the memory library.


--------------------------------------------------------------------------------
Index


Management
string.create   [ret]
string.free     [str]

Input/Output
string.print char0 char1 char2 ... 0

String formatting escape codes:
string.str     [str]
string.strfmt  [str], [padding], [pad char]
string.strinl  [str], padding, pad char
string.uint    [num]
string.uintfmt [num], [base], [padding], [padchar]
string.uintinl [num], base, padding, padchar
string.int     [num]
string.intfmt  [num], [base], [sign], [padding], [padchar]
string.intinl  [num], base, sign, padding, padchar


--------------------------------------------------------------------------------
Version History


1.00
     Initial version.
     Created print function.
1.01
     Reorganized integer printing constants.
1.02
     Replaced built-in integer printing with uint.print and int.print.
     Library now handles strings instead of just printing.
1.03
     Renamed print to string.print for consistency.
1.04
     Updated comments.
1.05
     Modified string.print to use uint.writestring instead of uint.print.
2.00
     Added string structure, basic manipulation functions, and console
     input/output functions.


--------------------------------------------------------------------------------
ASCII Reference Table


  0  00  NUL |  26  1a      |  52  34   4  |  78  4e   N  | 104  68   h
  1  01      |  27  1b  ESC |  53  35   5  |  79  4f   O  | 105  69   i
  2  02      |  28  1c      |  54  36   6  |  80  50   P  | 106  6a   j
  3  03      |  29  1d      |  55  37   7  |  81  51   Q  | 107  6b   k
  4  04      |  30  1e      |  56  38   8  |  82  52   R  | 108  6c   l
  5  05      |  31  1f      |  57  39   9  |  83  53   S  | 109  6d   m
  6  06      |  32  20  SPC |  58  3a   :  |  84  54   T  | 110  6e   n
  7  07  BEL |  33  21   !  |  59  3b   ;  |  85  55   U  | 111  6f   o
  8  08  BCK |  34  22   "  |  60  3c   <  |  86  56   V  | 112  70   p
  9  09  TAB |  35  23   #  |  61  3d   =  |  87  57   W  | 113  71   q
 10  0a  LF  |  36  24   $  |  62  3e   >  |  88  58   X  | 114  72   r
 11  0b  VTB |  37  25   %  |  63  3f   ?  |  89  59   Y  | 115  73   s
 12  0c      |  38  26   &  |  64  40   @  |  90  5a   Z  | 116  74   t
 13  0d  CR  |  39  27   '  |  65  41   A  |  91  5b   [  | 117  75   u
 14  0e      |  40  28   (  |  66  42   B  |  92  5c   \  | 118  76   v
 15  0f      |  41  29   )  |  67  43   C  |  93  5d   ]  | 119  77   w
 16  10      |  42  2a   *  |  68  44   D  |  94  5e   ^  | 120  78   x
 17  11      |  43  2b   +  |  69  45   E  |  95  5f   _  | 121  79   y
 18  12      |  44  2c   ,  |  70  46   F  |  96  60   `  | 122  7a   z
 19  13      |  45  2d   -  |  71  47   G  |  97  61   a  | 123  7b   {
 20  14      |  46  2e   .  |  72  48   H  |  98  62   b  | 124  7c   |
 21  15      |  47  2f   /  |  73  49   I  |  99  63   c  | 125  7d   }
 22  16      |  48  30   0  |  74  4a   J  | 100  64   d  | 126  7e   ~
 23  17      |  49  31   1  |  75  4b   K  | 101  65   e  | 127  7f  DEL
 24  18  CAN |  50  32   2  |  76  4c   L  | 102  66   f  |
 25  19      |  51  33   3  |  77  4d   M  | 103  67   g  |


--------------------------------------------------------------------------------
TODO


merge string.print and string.writeinline
rename string.int to string.esc.int, etc

Management
string.copy     ret str
string.clear    str
string.length   ret str
string.getchar  ret str idx
string.setchar  str idx chr

Formatting
string.writeinline [ret] char0 char1 char2 ... 0
string.writestring [ret] [fmt]

Input/Output
string.read  ret

Comparisons
string.cmp      a b lt eq gt

Block Operations
string.substring ret str start stop
string.split    ret str

Padding
string.strip    ret str
string.padleft  ret str
string.padright ret str
string.padsign  ret str # pad's left but skips +-, so "-31" becomes "-0031"

string structure
	0 ptr
	1 len
char[i] = [[string.ptr] + i]


|#


#---------------------------------------------------------------------------------
# Constants


# The string structure in memory.
string.struct:
	.str:  0
	.len:  1
	.size: 2


# Escape codes. Used to insert values into strings.
string.escstart:
string.str:     0  # [str]
string.strfmt:  1  # [str], [padding], [pad char]
string.strinl:  2  # [str], padding, pad char
string.uint:    3  # [num]
string.uintfmt: 4  # [num], [base], [padding], [pad char]
string.uintinl: 5  # [num], base, padding, pad char
string.int:     6  # [num]
string.intfmt:  7  # [num], [base], [padding], [pad char], [sign]
string.intinl:  8  # [num], base, padding, pad char, sign
string.escend:


#---------------------------------------------------------------------------------
# Management


string.create:
	# Call  : 0 ? string.create ret
	# Effect: Allocates an empty string and returns its pointer.
	mem.getargs.0 ? mem.getargs .ret 0 .arg3 0 0
	0 ? mem.alloc .str string.struct.size
	0 ? mem.set .ret:0 .str
	0 0 .arg3:0
	# Variables
	.str:0


string.free:
	# Call  : 0 ? string.free str
	# Effect: Frees [str].
	mem.getargs.0 ? mem.getargs .str 2 .arg3 0 0
	0 ? mem.getidx .strptr .str string.struct.str
	0 ? mem.free .strptr
	0 ? mem.free .str
	0 0 .arg3:0
	# Variables
	.strptr:0
	.str:0


#---------------------------------------------------------------------------------
# Formatting


#|
string.writeinline:
	.ptr .z-1 .modify:?+1
.ret:
	.tmp

string.writestring:
	# Call  : 0 ? string.writestring [ret] [fmt]
	# Effect:
|#


#---------------------------------------------------------------------------------
# Input/Output

#|
string.print:
	# Call  : 0 ? string.print char0 char1 char2 ... 0
	# Effect: Prints a zero terminated ASCII string. If an escape code is used,
	#       : the next value(s) are expected to be numbers or formatting.
	# Use [0] to get the calling address.
	0       .z+2    ?+1
	.ptr    .ptr    ?+1
	.ptr    0       ?+1
	.fmt+string.struct.str-string.struct+1 .fmt+string.struct.str-string.struct+1 ?+1
	.fmt+string.struct.str-string.struct+1 0                                      ?+1
	.fmt+string.struct.len-string.struct+1 .fmt+string.struct.len-string.struct+1 ?+1
	.fmt+string.struct.len-string.struct+1 .ptr                                   ?+1
	0       0       .loop
.ret:
	.tmp
.loop:
	# Get the next character.
	.tmp    .ptr:0  ?+1
	# If [tmp]=0, we've reached the end of the string.
	.tmp    .z      .print
	# If [tmp]<=-256, then we want to print an escape character.
	.tmp    .esc    ?+7
	.ptr    .z-1    ?+1
	.tmp    .tmp    .loop
	# Print something other than a character.
	# If [tmp]+start-1<=start-end-1, abort.
	.tmp    .nesc   ?+1
	.tmp    .escmax .abort
	.tmp    .nargs  ?+1
	.ptr    .tmp:0  ?+1
	.tmp    .tmp    .loop
.print:
	.tmp    .ptr    ?+1
	.fmt+string.struct.len-string.struct+1 .tmp ?+1
	0 ? string.writestring .str .fmt
	# Print the string.
	.str+string.struct.len-string.struct+1 .z .printdone
	.tmp    .tmp    ?+1
	.tmp    .str+string.struct.str-string.struct+1 ?+1
	.pptr   .pptr   ?+1
	.pptr   .tmp    ?+4
.printloop:
	.str+string.struct.len-string.struct+1 .z+1 .printdone
	0-2     .pptr:0 ?+1
	.pptr   .z-1    .printloop
.printdone:
	# Free the string.
	0 ? mem.free .str+string.struct.str-string.struct+1
	.str+string.struct.str-string.struct+1 .str+string.struct.str-string.struct+1 ?+1
	.ptr    .z-1    .ret
.abort:
	0-1     0       ?-2
	# Variables
	0-1 .z:0 1 2
	# Number of arguments in escape codes in reverse order.
	0-6 0-6 0-2 0-5 0-5 0-2 0-4 0-4 0-2
	.esc:0-256
	.nesc:256-string.escstart+1
	.escmax:string.escstart-string.escend-1
	.nargs:0-2-.z
	.fmt:?+1 0 0
	.str:?+1 0 0
|#

string.print:
	# Call  : 0 ? string.print char0 char1 char2 ... 0
	# Effect: Prints a zero terminated ASCII string. If an escape code is used,
	#       : the next value(s) are expected to be numbers or formatting.
	# Use [0] to get the calling address.
	.ptr    .ptr    ?+1
	.ptr    0       ?+1
	.ptr    .z-2    ?+1
	0       0       .loop
.ret:
	0 ? mem.free .mem
	.mem    .mem    ?+1
	.memlen .memlen ?+1
	.tmp
.loop:
	# Get the next character.
	.tmp    .ptr:0  ?+1
	.ptr    .z-1    ?+1
	.char   .char   ?+1
	.char   .tmp    ?+1
	# If [char]=0, we've reached the end of the string.
	.char   .z      .ret
	# If [tmp]<=[escape], then we want to print a non-character.
	.tmp    .esc    .escprint
	# Print [char].
	0-2     .char   ?+1
	.tmp    .tmp    .loop
.escprint:
	# Print something other than a character.
	0       .ptr    ?+1
	0       .z-2    ?+1
	.padchr .padchr ?+1
	.padchr .paddef ?+1
	.retry  .retry  ?+1
	# Determine what type of value we're printing.
	.tmp    .nesc   .invalid
	.tmp    .z+1    .intinl
	.tmp    .z+1    .intfmt
	.tmp    .z+1    .int
	.tmp    .z+1    .uintinl
	.tmp    .z+1    .uintfmt
	.tmp    .z+1    .uint
	.tmp    .z+1    .strinl
	.tmp    .z+1    .strfmt
	.tmp    .z+1    .str
.invalid:
	# Print "INVALID FORMAT" and abort.
	.ilen   .z+1    .z-1
	0-2     .iptr   ?+1
	?-2     .z-1    .invalid
	.iptr: 'I 'N 'V 'A 'L 'I 'D '  'F 'O 'R 'M 'A 'T 10
	.ilen: .ilen-.iptr+1
.str:
	mem.getargs.0 ? mem.getargs .substr 2 .ptr 0 0
	0 ? mem.getidx .p0 .substr string.struct.str
	0 ? mem.getidx .retlen .substr string.struct.len
	.tmp    .tmp    .lenok+18
.strfmt:
	mem.getargs.0 ? mem.getargs .substr 2 .pad 2 .padchr 2 .ptr 0 0
	.tmp    .tmp    .str+8
.strinl:
	mem.getargs.0 ? mem.getargs .substr 2 .pad 1 .padchr 1 .ptr 0 0
	.tmp    .tmp    .str+8
.uint:
	.retry  ?+2     ?+2  0-uint.writestring-36
	mem.getargs.0 ? mem.getargs ?+12 1 .ptr 0 0
	0 ? uint.writestring .mem .memlen .z .retlen 0 .base
	.tmp    .tmp    .write
.uintfmt:
	.retry  ?+2     ?+2  0-uint.writestring-36
	mem.getargs.0 ? mem.getargs ?+18 1 ?+17 1 .pad 2 .padchr 2 .ptr 0 0
	0 ? uint.writestring .mem .memlen .z .retlen 0 0
	.tmp    .tmp    .write
.uintinl:
	.retry  ?+2     ?+2  0-uint.writestring-36
	mem.getargs.0 ? mem.getargs ?+18 1 ?+17 0 .pad 1 .padchr 1 .ptr 0 0
	0 ? uint.writestring .mem .memlen .z .retlen 0 0
	.tmp    .tmp    .write
.int:
	.retry  ?+2     ?+2  0-int.writestring-39
	mem.getargs.0 ? mem.getargs ?+12 1 .ptr 0 0
	0 ? int.writestring .mem .memlen .z .retlen 0 .base .z
	.tmp    .tmp    .write
.intfmt:
	.retry  ?+2     ?+2  0-int.writestring-39
	mem.getargs.0 ? mem.getargs ?+20 1 ?+19 1 ?+18 1 .pad 2 .padchr 2 .ptr 0 0
	0 ? int.writestring .mem .memlen .z .retlen 0 0 0
	.tmp    .tmp    .write
.intinl:
	.retry  ?+2     ?+2  0-int.writestring-39
	mem.getargs.0 ? mem.getargs ?+20 1 ?+19 0 ?+18 0 .pad 1 .padchr 1 .ptr 0 0
	0 ? int.writestring .mem .memlen .z .retlen 0 0 0
	.tmp    .tmp    .write
.write:
	# If [retlen]<[memlen] we need to resize [mem] and retry.
	.retlen .memlen .lenok
	.tmp    .retlen ?+1
	.memlen .tmp    ?+1
	0 ? mem.realloc .mem .mem .memlen
	.mem    .z      .invalid
	.tmp    .tmp    .retry:0
.lenok:
	.tmp    .memlen ?+1
	.retlen .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .mem    ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	# Print padding.
	.pad    .retlen ?+10
	0-2     .padchr ?+1
	.pad    .z+1    ?+10
	0-2     .padchr ?-5
	.pad    .pad    ?+4
	# Print [mem].
	.retlen .z+1    ?+7
	0-2     .p0:0   ?+1
	.p0     .z-1    ?-8
	.tmp    .tmp    .loop
	# Variables
	0-2 0-1 .z:0 1
	.tmp:0
	.char:0
	.esc:0-256
	.nesc:256-string.escend
	.mem:0
	.memlen:0
	.retlen:0
	.substr:0
	# Formatting defaults
	.base:10
	.pad:0
	.padchr:0
	.paddef:0-32

