<!DOCTYPE HTML>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Unileq - A One Instruction Architecture</title>
	<link rel="stylesheet" href="../style/style.css" type="text/css">
	<script type="text/javascript" src="../style/style.js"></script>
	<script type="text/javascript" src="./unileq.js"></script>
	<script type="text/javascript" src="./editor.js"></script>
</head>
<body>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Header ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div id="header"><a href="../index.html">Alec Dee's Homepage</a></div>

<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Online Interpreter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div class="content"><h1>Unileq Online Editor</h1>
	<div style="text-align:center;">
		<button id="unileq_run">&#9654;&nbsp;&nbsp;&nbsp;Run</button>
		<button id="unileq_reset">&#8634;&nbsp;&nbsp;&nbsp;Reset</button>
		<button id="unileq_advanced">&#9776;&nbsp;&nbsp;&nbsp;Advanced</button>
		<label>Demos:
			<select id="unileq_demo">
				<option value="./libraries/helloworld_demo.unl">Hello World</option>
				<option value="./libraries/print_demo.unl">String Printing</option>
				<option value="./libraries/uint_demo.unl">Unsigned Math</option>
				<option value="./libraries/random_demo.unl">Random Numbers</option>
				<option value="./libraries/memory_demo.unl">Memory</option>
				<option value="./libraries/all_demo.unl">All Libraries</option>
				<option value="">Blank</option>
			</select>
		</label>
	</div>
	<div id="unileq_menu" class="codeblock" style="box-sizing:border-box;width:100%;display:none;font-family:sans-serif;white-space:normal;">
		<p>Advanced Settings</p><br>
		<input type="checkbox" id="unileq_keyboard" checked>
		<label for="unileq_keyboard"> Grab Keyboard:<br>
			<br>
			<span style="padding-left:2rem;">&bull;</span> Enables tab key<br>
			<span style="padding-left:2rem;">&bull;</span> F9: run<br>
			<span style="padding-left:2rem;">&bull;</span> F10: reset<br>
			<span style="padding-left:2rem;">&bull;</span> F11: release keyboard
		</label>
	</div>
	<textarea id="unileq_output" style="box-sizing:border-box;width:100%;height:14rem;" class="consoleblock" spellcheck="false" readonly>Please enable javascript to run</textarea>
	<textarea id="unileq_editor" style="box-sizing:border-box;width:100%;height:40rem;" class="codeblock" spellcheck="false">
	0 0 loop
loop:
	cnt one   done
	0-5 sleep loop
done:
	0-1 0 ?-2
	#Variables
	one:   1
	sleep: 71582788 #1/60
	cnt:   3601
</textarea>
</div>

<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Unileq Architecture ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div class="content"><h1>The Unileq Architecture</h1>
<p>Download the interpreter here: <a href="./unileq.c">unileq.c</a></p>
<br>
<p>The goal of unileq is to create the functionality of a normal computer using only one computing
instruction. This is like trying to build a working car out of legos while only using one type of
lego piece. Since we only have one instruction, most modern conveniences are gone. Things like
multiplying numbers or memory allocation need to built from scratch using unileq's instruction.</p>
<br>
<p>The instruction is fairly simple: Given <i>A</i>, <i>B</i>, and <i>C</i>, compute
<i>mem[A]-mem[B]</i> and store the result in <i>mem[A]</i>. Then, if <i>mem[A]</i> was less than
or equal to <i>mem[B]</i>, jump to <i>C</i>. Otherwise, jump by <i>3</i>. We use the instruction
pointer (<i>IP</i>) to keep track of our place in memory. The pseudocode below shows a unileq
instruction:</p>
<br>
<div class="codeblock langpython">A=mem[IP+0]
B=mem[IP+1]
C=mem[IP+2]
if mem[A]&lt;=mem[B]
     IP=C
else
     IP=IP+3
mem[A]=mem[A]-mem[B]
</div>
<br>
<p>The instruction pointer and memory values are all 64 bit unsigned integers. Overflow and
underflow are handled by wrapping values around to be between <i>0</i> and <i>2^64-1</i>
inclusive.</p>
<br>
<p>Interaction with the host environment is done by reading and writing from special memory
addresses. For example, writing anything to <i>-1</i> will end execution of the unileq
program.</p>
<br>
<p>Unileq is based off of the <a href="https://en.wikipedia.org/wiki/Subleq">subleq</a>
architecture.</p>
<br>
<h2>Unileq Assembly Language</h2>
<br>
<p>We can write a unileq program by setting the raw memory values directly, but it will be easier to
both read and write a program by using an assembly language. Because there's only one instruction,
we can omit any notation specifying what instruction to execute on some given memory values. The
flow of the program will decide what gets executed and what doesn't.</p>
<br>
<p>An outline of our language is given below:</p>
<br>
<table class="datatable headerrow">
<tr><td>Component</td><td>Description</td></tr>
<tr><td><i>#comment</i></td><td>Single line comment.</td></tr>
<tr><td><i>#|
	comment
|#</i></td><td>Multi line comment.</td></tr>
<tr><td><i>?</i></td><td>Inserts the current memory address.</td></tr>
<tr><td><i>Label:</i></td><td>Label declaration. Declarations mark the current memory address for
later recall. Declarations can't appear within an expression, ex: <i>0 label: +1</i>. Duplicate
declarations are an error.<br>
<br>
Labels are case sensitive and support UTF-8.<br>
First character: <i>a-zA-Z_.</i> and any character with a high bit<br>
Trailing characters: <i>a-zA-Z_.0-9</i> and any character with a high bit</td></tr>
<tr><td><i>Label</i></td><td>Inserts the memory address marked by <i>Label:</i>. There must be
whitespace or an operator between any two label recalls or numbers.</td></tr>
<tr><td><i>.Sublabel</i></td><td>Shorthand for placing a label under another label's scope. Ex:
<i>lbl:0 .sub:1</i> will be treated as <i>lbl:0 lbl.sub:1</i> internally.</td></tr>
<tr><td>Number</td><td>Inserts the number's value. A number must be in decimal or hexadecimal
form, such as <i>123</i> or <i>0xff</i>.</td></tr>
<tr><td>Operator <i>+-</i></td><td>Adds or subtracts the number or label from the previous value.
Parentheses are not supported. To express a negative number, use its unsigned form or the identity
<i>0-x=-x</i>.
<br>
There cannot be two consecutive operators, ex: <i>0++1</i>. Also, the program cannot begin or end
with an operator.</td></tr>
<tr><td>Input/Output</td><td>Interaction with the host environment can be done by reading or writing
from special addresses.<br>
<br>
<i>A = -1</i>: End execution.<br>
<i>A = -2</i>: Write <i>mem[B]</i> to stdout.<br>
<i>B = -3</i>: Subtract stdin from <i>mem[A]</i>.<br>
<i>B = -4</i>: Subtract current time from <i>mem[A]</i>.</td></tr>
</table>
</div>

<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Hello, World! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div class="content"><h1>Hello, World!</h1>
<p>We can show how the unileq assembly language and architecture work with a simple program that
prints "Hello, World!" to the screen:</p>
<br>
<div class="codeblock langunileq">loop: len  one   exit           #Decrement [len]. If [len]&lt;=1, exit.
      0-2  text  ?+1            #Print a letter.
      ?-2  neg   loop           #Increment letter pointer.
exit: 0-1  0     0

text: 72 101 108 108 111 44 32  #Hello,
      87 111 114 108 100 33 10  #World!
len:  len-text+1
one:  1
neg:  0-1
</div>
<br>
<p>The first 3 lines of the program define a loop, and at each iteration of the loop we print a new
character. Below the loop is a command to exit the program, followed by all of the data we need to
make the program work.</p>
<br>
<p>For brevity, we will use <i>[x]</i> as shorthand for <i>mem[x]</i>, the value at address
<i>x</i>. With that said, we can now describe what each line does.</p>
<br>
<div class="codeblock langunileq">loop: len  one   exit</div>
<br>
<p>The first line declares the label <i>loop:</i> to mark the memory address of where our loop
starts. It also contains the instruction <i>len one exit</i>. When this instruction is executed, it
will take the values at memory addresses <i>len</i> and <i>one</i>, subtract them, and store the
result back at <i>len</i>. That is, it will perform <i>[len]=[len]-[one]</i> which evaluates to
<i>[len]=[len]-1</i>. Also, if <i>[len]</i> is less than or equal to <i>[one]</i> (before
subtracting), then we will jump to <i>exit</i> and end the program.</p>
<br>
<p>Thus, when the program is running, we expect it to count from <i>len-text+1</i> down to <i>1</i>
and then exit.</p>
<br>
<div class="codeblock langunileq">      0-2  text  ?+1</div>
<br>
<p>The second instruction of our loop has <i>-2</i> as the first operand, which is a special output
address. When a program writes to this address, the interpreter won't execute a normal unileq
instruction. Instead it will will print the value of <i>[text]</i> to the screen.</p>
<br>
<div class="codeblock langunileq">      ?-2  neg   loop</div>
<br>
<p>The third instruction is used to advance to the next character to print and restart the loop.
Recall from the assembly specification that <i>?</i> refers to the current address, so <i>?-2</i>
refers to two memory addresses back. In this case, it points to the previous instruction where
<i>text</i> is. When this instruction executes, <i>-1</i> will be subtracted from <i>text</i>, which
will have the effect of advancing to the next character that we want to print. Since we are using
unsigned arithmetic, <i>[neg]=-1=2^64-1</i> will be greater than or equal to any other value. Thus
this instruction will always jump to <i>loop</i> and restart the loop.</p>
<br>
<div class="codeblock langunileq">exit: 0-1  0     0</div>
<br>
<p>The last instruction of our program uses another special address. In this case, writing anything
to <i>-1</i> will tell the interpreter to end the program. Note, we do not specifically need to use
<i>0-1</i> as the first operand. Any expression that evaluates to <i>-1</i>, such as <i>2-3</i>,
will also work.</p>
<br>
<div class="codeblock langunileq">text: 72 101 108 108 111 44 32
      87 111 114 108 100 33 10</div>
<br>
<p>Here we define the ASCII character codes for the text "Hello, World!", plus an end-of-line
character.</p>
<br>
<div class="codeblock langunileq">len:  len-text+1</div>
<br>
<p>This line is a quick and dirty way of calculating the length of the text we want to print. We
need to add <i>1</i> to the length since we abort at <i>1</i> instead of <i>0</i>.</p>
<br>
<div class="codeblock langunileq">one:  1
neg:  0-1</div>
<br>
<p>And the last 2 lines define the constants <i>1</i> and <i>-1</i>.</p>
<br>
<p>This section appears to be rather long, given that we are going over a simple program. However,
it is only long because it is meant as an introduction, and we are trying to be thorough with
explanations. The next section will be more terse.</p>
</div>

<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Synthesized Instructions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div class="content"><h1>Synthesized Instructions</h1>
<p>Although printing text to the screen is easy, we will need to synthesize more complicated
instructions to serve as building blocks when we make more complicated programs. In future articles,
we will also show how to turn these synthesized instructions into easy to call functions from within
unileq. For now, we are only focusing on basic instructions in order to show how the unileq
architecture works.</p>
<br>
<p>For these code blocks, <i>tmp</i> will denote an address for a temporary variable. It can have
any value at the start of the block, so we'll usually need to zero it out. We will also continue the
use of <i>[x]</i> as shorthand for <i>mem[x]</i>, or the value at address <i>x</i>.</p>
<br>
<p>Up first is one of the most common instructions, an unconditional jump to <i>jmp</i>. It also
sets <i>[tmp]=0</i>.</p>
<br>
<div class="codeblock langunileq">tmp  tmp  jmp</div>
<br>
<p>We can abort a unileq program by writing any value to <i>-1</i>. Note that we need to calculate
<i>-1</i> as "<i>0-1</i>" due to the syntax our assembly language.</p>
<br>
<div class="codeblock langunileq">0-1  0  0</div>
<br>
<p>Set <i>[a]=[b]</i>. The series of <i>?+1</i> expressions points to the next memory address after
the instruction. They simply serve to force the instruction pointer to go to the next instruction
regardless of whether or not the instruction would jump.</p>
<br>
<div class="codeblock langunileq">tmp  tmp  ?+1  #[tmp]=0
tmp  b    ?+1  #[tmp]=-[b]
a    a    ?+1  #[a]=0
a    tmp  ?+1  #[a]=-(-[tmp])=[b]
</div>
<br>
<p>Jump to <i>jmp</i> if <i>[a]=[b]</i>.</p>
<br>
<div class="codeblock langunileq">tmp1  tmp1  ?+1  #[tmp1]=0
tmp1  b     ?+1  #[tmp1]=-[b]
tmp2  tmp2  ?+1  #[tmp2]=0
tmp2  tmp1  ?+1  #[tmp2]=-[tmp1]=[b]
tmp2  a     ?+1  #[tmp2]=[b]-[a]
tmp1  tmp1  ?+1  #[tmp1]=0
tmp2  tmp1  jmp  #if [tmp2]&lt;=0, then [a]=[b], so jump
</div>
<br>
<p>We can print the character "A" to the screen by writing it to the special address <i>-2</i>. We
define <i>char</i> to be the ASCII code for "A".</p>
<br>
<div class="codeblock langunileq">0-2  char  ?+1
char: 65
</div>
<br>
<p>Increment <i>[a]</i>. This will always jump to the jump address.</p>
<br>
<div class="codeblock langunileq">a  neg  ?+1  #[a]=[a]-[neg]=[a]-(-1)=[a]+1
neg: 0-1
</div>
<br>
<p>Decrement <i>[a]</i>.</p>
<br>
<div class="codeblock langunileq">a  one  ?+1  #[a]=[a]-[one]=[a]-1
one: 1
</div>
<br>
<p>Set <i>[C]=[[A]+[B]]</i>. This is the same as getting the value at an array index, as in
<i>C=arr[i]</i> in other languages. This will form the backbone of functions in unileq.</p>
<br>
<div class="codeblock langunileq">tmp  tmp    ?+1
tmp  A      ?+1
tmp  B      ?+1  #[tmp]=-[A]-[B]
ptr  ptr    ?+1
ptr  tmp    ?+1  #[ptr]=[A]+[B]
tmp  tmp    ?+1
tmp  ptr:0  ?+1  #[tmp]=-[[A]+[B]]
C    C      ?+1
C    tmp    ?+1  #[C]=[[A]+[B]]
</div>
<br>
<p>Set <i>[[A]+[B]]=[C]</i>. This is the same as assigning a value to an array, as in
<i>arr[i]=C</i>. Assume <i>[p0]=[p1]=[p2]</i>.</p>
<br>
<div class="codeblock langunileq">p0    A     ?+1
p0    B     ?+1  #[p0]=[p0]-[A]-[B]
p1    p0    ?+1  #[p1]=[A]+[B]
p2    p0    ?+1  #[p2]=[A]+[B]
tmp   tmp   ?+1
tmp   p1    ?+1
p0    p0    ?+1
p0    tmp   ?+1  #[p0]=[A]+[B]
tmp   tmp   ?+1
tmp   C     ?+1
p0:0  p1:0  ?+1  #[[A]+[B]]=0
p2:0  tmp   ?+1  #[[A]+[B]]=[C]
</div>
<br>
<p>If we allow a unileq instruction to be atomic, we can actually create a spinlock. When the lock
is first acquired, the value of <i>[lock+1]</i> is overwritten from <i>z-1</i> to <i>z-1-[z-1]=z</i>
and we jump to the critical section. When a second thread tries to acquire the lock, it will
subtract <i>[z]=0</i> from <i>z</i>, which will fail to jump, and the thread will be caught by the
next instruction, <i>z z lock</i>. When the owning thread is done with the lock, it just needs to
subtract <i>[z+1]=1</i> from <i>[lock]</i> to allow the lock to be acquired by a new thread.</p>
<br>
<div class="codeblock langunileq">lock: lock+1  z-1  crit  #acquire lock
      z       z    lock  #failed to acquire, try again
crit:                    #
                         #critical section
                         #
      lock+1  z+1  ?+1   #reopen spinlock
      z       z    jmp   #jump
      0-1 z:0 1
</div>
</div>

<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Architecture Properties ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div class="content"><h1>Architecture Properties</h1>
<p>Unileq belongs to the family of one instruction architectures, like the
<a href="https://www.ece.ucsb.edu/~parhami/pubs_folder/parh88-ijeee-ultimate-risc.pdf">subleq</a>
architecture it's based off of. This section will go over the theoretical and practical properties
that unileq has. First, however, it is necessary to outline the differences between unileq and
subleq.</p>
<br>
<p>Whereas subleq uses 2's complement signed arithmetic, unileq uses unsigned arithmetic. There are
several reasons for this:</p>
<br>
<table class="listtable">
<tr><td>&bull;</td><td>We may use the entire address range, instead of only the non-negative
addresses subleq allows.</td></tr>
<tr><td>&bull;</td><td>Unileq offers 3 ways to guarantee a jump<br>
<br>
<span style="margin-left:2rem;"></span>1. Zeroing an address: <i>A  A  jmp</i><br>
<span style="margin-left:2rem;"></span>2. Subtracting anything from <i>0</i>: <i>Z  A  jmp</i><br>
<span style="margin-left:2rem;"></span>3. Subtracting <i>-1</i> from anything:
<i>A  Z-1  jmp</i><br>
<br>
Subleq can only guarantee a jump by zeroing an address. This gives unileq more options when deciding
program flow, since these are all common operations.
</td></tr>
<tr><td>&bull;</td><td>In unsigned arithmetic, if <i>A&gt;B</i>, then we know that <i>A-B&gt;0</i>.
This does not hold in signed arithmetic.</td></tr>
<tr><td>&bull;</td><td>Using the instruction <i>A Z jmp</i>, we can test <i>A</i> for equality
with <i>0</i> using only one instruction and without modifying any variables. This a common value to
test for. Subleq, would require 1 to 2 instructions and modifying <i>A</i> for this test.</td></tr>
</table>
<br>
<p>Unileq also uses a different order for operands. With unileq, for operands <i>A</i>, <i>B</i>,
and <i>C</i>, we take <i>[A]=[A]-[B]</i>, where subleq takes <i>[B]=[B]-[A]</i>. The order of
operands in subleq is perfectly valid, of course, but goes against the standard ordering used in
programming. For example, we usually write <i>a=b+c</i> instead of <i>b+c=a</i>. In an early version
of unileq, I used the subleq order of operands and found myself constantly having to reorder the
operands in my head. Thus I decided swap the roles of <i>A</i> and <i>B</i>.</p>
<br>
<p>So, with comparisons done, we can now go over the properties of the unileq architecture.</p>
<br>
<h2>Self Modifying</h2>
<br>
<p>Compared to modern architectures which prevent the modification of code for security reasons,
unileq programs require some amount of self modification to do anything useful at all. This can most
easily be seen in the "Hello, World!" program in the section above. Specifically, the lines</p>
<br>
<div class="codeblock langunileq">0-2  text  ?+1   #Print a letter.
?-2  neg   loop  #Increment letter pointer.</div>
<br>
<p>Here we must modify part of an instruction where <i>text</i> is in order to print successive
characters in a string.</p>
<br>
<p>We can use this self modifying property to generate some simple programs at run time, or make a
self interpreter that counts the number of instructions used by another unileq function. However,
symbolic self modification, like that seen in Lisp, would be difficult to perform in unileq.</p>
<br>
<h2>Special Addresses</h2>
<br>
<p>As part of the unileq specification, reading and writing from special addresses can be used to
interact with the host environment. For instance, <i>0-1 0 ?+1</i> will end the program, and
<i>0-2 char ?+1</i> will print <i>[char]</i> to the screen. Without these addresses, a unileq
program would have no way to display its results or interact with its host computer. It would
effectively be a brain in a vat. There's no real way around this, given our one instruction
limit.</p>
<br>
<p>Some consideration was taken as to how to interact with the host. One choice was to confine all
host interaction to one address, such as <i>0-1 B C</i>. What this address would do would depend on
the values of <i>B</i> and <i>C</i>. After using this method for a while, I determined that it
doesn't work well with unileq as a whole. The ability to read and write from specific addresses
allows them to used as if we're reading and writing from any other memory position. My opinion of
this might change as I use unileq.</p>
<br>
<p>One major difference from subleq implementations is ending execution. Whereas unileq requires
writing to a specific address, most subleq implementations end execution by jump to any negative
address. Since unileq allows any address to be used, we needed an explicit address to end
execution.</p>
<br>
<h2>Turing Complete</h2>
<br>
<p>We set out at the beginning of the article to "build up to what a normal computer can do", which
begs the question of whether or not this goal is possible. We will prove that it's possible by
showing that unileq can replicate the operations in Minsky's
<a href="http://www.cba.mit.edu/events/03.11.ASE/docs/Minsky.pdf">Computation: Finite and
Infinite Machines</a>. By doing so, we will show that unileq is Turing complete and thus can
replicate any more complicated computer.</p>
<br>
<p>Let <i>regn</i> denote some register and let the following assembly code initialize our
program.</p>
<br>
<div class="codeblock langunileq">0 0 start
neg1: 0-1
pos1: 1
reg0: 0
reg1: 0
reg2: 0
#...
start:
</div>
<br>
<p>We have the operation <i>regn'</i>, which increments register <i>regn</i> and jumps to the next
instruction. In unileq, this can be performed by</p>
<br>
<div class="codeblock langunileq">regn  neg1  ?+1</div>
<br>
<p>And we have the second operation, <i>regn<sup>-</sup>(n)</i>, which jumps to some memory address
<i>n</i> if <i>regn=0</i>, otherwise it decrements <i>regn</i> and jumps to the next instruction. In
unileq, this can be performed by</p>
<br>
<div class="codeblock langunileq">regn  0     n
regn  pos1  ?+1</div>
<br>
<p>Thus, unileq is Turing complete.</p>
<br>
<h2>One Instruction</h2>
<br>
<p>This is also a good place to mention a common criticism I have come across in forum postings
while doing my research. That is: how can you say that a unileq (or subleq) instruction is "one"
instruction when it does so many things? After all, it performs a subtraction and then jumps, so it
should at least count as two instructions.</p>
<br>
<p>The most important thing to consider is the intent of the architecture. Most architectures have
a variety of instructions to perform a variety of actions by design. A unileq program is meant to be
composed of one simple instruction, and the goal is to build up to what a normal architecture can
do. If we get tied up by the definition of the architecture, then we'll lose the intent of it.</p>
<br>
<p>That being said, we can create a formal definition of what "one instruction" actually means. The
definition uses a simplified version of
<a href="https://sites.google.com/site/comparchampsite/Home">Laplante and Gilreath's</a> complexity
calculation: Given a set of memory addresses, is it possible to execute more than 1 instruction on
those memory addresses. For instance, consider addresses <i>A</i> and <i>B</i>. In a complex
architecture we could execute<br>
<br>
<div class="codeblock">add A, B
sub A, B
mul A, B
...
</div>
<br>
<p>etc, all on the same memory addresses. Whereas with unileq, given <i>A</i>, <i>B</i>, and
<i>C</i>, we always execute the same instruction. This definition offers a better argument in my
opinion, although it can be circumvented by mapping instructions to memory addresses as in transport
triggered architectures.</p>
</div>

<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Notes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div class="content"><h1>Notes</h1>
<p>Since writing this, the interpreter has been improved in a few ways:</p>
<br>
<table class="listtable">
<tr><td>&bull;</td><td>All memory allocation (ex: <i>malloc()</i>) is checked for failure.</td></tr>
<tr><td>&bull;</td><td>The parser underlines the section of text that yields an error.</td></tr>
<tr><td>&bull;</td><td>The parser checks for non-terminated block quotes.</td></tr>
<tr><td>&bull;</td><td>The parser uses a hash map instead of an AVL tree for matching
labels.</td></tr>
<tr><td>&bull;</td><td>Memory is held in a flat array instead of an AVL tree. When profiling a
unileq math library, the flat array was almost 100 times faster.</td></tr>
</table>
<br>
<p>The main downside with using a flat array to hold memory is that a lot of it can be dead space.
Although the array will grow if we try to access a memory address outside of its current allocation,
for speed reasons the array will not check if it can be shrunk. Using a paged memory system may
offer a decent balance between speed and wasted space. It would be used like so:</p>
<br>
<div class="codeblock">val=mem[addr&gt;&gt;48][(addr&gt;&gt;32)&amp;0xffff][(addr&gt;&gt;16)&amp;0xffff][addr&amp;0xffff]</div>
<br>
<p>However, testing on large applications will need to be done.</p>
<br>
<p>Creating an animated heat map showing memory activity would be useful in showing how the
architecture works to casual observers.</p>
<br>
<p>To support multithreading, make each instruction atomic. The interpreter can spawn threads by
writing to a special address. The new thread's instruction pointer would start at <i>[B]</i>.</p>
<br>
<p>Within the language, make a bitwise and integer arithmetic library. Also see if there is a self
synchronizing sequence of instructions. That is, if the <i>IP</i> were to randomly land anywhere in
this block of memory, could we always direct it to some safe memory address?</p>
<br>
<p>Unileq's name comes from "UNsigned Integer subtract and branch if Less than or EQual to".
Although "uni" implying "one" is a nice coincidence.</p>
<br>
<p><a href="./testing.zip">testing.zip</a> contains my unfinished work, as well as test cases for
the <a href="./unileq.c">unileq.c</a> interpreter.</p>
</div>

<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Footer ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div id="footer">Created on 9 Apr 2020 - Modified on 6 Oct 2021<br>
Questions and comments: akdee<b>OBFUS</b>144@g<b>CATE</b>mail.com<br>
<a href="../index.html">Alec Dee's Homepage</a></div>
</body>
</html>
