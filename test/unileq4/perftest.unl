#|==============================================================================

Unsigned Integer Testing - v1.05

Author: Alec Dee - alecdee.github.io - akdee144@gmail.com

--------------------------------------------------------------------------------

Linux:
rm unileq
rm unileq.gcda
gcc -fprofile-generate -march=native -O3 ../site/unileq/unileq.c -o unileq
./unileq perftest.unl
gcc -fprofile-use -march=native -O3 ../site/unileq/unileq.c -o unileq
rm unileq.gcda
time ./unileq perftest.unl

Windows:
remove-item "unileq.exe"
remove-item "default.*"
clang -O3 -fprofile-instr-generate -march=native unileq.c -o unileq.exe
.\unileq.exe
remove-item "default.*"
.\unileq.exe perftest.unl
llvm-profdata merge -output="default.profdata" "*.profraw"
clang -O3 -fprofile-instr-use="default.profdata" -march=native unileq.c -o unileq.exe
.\unileq.exe
(measure-command {.\unileq.exe perftest.unl | Out-Default}).TotalSeconds

--------------------------------------------------------------------------------
Notes

To compile the necessary files together, run
cat uinttest.unl uint.unl print.unl random.unl > test.unl
./unileq test.unl

average instructions per function
cmp: 28
set: 24
neg: 25
add: 30
sub: 31
mul: 878
div: 911
shl: 83
shr: 131
not: 26
and: 469
 or: 470
xor: 471

|#

0 0 test.main

test.main:
	#Starting integer tests.
	0 ? print 115 116 97 114 116 105 110 103 32 105 110 116 101 103 101 114 32 116 101 115 116 115 10 0

	#------------------------- Bits -------------------------
	#Calculate how many bits we're using. Set [hbit]=1<<(bits-1).
	.tmp0     .z-1   ?+1
	.bitloop:
	.tmp0     .z     .bitdone
	.hbit     .hbit  ?+1
	.hbit     .tmp0  ?+1
	.tmp0     .hbit  ?+1
	.bits     .z-1   .bitloop
	.bitdone:

	#Set other bit related values.
	.nbits    .bits  ?+1
	.nbits-1  .bits  ?+1
	.bits+1   .nbits ?+1
	.bits+2   .nbits ?+1
	.shiftmax .nbits ?+1
	.shiftmax .nbits ?+1
	.shiftmax .nbits ?+1
	.shiftsub .nbits ?+1
	.shiftsub .z-2   ?+1

	0 ? print 98 105 116 115 58 32 0-1 .bits 10 0

.loop:
	#While trial<trials.
	.tmp0 .tmp0 ?+1
	.tmp0 .trials ?+1
	.tmp1 .tmp1 ?+1
	.tmp1 .tmp0 ?+1
	.tmp1 .trial .done

	#---------------------- Parameters ----------------------
	#Generate A, B, and C parameters.
	0 ? test.rand.uint .a
	0 ? test.rand.uint .b
	0 ? random.mod     .c .shiftmax
	.c .shiftsub ?+1

	#Randomly set A=B.
	0 ? random.mod     .tmp0 .eqprob
	.tmp0 .z    ?+4
	.tmp0 .tmp0 .nosetab
	.tmp0 .b    ?+1
	.a    .a    ?+1
	.a    .tmp0 ?+1
	.nosetab:

	#Copy A, B, and C to compare later.
	.tmp0 .tmp0 ?+1
	.tmp0 .a    ?+1
	.a0   .a0   ?+1
	.a0   .tmp0 ?+1
	.tmp0 .tmp0 ?+1
	.tmp0 .b    ?+1
	.b0   .b0   ?+1
	.b0   .tmp0 ?+1
	.tmp0 .tmp0 ?+1
	.tmp0 .c    ?+1
	.c0   .c0   ?+1
	.c0   .tmp0 ?+1

	#0 ? print 0-1 .trial 32 0-1 .a 32 0-1 .b 32 0-1 .c 10 0

	#----------------------- Compare ------------------------
	#Compare A and B manually.
	.exp0 .exp0 ?+1
	.exp0 .z-1  ?+1
	.b    .a    ?+4
	.exp0 .z+1  ?+7
	.b    .z    ?+4
	.exp0 .z-1  ?+1
	.tmp0 .tmp0 ?+1
	.tmp0 .a    ?+1
	.b    .tmp0 ?+1

	.ret0 .ret0 ?+1
	0 ? test.measure .cmpops .cmplt 0 ? uint.cmp .a .b .cmplt .cmpeq .cmpgt
	0-1 0 0
	.cmpgt: .ret0   .z-1  ?+1
	.cmpeq: .ret0   .z-1  ?+1
	.cmplt: .cmpops .ret0 ?+1
	0 ? test.cmp .exp0 .ret0 0

	#------------------------- Set --------------------------
	0 ? test.measure .setops ?+6 0 ? uint.set .ret0 .a
	0 ? test.cmp .a .ret0 1

	#----------------------- Negation -----------------------
	#Calculate -A manually.
	.exp0 .exp0 ?+1
	.exp0 .a    ?+1

	0 ? test.measure .negops ?+6 0 ? uint.neg .ret0 .a
	0 ? test.cmp .exp0 .ret0 2

	#----------------------- Addition -----------------------
	#Calculate A+B manually.
	.tmp0 .tmp0 ?+1
	.tmp0 .a    ?+1
	.tmp0 .b    ?+1
	.exp0 .exp0 ?+1
	.exp0 .tmp0 ?+1

	0 ? test.measure .addops ?+7 0 ? uint.add .ret0 .a .b
	0 ? test.cmp .exp0 .ret0 3

	#--------------------- Subtraction ----------------------
	#Calculate A-B manually.
	.exp0 .b    ?+1
	.exp0 .b    ?+1

	0 ? test.measure .subops ?+7 0 ? uint.sub .ret0 .a .b
	0 ? test.cmp .exp0 .ret0 4

	#-------------------- Multiplication --------------------
	#Calculate A*B manually.
	.exp0 .exp0 ?+1
	#[tmp1]=[a]
	.tmp0 .tmp0 ?+1
	.tmp0 .a    ?+1
	.tmp1 .tmp1 ?+1
	.tmp1 .tmp0 ?+1
	#[tmp2]=65
	.tmp2 .tmp2 ?+1
	.tmp2 .nbits-1 ?+1
	.mulloop:
	.tmp2 .z+1  .muldone
	#exp<<=1
	.tmp0 .tmp0 ?+1
	.tmp0 .exp1 ?+1
	.exp1 .tmp0 ?+1
	.tmp0 .tmp0 ?+1
	.tmp0 .exp0 ?+1
	.tmp0 .z+1  ?+1
	.exp0 .tmp0 ?+4
	#If [exp0] carries.
	.exp1 .z-1  ?+1
	.exp0 .z+1  ?+1
	#[tmp1]<<=1
	.tmp0 .tmp0 ?+1
	.tmp0 .tmp1 ?+1
	.tmp0 .z+1  ?+1
	.tmp1 .tmp0 .mulloop
	#[exp0]+=[b]
	.tmp0 .tmp0 ?+1
	.tmp0 .b    ?+1
	.tmp0 .z+1  ?+1
	.exp0 .tmp0 ?+4
	.exp1 .z-1  ?+1
	.exp0 .z+1  ?+1
	.tmp0 .tmp0 .mulloop
	.muldone:

	0 ? test.measure .mulops ?+8 0 ? uint.mul .ret1 .ret0 .a .b
	0 ? test.cmp .exp0 .ret0 5
	0 ? test.cmp .exp1 .ret1 6

	#----------------------- Division -----------------------
	#For B!=0, q=A/B, and r=A%B, we have A=q*B+r and r<B.
	.b .z .div0
	.divden .z-1 ?+1
	0 ? test.measure .divops ?+8 0 ? uint.div .ret0 .ret1 .a .b
	0 ? uint.cmp .ret1 .b .remlt ?+2 ?+1
	0 ? test.cmp .z .b 7
	.remlt:
	0 ? uint.mul .tmp0 .tmp1 .ret0 .b
	0 ? test.cmp .z .tmp0 8
	0 ? uint.add .tmp1 .ret1 .tmp1
	0 ? test.cmp .a .tmp1 9
	.div0:

	#---------------------- Shift Left ----------------------
	#Calculate A<<C manually.
	#[exp0]=[a]
	.tmp0 .tmp0 ?+1
	.tmp0 .a    ?+1
	.exp0 .exp0 ?+1
	.exp0 .tmp0 ?+1
	#[tmp2]=-[c]
	.tmp2 .tmp2 ?+1
	.tmp2 .c    ?+1
	.shlloop:
	.exp0 .z    .shldone
	.tmp2 .z    .shldone
	.tmp0 .tmp0 ?+1
	.tmp0 .exp0 ?+1
	.exp0 .tmp0 ?+1
	.tmp2 .z-1  .shlloop
	.shldone:

	0 ? test.measure .shlops ?+7 0 ? uint.shl .ret0 .a .c
	0 ? test.cmp .exp0 .ret0 10

	#--------------------- Shift Right ----------------------
	#Calculate A>>C manually.
	.exp0 .exp0 ?+1
	#[tmp1]=[a]
	.tmp0 .tmp0 ?+1
	.tmp0 .a    ?+1
	.tmp1 .tmp1 ?+1
	.tmp1 .tmp0 ?+1
	#[tmp2]=-[c]-1
	.tmp2 .tmp2 ?+1
	.tmp2 .c    ?+1
	.tmp2 .z+1  ?+1
	.shrloop:
	.tmp2 .nbits-1 .shrdone
	.tmp2 .bits+2 ?+1
	#[exp0]<<=1
	.tmp0 .tmp0 ?+1
	.tmp0 .exp0 ?+1
	.exp0 .tmp0 ?+1
	#[tmp1]<<=1
	.tmp0 .tmp0 ?+1
	.tmp0 .tmp1 ?+1
	.tmp0 .z+1  ?+1
	.tmp1 .tmp0 .shrloop
	.exp0 .z-1  .shrloop
	.shrdone:

	0 ? test.measure .shrops ?+7 0 ? uint.shr .ret0 .a .c
	0 ? test.cmp .exp0 .ret0 11

	#------------------------- Not --------------------------
	#~A=-1-A
	.exp0 .exp0 ?+1
	.exp0 .z+1  ?+1
	.exp0 .a    ?+1

	0 ? test.measure .notops ?+6 0 ? uint.not .ret0 .a
	0 ? test.cmp .exp0 .ret0 12

	#------------------------- And --------------------------
	#Calculate A&B manually.
	#[exp0]=[a]
	.tmp0 .tmp0 ?+1
	.tmp0 .a    ?+1
	.exp0 .exp0 ?+1
	.exp0 .tmp0 ?+1
	#[exp1]=[b]
	.tmp0 .tmp0 ?+1
	.tmp0 .b    ?+1
	.exp1 .exp1 ?+1
	.exp1 .tmp0 ?+1
	#[tmp2]=65
	.tmp2 .tmp2 ?+1
	.tmp2 .nbits-1 ?+1
	.andloop:
	.tmp2 .z+1  .anddone
	#[exp0]<<=1
	.tmp0 .tmp0 ?+1
	.tmp0 .exp0 ?+1
	.exp0 .tmp0 ?+1
	#[exp1]<<=1
	.tmp1 .tmp1 ?+1
	.tmp1 .exp1 ?+1
	.tmp1 .z+1  ?+1
	#Set [exp0] if both carry.
	.exp1 .tmp1 .andloop
	.tmp0 .z    .andloop
	.tmp0 .hbit ?+4
	.tmp0 .tmp0 .andloop
	.exp0 .z-1  .andloop
	.anddone:

	0 ? test.measure .andops ?+7 0 ? uint.and .ret0 .a .b
	0 ? test.cmp .exp0 .ret0 13

	#-------------------------- Or --------------------------
	#A|B=A+B-(A&B)
	.ret0 .a    ?+1
	.ret0 .b    ?+1
	.exp1 .exp1 ?+1
	.exp1 .ret0 ?+1

	0 ? test.measure .orops ?+7 0 ? uint.or .ret0 .a .b
	0 ? test.cmp .exp1 .ret0 14

	#------------------------- Xor --------------------------
	#A^B=(A|B)-(A&B)
	.exp1 .exp0 ?+1

	0 ? test.measure .xorops ?+7 0 ? uint.xor .ret0 .a .b
	0 ? test.cmp .exp1 .ret0 15

	#Make sure parameters haven't been modified.
	0 ? test.cmp .a0 .a 16
	0 ? test.cmp .b0 .b 17
	0 ? test.cmp .c0 .c 18

	.trial .z-1 .loop

.done:
	#Print instruction counts.
	0 ? uint.div .cmpops 0 .cmpops .trial
	0 ? uint.div .setops 0 .setops .trial
	0 ? uint.div .negops 0 .negops .trial
	0 ? uint.div .addops 0 .addops .trial
	0 ? uint.div .subops 0 .subops .trial
	0 ? uint.div .mulops 0 .mulops .trial
	0 ? uint.div .divops 0 .divops .divden
	0 ? uint.div .shlops 0 .shlops .trial
	0 ? uint.div .shrops 0 .shrops .trial
	0 ? uint.div .notops 0 .notops .trial
	0 ? uint.div .andops 0 .andops .trial
	0 ? uint.div  .orops 0  .orops .trial
	0 ? uint.div .xorops 0 .xorops .trial
	0 ? print 97 118 101 114 97 103 101 32 105 110 115 116 114 117 99 116 105 111
	          110 115 32 112 101 114 32 102 117 110 99 116 105 111 110 10 0
	0 ? print  99 109 112 58 32 0-1 .cmpops 10 0
	0 ? print 115 101 116 58 32 0-1 .setops 10 0
	0 ? print 110 101 103 58 32 0-1 .negops 10 0
	0 ? print  97 100 100 58 32 0-1 .addops 10 0
	0 ? print 115 117  98 58 32 0-1 .subops 10 0
	0 ? print 109 117 108 58 32 0-1 .mulops 10 0
	0 ? print 100 105 118 58 32 0-1 .divops 10 0
	0 ? print 115 104 108 58 32 0-1 .shlops 10 0
	0 ? print 115 104 114 58 32 0-1 .shrops 10 0
	0 ? print 110 111 116 58 32 0-1 .notops 10 0
	0 ? print  97 110 100 58 32 0-1 .andops 10 0
	0 ? print  32 111 114 58 32 0-1  .orops 10 0
	0 ? print 120 111 114 58 32 0-1 .xorops 10 0
	0 ? print 112 97 115 115 101 100 10 0
	0-1 0 0

	#Variables
	0-2 0-1 .z:0 1
	.a:0
	.b:0
	.c:0
	.eqprob:64
	.hbit:0
	0-1 .nbits:0
	.bits:0 1 2
	.shiftmax:0
	.shiftsub:0
	.cmpops:0
	.setops:0
	.negops:0
	.addops:0
	.subops:0
	.mulops:0
	.divops:0
	.divden:0
	.shlops:0
	.shrops:0
	.notops:0
	.andops:0
	.orops:0
	.xorops:0
	.trial:0
	.trials:22500
	.exp0:0
	.exp1:0
	.ret0:0
	.ret1:0
	.tmp0:0
	.tmp1:0
	.tmp2:0
	#Place these far away from .a, .b, and .c in order to minimize accidental use
	#by functions.
	.a0:0
	.b0:0
	.c0:0

test.rand.uint:
	#Call  : 0 ? test.rand ret
	#Effect: [ret]=(rand)
	#Generate a random integer such that the probability of any bitcount is uniform.
	#Setup new stack.
	.tmp0 .tmp0 ?+1
	.tmp0 .p0   ?+1
	0     .z+2  ?+1
	0     .tmp0 ?+1
	.p0   0     ?+1
	.addr 0     ?+1
	0     0     ?+1
	#Get [ret]
	.tmp0 .tmp0 ?+1
	.tmp0 .p0:0 ?+1
	.p5   .p5   ?+1
	.p5   .tmp0 ?+1
	.p6   .p6   ?+1
	.p6   .tmp0 ?+1
	#Shuffle arr.
	0 ? random.shuffle .arr0 test.main.bits
	#Calculate how many bits we want to set.
	0 ? random.mod .i test.main.bits
	.tmp0 .tmp0 ?+1
	.b0   .b0   ?+1
	.b0   .narr ?+1
	.i    .z-1  ?+1
.setbits:
	.i    .z+1  .setdone
	.tmp0 .b0:0 ?+1
	.b0   .z-1  .setbits
.setdone:
	#Return
	.tmp1 .tmp1 ?+1
	.tmp1 .p5:0 ?+1
	.tmp0 .tmp1 ?+1
	.p6:0 .tmp0 ?+1  #[ret]=[rand]
	0     0     .addr:1
	#Variables
	0-1 .z:0 1 2
	.tmp0:0
	.tmp1:0
	.i:0
	.arr:
		0x1 0x2 0x4 0x8 0x10 0x20 0x40 0x80 0x100 0x200 0x400 0x800 0x1000 0x2000 0x4000
		0x8000 0x10000 0x20000 0x40000 0x80000 0x100000 0x200000 0x400000 0x800000
		0x1000000 0x2000000 0x4000000 0x8000000 0x10000000 0x20000000 0x40000000
		0x80000000 0x100000000 0x200000000 0x400000000 0x800000000 0x1000000000
		0x2000000000 0x4000000000 0x8000000000 0x10000000000 0x20000000000 0x40000000000
		0x80000000000 0x100000000000 0x200000000000 0x400000000000 0x800000000000
		0x1000000000000 0x2000000000000 0x4000000000000 0x8000000000000 0x10000000000000
		0x20000000000000 0x40000000000000 0x80000000000000 0x100000000000000
		0x200000000000000 0x400000000000000 0x800000000000000 0x1000000000000000
		0x2000000000000000 0x4000000000000000 0x8000000000000000
	.arr0:.arr
	.narr:0-.arr

test.cmp:
	#Call  : 0 ? test.cmp exp val id
	#Setup stack.
	.tmp  .tmp  ?+1
	.tmp  .p0   ?+1
	0     .tmp  ?+1
	0     .z+2  ?+1
	.p0   0     ?+1
	.p2   0     ?+1
	.id   0     ?+1
	.ret  0     ?+1
	0     0     ?+1
	#Get [exp]
	.tmp  .tmp  ?+1
	.tmp  .p0:0 ?+1
	.p1   .p1   ?+1
	.p1   .tmp  ?+1
	.tmp  .tmp  ?+1
	.tmp  .p1:0 ?+1
	.exp  .tmp  ?+1
	#Get [val]
	.tmp  .tmp  ?+1
	.tmp  .p2:1 ?+1
	.p3   .p3   ?+1
	.p3   .tmp  ?+1
	.tmp  .tmp  ?+1
	.tmp  .p3:0 ?+1
	.val  .val  ?+1
	.val  .tmp  ?+1
	#Compare [exp] and [val].
	.exp  .val  ?+1
	.exp  .z    .ret:3
	.exp  .tmp  ?+1
	#ERROR
	0 ? print 69 82 82 79 82 10 0
	#line
	0 ? print 116 114 105 97 108 32 58 32 0-1 test.main.trial 10 0
	#test
	0 ? print 116 101 115 116 32 32 58 32 0-1 .id:2 10 0
	#expect
	0 ? print 101 120 112 101 99 116 58 32 0-1 .exp 10 0
	#return
	0 ? print 114 101 116 117 114 110 58 32 0-1 .val 10 0
	0-1 0 0
.exp:0
.val:0
.z:0 1 2
.tmp:0

test.measure:
	#0 ? test.measure counter return 0 ? func arg0 arg1 ...
	#counter = the address for counting instructions.
	#return  = address the function will return to when finished.
	#Emulates the execution of a function and measures how many instructions it uses.
	#Uses 24+20*n instructions for n emulated instructions.
	.tmp    .a0     ?+1
	.nret   .tmp    ?+1
	.tmp    0       ?+1
	.dif    .tmp    ?+1
	.dif    .z+4    ?+1
	#Setup counter.
	0       .z+2    ?+1
	.p0     .p0     ?+1
	.p0     0       ?+1
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1
	.cnt    .cnt    ?+1
	.cnt    .tmp    ?+1
	#Get the negative return address. If [nret]+[dif0]+[dif1]+...=0, then return.
	0       .z+1    ?+1
	.p1     .p1     ?+1
	.p1     0       ?+1
	.nret   .p1:0   ?+1
	#Reset stack address.
	0       0       .loop
.jmp:
	#We jumped, set [dif]=[a0]-[c].
	.tmp    .tmp    ?+1
	.tmp    .a0     ?+1
	.dif    .tmp    ?+1
.loop:
	#Update a, b, and c addresses.
	.a0     .dif    ?+1
	.b0     .dif    ?+1
	.c0     .dif    ?+1
	.nret   .dif    ?+1
	.dif    .dif    ?+1
	#Return if ip=[ret].
	.nret   .z      .ret
	#Increment the instruction counter.
	.cnt:0  .z-1    ?+1
	#Load [a]. a0 will hold the return address when we're done.
	.tmp    .tmp    ?+2
	.ret:   .tmp
	.tmp    .a0:0   ?+1
	.a      .a      ?+1
	.a      .tmp    ?+1
	#Load [b].
	.tmp    .tmp    ?+1
	.tmp    .b0:1   ?+1
	.b      .b      ?+1
	.b      .tmp    ?+1
	#Set [dif]=-[c].
	.dif    .c0:2   ?+1
	#Execute instruction.
	.a:0    .b:0    .jmp
	#We failed to jump, set [dif]=-3.
	.dif    .dif    ?+1
	.dif    .z+3    .loop
	#Variables
	.tmp:0
	.nret:0
	.dif:0
	0-2 0-1 .z:0 1 2 3 4

#|==============================================================================

Unsigned Integer Operations - v3.09

Author: Alec Dee - alecdee.github.io - akdee144@gmail.com

--------------------------------------------------------------------------------
Notes

This library provides functions for performing most of the common unsigned
integer operations. In particular, it handles comparisons, arithmetic, and
bitwise operations.

Almost all functions are bit length agnostic. That is, they don't need to be
modified even if unileq uses a something other than 64 bit integers. The only
functions that need the bit length set are uint.mul and uint.div.

The 0 address will always be 0 upon function return, even if one of the return
value addresses is 0.

This library does not depend on any other libraries.

Worst case time complexity:

       Function  |  Time  |     O(n)
     ------------+--------+--------------
          cmp    |    29  |  29
          set    |    24  |  24
          neg    |    25  |  25
          add    |    30  |  30
          sub    |    31  |  31
          mul    |   993  |  33+15*bits
          div    |  1006  |  46+15*bits
          shl    |   185  |  56+17*((bits-1)//8)
          shr    |   546  |  34+8*bits
          not    |    26  |  26
          and    |   485  |  44+7*bits
           or    |   486  |  45+7*bits
          xor    |   487  |  46+7*bits

--------------------------------------------------------------------------------
Index

Comparisons
uint.cmp a b lt eq gt

Integer Arithmetic
uint.set ret a
uint.neg ret a
uint.add ret a b
uint.sub ret a b
uint.mul high low a b
uint.div quot rem num den

Bitwise Arithmetic
uint.shl ret num shift
uint.shr ret num shift
uint.not ret a
uint.and ret a b
uint.or  ret a b
uint.xor ret a b

--------------------------------------------------------------------------------
Version History

1.00
     Initial version. Used uint.cmp, mem.get, and mem.set for proof of concept.
     Functions take tens of thousands of instructions.
2.00
     Unrolled functions so they don't use mem.get and mem.set.
     Functions take thousands of instructions.
3.00
     Optimized functions so they are all under 1100 instructions.
3.01
     Optimized uint.and, or, and xor so the final value is stored in [a]. This
     removes the need for a temporary storage variable.
     Cleaned up uint.cmp so its branching is more straight forward.
3.02
     Optimized uint.set and uint.add to remove 1 instruction.
3.03
     Fixed an error in uint.mul when carrying from low to high. Removed need to
     offset [b] by 1 to check for carrying.
     Updated formatting for uint.cmp.
     Changed uint.div to abort with 0xd0 when dividing by 0.
     Optimized AND/OR/XOR by skipping first loop check.
3.04
     Optimized AND/OR/XOR by 18%. [a] and [b] only need to be offset by 1 on the
     first loop. This removes 2 decrement instructions per loop.
3.05
     Optimized AND/OR/XOR by 11%. Removed the iteration counter and instead
     check if [b]=0. We only set the bottom bit of [a] in 1/4 of cases, and only
     check if [b]=0 in 1/2 of cases. OR/XOR are based off of AND for their loop.
3.06
     Updated comments.
3.07
     Replaced average case time complexity with worst case time complexity.
     Standardized formatting to 8 spaces per column.
3.08
     Updated comments.
3.09
     Changed division by 0 abort instruction.
     Made uint.shl bit length agnostic and lowered run time by 36%.
     Made uint.shr bit length agnostic and lowered run time by 11%.

--------------------------------------------------------------------------------
TODO

Use global "uint" scope and shared variables (.z:, .tmp:, etc).
Add effects to index section.
Add better overview explanations for uint.and, uint.mul, and uint.div.
Remove loop counter from uint.mul. Optimize if high=0.
Remove loop counter from uint.div. Optimize if quot=0 or den>=num.
Calculating A&B might be faster by looking at bit changes in A-B. Use the changes
in runs of 0's and 1's to determine where bit differences are.
|#

#--------------------------------------------------------------------------------
#Comparisons

uint.cmp:
	#Call  : 0 ? uint.cmp a b lt eq gt
	#Effect:
	#     if [a]<[b]: goto lt
	#     if [a]=[b]: goto eq
	#     if [a]>[b]: goto gt
	#Time  : 29
	.z      .arg2   ?+1
	0       .z      ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	0       0       ?+1
	#get [a]
	.z      .z      ?+1
	.z      .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .z      ?+1
	.z      .z      ?+1
	.z      .p0:0   ?+1
	.a      .a      ?+1
	.a      .z      ?+1
	#get [b]
	.z      .z      ?+1
	.z      .arg3:3 ?+1
	.b      .b      ?+1
	.b      .z      ?+1
	#[a]-[b]
	.z      .z      ?+1
	.a      .b:0    .le
	#[a]>[b]
	.z      .arg6:6 .ret
.le:
	.a      .z      .eq
	#[a]<[b]
	.z      .arg4:4 .ret
.eq:
	#[a]=[b]
	.z      .arg5:5 .ret
.ret:
	.r0     .r0     ?+1
	.r0     .z      ?+1
	.z      .z      .r0:0
	#Variables
	.a:0
	.z:0 1 2


#--------------------------------------------------------------------------------
#Integer Arithmetic

uint.set:
	#Call  : 0 ? uint.set ret a
	#Effect: [ret]=[a]
	#Time  : 24
	#Setup the stack.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	#Get [ret]
	.p0     .arg2:2 ?+1
	.p1     .p0     ?+1
	.p2     .p0     ?+1
	.tmp    .tmp    ?+1
	.tmp    .p1     ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	#Set [ret]
	.ret    .ret    ?+1
	.ret    .p3:0   ?+1  #[ret]=-[a]
	.p0:0   .p1:0   ?+1
	.p2:0   .ret    ?+1  #[ret]=[a]
	0       0       .arg4:4
	#Variables
	.off:2
	.ret:0
	.tmp:0


uint.neg:
	#Call  : 0 ? uint.neg ret a
	#Effect: [ret]=-[a]
	#Time  : 25
	#Setup the stack.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	#Get [ret]
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p2     .p2     ?+1
	.p2     .tmp    ?+1
	#Set [ret]
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1  #[tmp]=-[ret]
	.tmp    .p2:0   ?+1  #[tmp]=-[ret]-[a]
	.ret    .ret    ?+1
	.ret    .tmp    ?+1  #[ret]=[ret]+[a]
	.p1:0   .ret    ?+1  #[ret]=[ret]-([ret]+[a])=-[a]
	0       0       .arg4:4
	#Variables
	.off:2
	.ret:0
	.tmp:0


uint.add:
	#Call  : 0 ? uint.add ret a b
	#Effect: [ret]=[a]+[b]
	#Time  : 30
	#Setup the stack.
	.tmp    .tmp    ?+1
	.tmp    .arg0   ?+1
	0       .tmp    ?+1
	.arg0   0       ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get [ret]
	.p0     .arg2:2 ?+1
	.p1     .p0     ?+1
	.p2     .p0     ?+1
	.tmp    .tmp    ?+1
	.tmp    .p1     ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	#Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p4     .p4     ?+1
	.p4     .tmp    ?+1
	#Set [ret]
	.tmp    .tmp    ?+1
	.tmp    .p3:0   ?+1  #[tmp]=-[a]
	.tmp    .p4:0   ?+1  #[tmp]=-[a]-[b]
	.p0:0   .p1:0   ?+1
	.p2:0   .tmp    ?+1  #[ret]=[a]+[b]
	#Return
	0       0       .arg5:5
	#Variables
	.arg0:0
	.tmp:0
	.pt:0


uint.sub:
	#Call  : 0 ? uint.sub ret a b
	#Effect: [ret]=[a]-[b]
	#Time  : 31
	#Setup the stack.
	.tmp    .tmp    ?+1
	.tmp    .arg0   ?+1
	0       .tmp    ?+1
	.arg0   0       ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get [ret]
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p2     .p2     ?+1
	.p2     .tmp    ?+1
	#Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	#Set [ret]
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1  #[tmp]=-[ret]
	.tmp    .p3:0   ?+1  #[tmp]=-[ret]-[b]
	.ret    .ret    ?+1
	.ret    .p2:0   ?+1  #[ret]=-[a]
	.ret    .tmp    ?+1  #[ret]=[ret]-[a]+[b]
	.p1:0   .ret    ?+1  #[ret]=[a]-[b]
	#Return
	0       0       .arg5:5
	#Variables
	.arg0:0
	.ret:0
	.tmp:0


uint.mul:
	#Call  : 0 ? uint.mul high low a b
	#Effect:
	#     [high]=([a]*[b])/2^64
	#     [low] =([a]*[b])%2^64
	#Time  : 33+15*bits = 993
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	#Get high.
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.h0     .h0     ?+1
	.h0     .tmp    ?+1
	.h1     .h1     ?+1
	.h1     .tmp    ?+1
	#Get low.
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.l0     .l0     ?+1
	.l0     .tmp    ?+1
	.l1     .l1     ?+1
	.l1     .tmp    ?+1
	#Get -[a]. Use -[a] for adding to [lval].
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.a0     .a0     ?+1
	.a0     .tmp    ?+1
	.a      .a      ?+1
	.a      .a0:0   ?+1
	#Get [b].
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.b0     .b0     ?+1
	.b0     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .b0:0   ?+1
	.b      .b      ?+1
	.b      .tmp    ?+1
	#Initialize lval and hval.
	.hval   .hval   ?+1
	.lval   .lval   ?+1
	#Manually perform the first loop and make sure [b] is odd.
	.tmp    .z+1    ?+1
	.b      .tmp    ?+4
	.lval   .a      ?+1
	.i      .bits   ?+13
.loop:
	#Check loop.
	.i      .z+1    .ret
	#Left shift [hval] and [lval].
	.tmp    .tmp    ?+1
	.tmp    .hval   ?+1
	.hval   .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .lval   ?+1
	.tmp    .z+1    ?+1
	.lval   .tmp    ?+4
	.hval   .z-1    ?+1
	.lval   .z+1    ?+1
	#If the highest bit of [b] is set, add [a] to [lval] and carry to [hval].
	#Since [b] is guaranteed to be odd, we don't need to offset it.
	.tmp    .tmp    ?+1
	.tmp    .b      ?+1
	.b      .tmp    .loop
	.lval   .a      .loop
	.hval   .z-1    .loop
.ret:
	#Set [high].
	.hval   .h0:0   ?+1
	.tmp    .tmp    ?+1
	.tmp    .hval   ?+1
	.h1:0   .tmp    ?+1
	#Set [low].
	.lval   .l0:0   ?+1
	.tmp    .tmp    ?+1
	.tmp    .lval   ?+1
	.l1:0   .tmp    ?+1
	0       0       .arg6:6
	#Variables
	0-1 .z:0 1 2
	.tmp:0
	.a:0
	.b:0
	.hval:0
	.lval:0
	.i:0
	.bits:0-31


uint.div:
	#Call  : 0 ? uint.div quot rem num den
	#Effect:
	#     [quot]=[num]/[den], rounded down
	#     [rem] =[num]%[den]
	#Time  : 46+15*bits = 1006
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	#Get quotient.
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.r0     .r0     ?+1
	.r0     .tmp    ?+1
	.r1     .r1     ?+1
	.r1     .tmp    ?+1
	#Get remainder.
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.r2     .r2     ?+1
	.r2     .tmp    ?+1
	.r3     .r3     ?+1
	.r3     .tmp    ?+1
	#Get numerator.
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1
	.num    .num    ?+1
	.num    .tmp    ?+1
	#Get denominator.
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.nden   .nden   ?+1
	.nden   .p1:0   ?+1
	#If [den]=0, abort
	.nden   .z      .divz
	.nden   .z-1    ?+1
	.den    .den    ?+1
	.den    .nden   ?+1
	#Start loop.
	.quot   .quot   ?+1
	.rem    .rem    ?+1
	.i      .bits   ?+1
.loop:
	#[rem]+=[num]>>63, [num]<<=1
	.tmp    .tmp    ?+1
	.tmp    .num    ?+1
	.tmp    .z+1    ?+1
	.num    .tmp    ?+4
	.rem    .z-1    ?+1
	#if [rem]>=[den], [quot]+=1
	.rem    .den    ?+7
	.rem    .z+1    ?+1
	.quot   .z-1    ?+4
	.rem    .nden   ?+1
	.i      .z+1    .ret
	#[quot]<<=1
	.tmp    .tmp    ?+1
	.tmp    .quot   ?+1
	.quot   .tmp    ?+1
	#[rem]<<=1
	.tmp    .tmp    ?+1
	.tmp    .rem    ?+1
	.rem    .tmp    .loop
.ret:
	#Set quotient.
	.quot   .r0:0   ?+1
	.tmp    .tmp    ?+1
	.tmp    .quot   ?+1
	.r1:0   .tmp    ?+1
	#Set remainder.
	.rem    .r2:0   ?+1
	.tmp    .tmp    ?+1
	.tmp    .rem    ?+1
	.r3:0   .tmp    ?+1
	0       0       .arg6:6
.divz:
	#Abort.
	0-1     0       ?-2
	#Variables
	.num:0
	.den:0
	.nden:0
	.quot:0
	.rem:0
	.tmp:0
	.i:0
	.bits:0-32
	0-1 .z:0 1 2


#--------------------------------------------------------------------------------
#Bitwise Arithmetic

uint.shl:
	#Call  : 0 ? uint.shl ret num shift
	#Effect: [ret]=[num]<<[shift]
	#Time  : 38+17*((bits-1)//8)+4*((bits-1)%8) = 185
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get ret.
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	#Get -[num]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.num    .num    ?+1
	.num    .p0:0   ?+1
	#Get [shift]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p1:0   ?+1
	.shift  .shift  ?+1
	.shift  .tmp    .done8-3
	#[num]=[num]<<8. Abort if [num]=0.
.loop8:
	.num    .z      .ret
	.shift  .p7     .done8
	.shift  .z+1    ?+1
	.tmp    .num    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.num    .tmp    ?+1
	.tmp    .num    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.num    .tmp    ?+1
	.tmp    .num    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .tmp    .loop8
.done8:
	.shift  .n8     ?+1
	#[num]=[num]<<1
.loop1:
	.shift  .z+1    .ret
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .tmp    .loop1
.ret:
	#Set [ret].
	.tmp    .ret0:0 ?+1
	.num    .tmp    ?+1
	.ret1:0 .num    ?+1
	0       0       .arg5:5
	#Variables
	.num:0
	.shift:0
	.tmp:0
	.z:0 1 2
	.p7:7
	.n8:0-8


uint.shr:
	#Call  : 0 ? uint.shr ret num shift
	#Effect: [ret]=[num]>>[shift]
	#Time  : 34+8*bits = 546
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#On first run, calculate how many bits we are using.
	.tmp    .tmp    .skip:?+1
	.skip   .fval   ?+1
	.num    .z-1    ?+1
.firstloop:
	.num    .z      .firstdone
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.nbits  .z+1    ?+1
	.tmp    .tmp    .firstloop
.firstdone:
	#Get ret
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	.rval   .rval   ?+1
	#Get [num]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1
	.num    .num    ?+1
	.num    .tmp    ?+1
	#Get [shift]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.shift  .shift  ?+1
	.shift  .nbits  ?+1
	#If [shift]>=[bits], abort.
	.shift  .p1:0   .ret
	.tmp    .tmp    ?+1
	.tmp    .num    ?+1
	.tmp    .z+1    ?+1
	.num    .tmp    .loop
	.rval   .z-1    ?+1
.loop:
	.shift  .z+1    .ret
	#[rval]<<=1
	.tmp    .tmp    ?+1
	.tmp    .rval   ?+1
	.rval   .tmp    ?+1
	#[num]<<=1
	.tmp    .tmp    ?+1
	.tmp    .num    ?+1
	.num    .tmp    .loop
	.rval   .z-1    .loop
.ret:
	#Set [ret].
	.tmp    .tmp    ?+1
	.rval   .ret0:0 ?+1
	.tmp    .rval   ?+1
	.ret1:0 .tmp    ?+1
	0       0       .arg5:5
	#Variables
	.fval:.skip+1-.firstdone
	.num:0
	.rval:0
	.shift:0
	.tmp:0
	.nbits:0
	0-1 .z:0 1 2


uint.not:
	#Call  : 0 ? uint.not ret a
	#Effect: [ret]=~[a]
	#Time  : 26
	#Use the relation -1-[a]=~[a]
	#Setup the stack.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	#Get [ret]
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p2     .p2     ?+1
	.p2     .tmp    ?+1
	#Set [ret]
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1  #[tmp]=-[ret]
	.tmp    .p2:0   ?+1  #[tmp]=-[ret]-[a]
	.tmp    .z+1    ?+1
	.ret    .ret    ?+1
	.ret    .tmp    ?+1  #[ret]=[ret]+[a]
	.p1:0   .ret    ?+1  #[ret]=[ret]-([ret]+[a])=-[a]
	0       0       .arg4:4
	#Variables
	.z:0 1 2
	.ret:0
	.tmp:0


uint.and:
	#Call  : 0 ? uint.and ret a b
	#Effect: [ret]=[a]&[b]
	#Time  : 44+7*bits = 485
	#This function works by making sure that the bottom bit is set for [a] and [b].
	#As we shift [b] left, if [b]=0, then we know we have processed all bits. As we
	#rotate [a] left, if we need to set a bit, we simply add 1 to it. The main loop
	#is arranged to minimize the number of [a] bits set or [b]=0 checks needed.
	#Setup stack pointer.
	.atmp   .arg2   ?+1
	0       .atmp   ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get [ret]
	.atmp   .atmp   ?+1
	.atmp   .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .atmp   ?+1
	.ret1   .ret1   ?+1
	.ret1   .atmp   ?+1
	#Get [a]
	.atmp   .atmp   ?+1
	.atmp   .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .atmp   ?+1
	.atmp   .atmp   ?+1
	.atmp   .a0:0   ?+1
	.a      .a      ?+1
	.a      .atmp   ?+1
	#Get [b]
	.btmp   .btmp   ?+1
	.btmp   .arg4:4 ?+1
	.b0     .b0     ?+1
	.b0     .btmp   ?+1
	.btmp   .btmp   ?+1
	.btmp   .b0:0   ?+1
	.b      .btmp   ?+1
	#Perform the first iteration outside of the loop. We need [a] and [b] to be odd
	#so that we can efficiently check for carrying in the loop. Flag if the top bit
	#needs to be set at the end.
	        .atmp   .z+1    ?+1
	        .btmp   .z+1    ?+1
	        .a      .atmp   .l0x
	.l1x:   .b      .btmp   .l00
	.l11:   .atmp   .atmp   .loop
	.l0x:   .b      .btmp   .l00
	.l00:   .top    .z+1    ?+1
	        .atmp   .atmp   .loop
	#Loop until [b]=0.
.loop:
	#Prepare [b] for shift and carry.
	        .btmp   .btmp   ?+1
	        .btmp   .b      ?+1
	#Left shift [a] and [b] and check for carry. Set low bit of [a] if needed.
	#If [b]<=[btmp] and [b]=0, then we are done.
	        .b      .btmp   .f0x
	.f1x:   .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f11:   .a      .z-1    .f00
	.f0x:   .b      .z      .done
	        .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f00:   .atmp   .atmp   .loop
.done:
	#Check if the top bit needs to be zero'd.
	.top    .top:.z ?+4
	.a      .btmp   ?+1
	#We have [a]=[a]&[b]+-[btmp] and [btmp]=2^(n-1).
	.a      .ret0:0 ?+1
	.btmp   .a      ?+1
	.ret1:0 .btmp   ?+1
	0       0       .arg5:5
	#Variables
	0-1 .z:0 1 2
	.a:0 .atmp:0
	.b:0 .btmp:0


uint.or:
	#Call  : 0 ? uint.or ret a b
	#Effect: [ret]=[a]|[b]
	#Time  : 45+7*bits = 486
	#Use uint.and and the relation A|B=-1-(~A)&(~B).
	#Setup stack pointer.
	.atmp   .arg2   ?+1
	0       .atmp   ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get [ret]
	.atmp   .atmp   ?+1
	.atmp   .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .atmp   ?+1
	.ret1   .ret1   ?+1
	.ret1   .atmp   ?+1
	#Get -[a]
	.atmp   .atmp   ?+1
	.atmp   .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .atmp   ?+1
	.a      .a      ?+1
	.a      .a0:0   ?+1
	.atmp   .atmp   ?+1
	.atmp   .a      ?+1
	#Get -[b]
	.btmp   .btmp   ?+1
	.btmp   .arg4:4 ?+1
	.b0     .b0     ?+1
	.b0     .btmp   ?+1
	.b      .b0:0   ?+1
	.btmp   .btmp   ?+1
	.btmp   .b      ?+1
	#Perform the first iteration outside of the loop. We need [a] and [b] to be odd
	#so that we can efficiently check for carrying in the loop. Flag if the top bit
	#needs to be set.
	        .a      .z+1    ?+1
	        .b      .z+1    ?+1
	        .a      .atmp   .l0x
	.l1x:   .b      .btmp   .l00
	.l11:   .atmp   .atmp   .loop
	.l0x:   .b      .btmp   .l00
	.l00:   .top    .z+1    ?+1
	        .atmp   .atmp   .loop
	#Loop until [b]=0.
.loop:
	#Prepare [b] for shift and carry.
	        .btmp   .btmp   ?+1
	        .btmp   .b      ?+1
	#Left shift [a] and [b] and check for carry. Set low bit of [a] if needed.
	#If [b]<=[btmp] and [b]=0, then we are done.
	        .b      .btmp   .f0x
	.f1x:   .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f11:   .a      .z-1    .f00
	.f0x:   .b      .z      .done
	        .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f00:   .atmp   .atmp   .loop
.done:
	#Check if the top bit needs to be zero'd.
	.top    .top:.z ?+4
	.a      .btmp   ?+1
	#We have [a]=[a]&[b]+-[btmp] and [btmp]=2^(n-1).
	#A|B=-1-(~A)&(~B)
	.a      .z-1    ?+1
	.btmp   .ret0:0 ?+1
	.a      .btmp   ?+1
	.ret1:0 .a      ?+1
	0       0       .arg5:5
	#Variables
	0-1 .z:0 1 2
	.a:0 .atmp:0
	.b:0 .btmp:0


uint.xor:
	#Call  : 0 ? uint.xor ret a b
	#Effect: [ret]=[a]^[b]
	#Time  : 46+7*bits = 487
	#Use uint.and and the relation A^B=A+B-2(A&B).
	#Setup stack pointer.
	.atmp   .arg2   ?+1
	0       .atmp   ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get [ret]
	.atmp   .atmp   ?+1
	.atmp   .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .atmp   ?+1
	.ret1   .ret1   ?+1
	.ret1   .atmp   ?+1
	#Get [a]
	.atmp   .atmp   ?+1
	.atmp   .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .atmp   ?+1
	.atmp   .atmp   ?+1
	.atmp   .a0:0   ?+1
	.a      .a      ?+1
	.a      .atmp   ?+1
	#Get [b]
	.btmp   .btmp   ?+1
	.btmp   .arg4:4 ?+1
	.b0     .b0     ?+1
	.b0     .btmp   ?+1
	.btmp   .btmp   ?+1
	.btmp   .b0:0   ?+1
	.b      .btmp   ?+1
	#Perform the first iteration outside of the loop. We need [a] and [b] to be odd
	#so that we can efficiently check for carrying in the loop.
	.off    .off    ?+1
	.off    .atmp   ?+1
	.off    .btmp   ?+1
	.atmp   .z+1    ?+1
	.btmp   .z+1    ?+1
	.a      .atmp   ?+1
	.b      .btmp   ?+1
	.atmp   .atmp   .loop
	#Loop until [b]=0.
.loop:
	#Prepare [b] for shift and carry.
	        .btmp   .btmp   ?+1
	        .btmp   .b      ?+1
	#Left shift [a] and [b] and check for carry. Set low bit of [a] if needed.
	#If [b]<=[btmp] and [b]=0, then we are done.
	        .b      .btmp   .f0x
	.f1x:   .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f11:   .a      .z-1    .f00
	.f0x:   .b      .z      .done
	        .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f00:   .atmp   .atmp   .loop
.done:
	#We have [a]=[a]&[b]+-[btmp] and [btmp]=2^(n-1).
	#Use A^B=A+B-2(A&B).
	.off    .a      ?+1
	.off    .ret0:0 ?+1
	.a      .off    ?+1
	.ret1:0 .a      ?+1
	0       0       .arg5:5
	#Variables
	0-1 .z:0 1 2
	.a:0 .atmp:0
	.b:0 .btmp:0
	.off:0

#|==============================================================================

String Printing - v1.05

Author: Alec Dee - alecdee.github.io - akdee144@gmail.com

--------------------------------------------------------------------------------
ASCII Table

  0  00  NUL |  26  1a      |  52  34   4  |  78  4e   N  | 104  68   h
  1  01      |  27  1b  ESC |  53  35   5  |  79  4f   O  | 105  69   i
  2  02      |  28  1c      |  54  36   6  |  80  50   P  | 106  6a   j
  3  03      |  29  1d      |  55  37   7  |  81  51   Q  | 107  6b   k
  4  04      |  30  1e      |  56  38   8  |  82  52   R  | 108  6c   l
  5  05      |  31  1f      |  57  39   9  |  83  53   S  | 109  6d   m
  6  06      |  32  20  SPC |  58  3a   :  |  84  54   T  | 110  6e   n
  7  07  BEL |  33  21   !  |  59  3b   ;  |  85  55   U  | 111  6f   o
  8  08  BCK |  34  22   "  |  60  3c   <  |  86  56   V  | 112  70   p
  9  09  TAB |  35  23   #  |  61  3d   =  |  87  57   W  | 113  71   q
 10  0a  LF  |  36  24   $  |  62  3e   >  |  88  58   X  | 114  72   r
 11  0b  VTB |  37  25   %  |  63  3f   ?  |  89  59   Y  | 115  73   s
 12  0c      |  38  26   &  |  64  40   @  |  90  5a   Z  | 116  74   t
 13  0d  CR  |  39  27   '  |  65  41   A  |  91  5b   [  | 117  75   u
 14  0e      |  40  28   (  |  66  42   B  |  92  5c   \  | 118  76   v
 15  0f      |  41  29   )  |  67  43   C  |  93  5d   ]  | 119  77   w
 16  10      |  42  2a   *  |  68  44   D  |  94  5e   ^  | 120  78   x
 17  11      |  43  2b   +  |  69  45   E  |  95  5f   _  | 121  79   y
 18  12      |  44  2c   ,  |  70  46   F  |  96  60   `  | 122  7a   z
 19  13      |  45  2d   -  |  71  47   G  |  97  61   a  | 123  7b   {
 20  14      |  46  2e   .  |  72  48   H  |  98  62   b  | 124  7c   |
 21  15      |  47  2f   /  |  73  49   I  |  99  63   c  | 125  7d   }
 22  16      |  48  30   0  |  74  4a   J  | 100  64   d  | 126  7e   ~
 23  17      |  49  31   1  |  75  4b   K  | 101  65   e  | 127  7f  DEL
 24  18  CAN |  50  32   2  |  76  4c   L  | 102  66   f  |
 25  19      |  51  33   3  |  77  4d   M  | 103  67   g  |
|#

print:
	#Call: 0 ? print char0 char1 char2 ... 0
	#Print function. Prints a zero terminated ASCII string. If -1 is used as a
	#character value, then treat the next character as a pointer to a number.
	.ptr    .ptr    ?+1
	.ptr    0       ?+1
	.ptr    .z-2    ?+1
	0       0       ?+2
	.ret:   .tmp
.loop:
	#Get the next character.
	.tmp    .ptr:0  ?+1
	.ptr    .z-1    ?+1
	.char   .char   ?+1
	.char   .tmp    .p0:?+1
	#If [char]=0, we've reached the end of the string.
	.char   .z      .ret
	#If [char]>0, and [tmp]<=1, then [char]=-1.
	.tmp    .z+1    .numprep
	#Print [char].
.print:
	0-2     .char   ?+1
	.tmp    .tmp    .loop
.numprep:
	#Prepare to print a number.
	#First entry. Jump back to beginning of loop to get the number's pointer.
	.p0     .pset   .loop
	#Second entry. Get the number from [char].
	.p0     .prem   ?+1
	.tmp    .tmp    ?+1
	.tmp    .char:0 ?+1
	.num    .tmp    ?+1
	.show   .show   ?+1
	.base   .base0  ?+1
.numloop:
	#Store a power of 10 in [tmp].
	.tmp    .tmp    ?+1
	.tmp    .base:.base0-1 ?+1
	.char   .char   ?+1
	.char   .char0  ?+1
	#Subtract [tmp] from [num] to get the next digit.
.digitloop:
	.num    .tmp    .digitdone
	.num    .z+1    ?+1
	.show   .z-1    ?+1
	.char   .z-1    .digitloop
.digitdone:
	#If [tmp]=0 then return to the main loop and print the last digit.
	.tmp    .z      .print
	#Add [num]+=[tmp] to correct for the last [num]-[tmp] operation.
	.z      .tmp    ?+1
	.num    .z      ?+1
	.z      .z      ?+1
	#If [show]>0, then we can print digits.
	.show   .z      .noshow
	0-2     .char   ?+1
.noshow:
	.base   .z-1    .numloop
	#Variables
	0-2 0-1 .z:0 1
	.num:0
	.tmp:0
	.show:0
	.char0:0-48
	.pset:.p0-.numprep-2
	.prem:.numprep-.p0+2
	#1-10^n
	.base10:
		0-999999999          0-99999999
		            0-9999999             0-999999             0-99999
		               0-9999                0-999                0-99
		                  0-9                    0
	.base0:?-.base10-1

#|==============================================================================

Random Number Generator - v1.02

Author: Alec Dee - alecdee.github.io - akdee144@gmail.com

--------------------------------------------------------------------------------
Index

random.seed    [num]
random.jump    [num]
random.get     [dst]
random.mod     [dst] [mod]
random.shuffle [[arr]] [len]

--------------------------------------------------------------------------------
Version History

1.00
     Initial version.
1.01
     Added shuffling.
1.02
     Optimized random.generate by removing offsets during shitfing.

--------------------------------------------------------------------------------
TODO

Optimize random.jump based on uint.mul.
Optimize random.mod and random.shuffle based on uint.div.
Merge random.get and random.generate.
Use time as initial random seed.
|#

random.table:
	#For the hash output to be unique, the bottom 8 bits of the table elements
	#need be unique. Add 128 to compensate for shifting in random.generate.
	0x98f570cabbbe2960 0x911fe275124571d3 0xc4b49b92decb87b8 0x2cd974e264a1471e
	0xf25c1cd4ec741993 0x6ac38c14e315ff72 0x532a643077bdeaf3 0xe73da4ddf4ea21ce
	0xf482feb36863db2c 0xb0b08786cdd32bff 0x2912bb15798712d5 0xaa3c40a2341958ba
	0xa56c2aec8d398c9f 0xb571c4090f4e31b5 0xcfbbfe93f0333090 0x4d08908eb0d3773f
	0x902c693a21a631cb 0x9b35783a62da3801 0xeb23e76d74a030bd 0x148e78184600d905
	0x93cdff03f57a90f0 0xdc500bc795c0db4b 0x70da57814f7632c1 0x036633f4013f2582
	0x0c8b76d2def52fc2 0xa45d1da2dba14a25 0x28dbc12379f88e00 0xcf437f8d91ddbc86
	0x0e04a0cdced858ab 0xc7ad971bd5fd8b40 0x29c4517860f09471 0x651bab92d762f10c
	0x9e5f7051205bcc26 0xdcf588711bbcf16c 0xb511a1dded21dd29 0x3679f6456f3452f6
	0xe38dc026335be06b 0xc11d3c759a573da9 0x69410c19157a935a 0xbcc29a4c1b48f135
	0x178c1f951bb7690d 0xd0fc4d498b3e96cf 0xb5b221282132f91f 0x3406dfcb2f0366c6
	0xa18219fffb9a29fc 0xf389feeac4bde69c 0x7b0c200137dd9f57 0x2ecc7eb7f4962591
	0x92ac81ab67b51beb 0x9009eb7acc6a5c7d 0x3182a4ab17f0d814 0xde30902e8d338137
	0x3f3b76e6cccfc642 0xb90d0547d1666133 0x8829b84121f35da7 0xaf509317565b19e7
	0x8fa5742b4f4eeeac 0xbfb86e765ab97f32 0x42b8d16ac3cc3a7f 0x33b8fda60fa07180
	0x68b9f22c1b7ba74d 0x0cee1ee11bc6d449 0x0dce2401a6399421 0x052188c95763afdb
	0x4cd0743f96271244 0x8ab6545393a1ebf9 0x768742f4f5d2cab3 0x2505089bf7de1def
	0xc77ddf5d4bcb4fe8 0x3b861ae62a54910f 0xbba48529fa2859a1 0x9364a79693182e69
	0x29da3184545bf7ed 0xae8efc34c79dd8d0 0xefb805aef57bab34 0xf78943322ead0764
	0x9c357259e48eb6af 0x1dcf0b5f98e2b294 0xa84cb6e4e7897551 0x9054b2308f7ff5a8
	0xdea01eccc8cb3002 0x46be28419fcd8f73 0x5c466247cab9ce7a 0x1034bef3c280cb12
	0x8595486352ef7b07 0xe9c864d995472116 0x9d17d691fa40b9d8 0x1b0a781d7f42e5c0
	0x9260768bc3848498 0x32b48273b8447b6e 0xa630dd7aa9926f68 0x6a5f0a3586db52e5
	0xbeda047a0761a9de 0xeeedd85395df432a 0x9fa214fd946164b7 0xd76c7fadfb1b9f27
	0xe2679809cd7c7195 0x4dbb967cba099877 0x9e611d7eb7c16511 0xde11e3858421c4dd
	0x8f60a79abb8d57a4 0xb69e8632011f0476 0x3a1b15a9d57b3adc 0x6ec8bf7ca6e952f4
	0x18ab73ed10808a85 0xccf19063a89d6ed6 0x9ddaae641e0d371d 0x349a6b56eb499da3
	0xdebee3f7288eabe9 0x6d75b7185e043496 0xbfe68ee59f24e009 0xe2f755c64a184728
	0xe3956041e0330606 0x1684ec84b22cf1a6 0xe547786c47fe87e1 0x7aaf255ec884c10b
	0xb9a7b0be91eca4fa 0x18a85229e8fbe317 0x9b6dad19e7415bc4 0xdab2c6a930db6224
	0xd745efee27085597 0x76f406eb0c7428d4 0x3f779c073097aad9 0xbd0f440b38d1bb66
	0x6ebf3706f695fc55 0x5fbeb72a136c5f89 0xd1c85045aafa5699 0x9b0cf77eb69cfe5b
	0x96bc972c67aeefe2 0xb878518614240efb 0x915a36484cec1b5d 0xa020e164db74d519
	0x875a2ac9e4b98658 0xe34b6b0a580b7d50 0xcd30c71286948c3b 0xf0e6820ef3e9dedf
	0x5dd7e2048d695b67 0xc631ad2b02402fe4 0xc04e99806aa6b8b0 0x5c3304efe897203a
	0x8470f7bb68304a7e 0x4667d0d2c455a98f 0x627165e1b5e16941 0xcd115b2a371d7253
	0x9d6959acac5178f2 0x2722e04d0a4a143e 0x9da126422bd82cb6 0xef7d31df6da70b9b
	0x8419df95b52ed518 0x8744bd266232eec9 0xfec4fb7d4a39b7b4 0x653e09ad754e9663
	0x2608342e20aa3b1b 0xcaacecdf21d87d83 0x60760dd379bb46ea 0xb3f7371bd3167bee
	0x83456546a5d4b0c8 0x3b873a2c613d06d2 0x12c3d73474334dec 0xbec28771231d6d4f
	0x1e0915b280ca6d78 0x12f9adbc60d758f8 0x9fb08c027989eee0 0xbe06995c7b3a3a8d
	0xa018541f0b2d74fe 0xcb0dd0f03d00ed20 0xcea6dda8960694ae 0x903aaea97447f361
	0xa790fbe394d3a1f1 0x40efcea66b9f4687 0xce2e0082770418c3 0x648d7efc4101d2c7
	0x77554a83e487e00e 0x88a954411c963eca 0x5e50a70702f25e70 0x0f71bbe7c9f8888e
	0xe10b0dd69b525b39 0xb6e0722926754946 0xf170a88f296f535f 0x3c04bceebe44795e
	0x68bba5422fffc54a 0x3532437701d42d5c 0x0f193926db9f9f03 0xe3e8936f5cc07b75
	0xeb05b184ecbc0781 0xcfb13169fb869a04 0x42a0202293da976a 0xf2b6c837dd71ec52
	0x384cbe585d4a284c 0xaa3111a39a9aeffd 0x6c8ab832cf881743 0x0483dd6ad0cc54da
	0x720a2dd6094fc823 0x03107a9e669770bc 0x1668b4ba38718ed7 0x771106507afb5788
	0x5054ac481b535308 0x7e485aae5cf0843c 0x881766ced977c01c 0x2eb2c7255ded91e6
	0xeeb1ca030d19f04e 0x68138ac1b21f7030 0xe5de8ba1badd73c5 0x03a8f78e3114d636
	0xde62bdde8d42596d 0xcb15fc108b83a222 0x47e32cf9f7cb1038 0xdd46c0bcb1b2ed8b
	0x24966b07ce5abb74 0x107257fa9545c5d1 0xbb6bed3a3715a192 0xca941e35cb1a8ab9
	0x3ea5389dbca69e2d 0x0b84722da650e37c 0x0ddd81bdedcd05ad 0xa55ee070874ab6be
	0x4856d854cdc81015 0xaf3482758939f02f 0x80547b7b42c6082b 0x32a83053658a73aa
	0xb4e0f4a4bd383c9e 0x86c52d7ce1b79e0a 0x1567a7aa94e4fcb1 0x71fc8c1a6dfa442e
	0x381ae7272b68bb48 0x85632a5c9280d6f7 0x141c9e3bdecc42f5 0xae184e25976dae1a
	0x6fd0f1321084317b 0xb95e50ee69ed5f9d 0x786f68e44c0f0ea2 0x88ac24917ce632bb
	0x88fca453535915bf 0x6c6e38b0bf5b979a 0x4b42cfc646897ccd 0x2a18e1dbbded9bb2
	0x8c75ad2c94462045 0xde14e4d24fc9bb62 0x88d304a2898a4584 0xf7e1e0b52d45f0cc
	0x9d8a8dd7d1bafba0 0x5ba48bfee8d17479 0x5d2d0cfc9a48fa56 0x85e41916f3616c6f
	0xedfc0c68c0217147 0x067e32a00b210665 0x04440fe6a9b7ad3d 0xe0942f02c01f838c
	0x86c8c765b04b7031 0x03edd68c2c9f6259 0xa82b24db8deaf410 0x66337c5333e8c4a5
	0x305d36e368598b13 0xbdd8330fbb889ee3 0xc146c702c618a08a 0x377d5bd4c5c6b854


random.generate:
	#Call  : 0 ? random.generate
	#Effect: Meant for internal use. Advances the PRNG state, hashes it, and stores
	#the result in random.generate.ret.
	#Time  : 296 instructions
	#Set return address.
	.arg2   .arg2   ?+1
	.arg2   0       ?+1
	.arg2   .l+6    ?+1
	#Advance state.
	.state  .inc    ?+1
	#Prepare return value.
	.ret    .ret    ?+1
	.ret    .state  ?+1
	.z      .l+5    ?+4
.loop:
	.z      .z+1    .done
	#Set [ret]=[ret]*256+128 and [t0]=[table+([out]>>56)]. Offset [ret] by 1 so
	#we can detect if a carry occurs.
	.tmp .tmp ?+1 .tmp .ret ?+1 .tmp .z+1 ?+1 .ret .tmp ?+4
	.tbl .l+0 ?+4 .tbl .l+8 ?+1
	.tmp .tmp ?+1 .tmp .ret ?+1 .ret .tmp ?+4 .tbl .l+1 ?+1
	.tmp .tmp ?+1 .tmp .ret ?+1 .ret .tmp ?+4 .tbl .l+2 ?+1
	.tmp .tmp ?+1 .tmp .ret ?+1 .ret .tmp ?+4 .tbl .l+3 ?+1
	.tmp .tmp ?+1 .tmp .ret ?+1 .ret .tmp ?+4 .tbl .l+4 ?+1
	.tmp .tmp ?+1 .tmp .ret ?+1 .ret .tmp ?+4 .tbl .l+5 ?+1
	.tmp .tmp ?+1 .tmp .ret ?+1 .ret .tmp ?+4 .tbl .l+6 ?+1
	.tmp .tmp ?+1 .tmp .ret ?+1 .ret .tmp ?+4 .tbl .l+7 ?+1
	#[ret]-=table+128
	.ret    .tbl:0  ?+1
	.tbl    .tbl    .loop
.done:
	0       0       .arg2:0
	#Variables
	.state:0x4a090815efe7b279
	.inc:0x1b859b859f5851fd
	.ret:0
	.tmp:0
	.l:0-128-random.table 0-64 0-32 0-16 0-8 0-4 0-2 0-1 0-random.table
	.z:0 1


random.seed:
	#Call  : 0 ? random.seed num
	#Effect: Sets the PRNG state based on the value of [num].
	#Setup the stack.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	0       0       ?+1
	#Get [num].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1
	#Reset the generator state.
	random.generate.state random.generate.state ?+1
	random.generate.inc   random.generate.inc   ?+1
	#Set [inc] make sure it's odd.
	random.generate.inc .tmp ?+1
	0 ? random.generate
	random.generate.inc random.generate.inc ?+1
	random.generate.inc random.generate.ret ?+1
	random.generate.inc random.generate.ret ?+1
	random.generate.inc .z-1 ?+1
	#Set [state].
	random.generate.state .tmp ?+1
	0 ? random.generate
	random.generate.state random.generate.state ?+1
	random.generate.state random.generate.ret   .arg3:3
	#Variables
	.tmp:0
	0-2 0-1 .z:0


random.jump:
	#Call  : 0 ? random.jump num
	#Effect: Jumps the PRNG state forward or backwards [num] number of steps.
	#Setup the stack.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	#Get [num].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.num    .num    ?+1
	.num    .p0:0   ?+1
	#Calculate [inc]*[num].
	.mul    .mul    ?+1
	.tmp    .tmp    ?+1
	.i      .i0     ?+1
.loop:
	#[num]<<1 and carry into [mul].
	.tmp    .z+1    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+4
	.mul    random.generate.inc ?+1
	.tmp    .tmp    ?+1
	.i      .z+1    .done
	#[mul]<<1
	.tmp    .mul    ?+1
	.mul    .tmp    ?+1
	.tmp    .tmp    .loop
.done:
	#[state]+=[inc]*[num]
	.tmp    .mul    ?+1
	random.generate.state .tmp ?+1
	#Return
	0       0       .arg3:3
	#Variables
	.tmp:0
	.num:0
	.mul:0
	.i:0
	.i0:0-64
	0-2 0-1 .z:0 1


random.get:
	#Call  : 0 ? random.get dst
	#Effect: [dst]=a random 64 bit integer
	#Setup the stack.
	0       .z+2    ?+1
	.arg2   .arg2   ?+1
	.arg2   0       ?+1
	0       .z+1    ?+1
	.arg3   .arg3   ?+1
	.arg3   0       ?+1
	0       0       ?+1
	#Get dst.
	.p0     .arg2:2 ?+1
	.p1     .p0     ?+1
	.p2     .p0     ?+1
	.z      .p1     ?+1
	.p0     .p0     ?+1
	.p0     .z      ?+1
	.z      .z      ?+1
	#Get a random number.
	0 ? random.generate
	.z random.generate.ret ?+1
	#Set [dst] and return.
	.p0:0   .p1:0   ?+1
	.p2:0   .z      ?+1
	.z      .z      ?+1
	0       0       .arg3:3
	#Variables
	.z:0 1 2


random.mod:
	#Call  : 0 ? random.get dst mod
	#Effect: [dst]=a random number in [0,[mod]).
	#Setup the stack.
	.tmp0   .tmp0   ?+1
	.tmp0   .arg2   ?+1
	0       .tmp0   ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	0       0       ?+1
	#Get dst.
	.tmp0   .tmp0   ?+1
	.tmp0   .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .tmp0   ?+1
	.p1     .p1     ?+1
	.p1     .tmp0   ?+1
	#Get [mod].
	.tmp0   .tmp0   ?+1
	.tmp0   .arg3:3 ?+1
	.p2     .p2     ?+1
	.p2     .tmp0   ?+1
	.nmod   .nmod   ?+1
	.nmod   .p2:0   ?+1
	.nmod   .z      .div0
	.nmod   .z-1    ?+1
	.mod    .mod    ?+1
	.mod    .nmod   ?+1
.randloop:
	#Get a new random number.
	0 ? random.generate
	.rand   .rand   ?+1
	.rand random.generate.ret ?+1
	.tmp0   .tmp0   ?+1
	.tmp0 random.generate.ret ?+1
	.rem    .rem    ?+1
	.i      .i0     ?+1
	#Caculate [rem]=[rand]%[mod].
.modloop:
	#[tmp0]<<1 and carry into [rem].
	.tmp1   .tmp1   ?+1
	.tmp1   .tmp0   ?+1
	.tmp1   .z+1    ?+1
	.tmp0   .tmp1   ?+4
	.rem    .z-1    ?+1
	#[rem]%[mod]
	.rem    .mod    ?+7
	.rem    .z+1    ?+1
	.tmp1   .tmp1   ?+7
	.rem    .nmod   ?+1
	.tmp1   .tmp1   ?+1
	.i      .z+1    .moddone
	#[rem]<<1
	.tmp1   .rem    ?+1
	.rem    .tmp1   .modloop
.moddone:
	#Rejection sampling. Accept if rand-rem<=-mod.
	.nmod   .z+1    ?+1
	.rand   .rem    ?+1
	.rand   .nmod   .accept
	.nmod   .z-1    .randloop
.accept:
	.rem    .p0:0   ?+1
	.tmp1   .rem    ?+1
	.p1:0   .tmp1   ?+1
	0       0       .arg4:4
.div0:
	0-1     0       0
	#Variables
	.nmod:0
	.mod:0
	.rand:0
	.rem:0
	.tmp0:0
	.tmp1:0
	.i:0
	.i0:0-64
	0-1 .z:0 1 2


random.shuffle:
	#Call  : 0 ? random.shuffle arr len
	#Effect: Randomly shuffles [[arr]] from [0,[len]).
	#Setup the stack.
	.tmp0   .tmp0   ?+1
	.tmp0   .arg2   ?+1
	0       .tmp0   ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	0       0       ?+1
	#Get [len].
	.tmp0   .tmp0   ?+1
	.tmp0   .arg3:3 ?+1
	.p1     .p1     ?+1
	.p1     .tmp0   ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .p1:0   ?+1
	.len    .len    ?+1
	.len    .tmp0   ?+1
	#Return if [len]<=1.
	.len    .z+1    .done
	#Get -[arr].
	.tmp0   .tmp0   ?+1
	.tmp0   .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .tmp0   ?+1
	.narr   .narr   ?+1
	.narr   .p0:0   ?+1
	#Set array pointers.
	.i0     .i0     ?+1
	.i0     .narr   ?+1
	.i1     .i1     ?+1
	.i1     .narr   ?+1
	.nmod   .nmod   ?+1
	.nmod   .z+1    ?+1
	.mod    .mod    ?+1
	.mod    .z-1    .randloop
.loop:
	.len    .z+1    .done
	#Get a random number in [0,i+1).
.randloop:
	0 ? random.generate
	.rand   .rand   ?+1
	.rand random.generate.ret ?+1
	.tmp0   .tmp0   ?+1
	.tmp0 random.generate.ret ?+1
	.rem    .rem    ?+1
	.k      .k0     ?+1
	#Caculate [rem]=[rand]%[mod].
.modloop:
	#[tmp0]<<1 and carry into [rem].
	.tmp1   .tmp1   ?+1
	.tmp1   .tmp0   ?+1
	.tmp1   .z+1    ?+1
	.tmp0   .tmp1   ?+4
	.rem    .z-1    ?+1
	#[rem]%[mod]
	.rem    .mod    ?+7
	.rem    .z+1    ?+1
	.tmp1   .tmp1   ?+7
	.rem    .nmod   ?+1
	.tmp1   .tmp1   ?+1
	.k      .z+1    .moddone
	#[rem]<<1
	.tmp1   .rem    ?+1
	.rem    .tmp1   .modloop
.moddone:
	#Rejection sampling. Accept if rand-rem<=-mod.
	.nmod   .z+1    ?+1
	.rand   .rem    ?+1
	.rand   .nmod   .modaccept
	.nmod   .z-1    .randloop
.modaccept:
	#Increment i.
	.i0     .z-1    ?+1
	.i1     .z-1    ?+1
	#Set j=arr+[rand]%(i+1).
	.rem    .j0     ?+1
	.rem    .narr   ?+1
	.tmp1   .rem    ?+1
	.j0     .tmp1   ?+1
	.j1     .tmp1   ?+1
	#Swap [i] and [j].
	.tmp0   .tmp0   ?+1
	.tmp0   .i0:0   ?+1
	.tmp1   .tmp1   ?+1
	.tmp1   .j0:0   ?+1
	.tmp1   .tmp0   ?+1  #[tmp1]=[i]-[j]
	.i1:0   .tmp1   ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .tmp1   ?+1
	.j1:0   .tmp0   ?+1
	#Next loop.
	.mod    .z-1    .loop
.done:
	0       0       .arg4:4
	#Variables
	.tmp0:0
	.tmp1:0
	.narr:0
	.rem:0
	.nmod:0
	.mod:0
	.len:0
	.rand:0
	.k:0
	.k0:0-64
	0-1 .z:0 1 2

