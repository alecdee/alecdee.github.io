#|==============================================================================


String Library - v1.02

Author: Alec Dee - alecdee.github.io - akdee144@gmail.com


--------------------------------------------------------------------------------
Notes


string.unl currently only provides the "print" function. In the future, it will
also provide string manipulation functions.


--------------------------------------------------------------------------------
Index


Printing
print char0 char1 char2 ... 0

String formatting escape codes
string.uint    [num]
string.uintfmt [num], [base], [padding], [padchar]
string.uintcon [num], base, padding, padchar
string.int     [num]
string.intfmt  [num], [base], [padding], [padchar], [sign]
string.intcon  [num], base, padding, padchar, sign


--------------------------------------------------------------------------------
Version History


1.00
     Initial version.
     Created print function.
1.01
     Reorganized integer printing constants.
1.02
     Replaced built-in integer printing with uint.print and int.print.
     Library now handles strings instead of just printing.


--------------------------------------------------------------------------------
ASCII Table


  0  00  NUL |  26  1a      |  52  34   4  |  78  4e   N  | 104  68   h
  1  01      |  27  1b  ESC |  53  35   5  |  79  4f   O  | 105  69   i
  2  02      |  28  1c      |  54  36   6  |  80  50   P  | 106  6a   j
  3  03      |  29  1d      |  55  37   7  |  81  51   Q  | 107  6b   k
  4  04      |  30  1e      |  56  38   8  |  82  52   R  | 108  6c   l
  5  05      |  31  1f      |  57  39   9  |  83  53   S  | 109  6d   m
  6  06      |  32  20  SPC |  58  3a   :  |  84  54   T  | 110  6e   n
  7  07  BEL |  33  21   !  |  59  3b   ;  |  85  55   U  | 111  6f   o
  8  08  BCK |  34  22   "  |  60  3c   <  |  86  56   V  | 112  70   p
  9  09  TAB |  35  23   #  |  61  3d   =  |  87  57   W  | 113  71   q
 10  0a  LF  |  36  24   $  |  62  3e   >  |  88  58   X  | 114  72   r
 11  0b  VTB |  37  25   %  |  63  3f   ?  |  89  59   Y  | 115  73   s
 12  0c      |  38  26   &  |  64  40   @  |  90  5a   Z  | 116  74   t
 13  0d  CR  |  39  27   '  |  65  41   A  |  91  5b   [  | 117  75   u
 14  0e      |  40  28   (  |  66  42   B  |  92  5c   \  | 118  76   v
 15  0f      |  41  29   )  |  67  43   C  |  93  5d   ]  | 119  77   w
 16  10      |  42  2a   *  |  68  44   D  |  94  5e   ^  | 120  78   x
 17  11      |  43  2b   +  |  69  45   E  |  95  5f   _  | 121  79   y
 18  12      |  44  2c   ,  |  70  46   F  |  96  60   `  | 122  7a   z
 19  13      |  45  2d   -  |  71  47   G  |  97  61   a  | 123  7b   {
 20  14      |  46  2e   .  |  72  48   H  |  98  62   b  | 124  7c   |
 21  15      |  47  2f   /  |  73  49   I  |  99  63   c  | 125  7d   }
 22  16      |  48  30   0  |  74  4a   J  | 100  64   d  | 126  7e   ~
 23  17      |  49  31   1  |  75  4b   K  | 101  65   e  | 127  7f  DEL
 24  18  CAN |  50  32   2  |  76  4c   L  | 102  66   f  |
 25  19      |  51  33   3  |  77  4d   M  | 103  67   g  |


--------------------------------------------------------------------------------
TODO


|#


print:
	#Call  : 0 ? print char0 char1 char2 ... 0
	#Effect: Prints a zero terminated ASCII string. If an escape code is used,
	#the next value(s) are expected to be numbers or formatting.
	#
	.ptr    .ptr    ?+1
	.ptr    0       ?+1
	.ptr    .z-2    ?+1
	0       0       ?+2
	.ret:   .tmp
.loop:
	#Get the next character.
	.tmp    .ptr:0  ?+1
	.ptr    .z-1    ?+1
	.char   .char   ?+1
	.char   .tmp    ?+1
	#If [char]=0, we've reached the end of the string.
	.char   .z      .ret
	#If [tmp]<=[escape], then we want to print a non-character.
	.tmp    .esc    .escprint
	#Print [char].
	0-2     .char   ?+1
	.tmp    .tmp    .loop
.escprint:
	#Print something other than a character.
	0       .ptr    ?+1
	0       .z-2    ?+1
	#Determine what type of value we're printing.
	.tmp    .z      .str
	.tmp    .nesc   .invalid
	.tmp    .z+1    .intcon
	.tmp    .z+1    .intfmt
	.tmp    .z+1    .int
	.tmp    .z+1    .uintcon
	.tmp    .z+1    .uintfmt
	.tmp    .z+1    .uint
	.tmp    .z+1    .strfmt
.invalid:
	#INVALID FORMAT
	.tmp    .tmp    ?+1
	0       0       ?+1
	0 ? print 73 78 86 65 76 73 68 32 70 79 82 77 65 84 10 0
	0-1     0       ?-2
.str:
	#Reserved for string printing.
	0-1     0       ?-2
.strfmt:
	#Reserved for string printing.
	0-1     0       ?-2
.uint:
	mem.getargs.0 ? mem.getargs ?+8 1 .ptr 0 0
	0 ? uint.print 0 .base .z .padchr
	.tmp    .tmp    .loop
.uintfmt:
	mem.getargs.0 ? mem.getargs ?+14 1 ?+13 1 ?+12 1 ?+11 1 .ptr 0 0
	0 ? uint.print 0 0 0 0
	.tmp    .tmp    .loop
.uintcon:
	mem.getargs.0 ? mem.getargs ?+14 1 ?+13 0 ?+12 0 ?+11 0 .ptr 0 0
	0 ? uint.print 0 0 0 0
	.tmp    .tmp    .loop
.int:
	mem.getargs.0 ? mem.getargs ?+8 1 .ptr 0 0
	0 ? int.print 0 .base .z .padchr .z
	.tmp    .tmp    .loop
.intfmt:
	mem.getargs.0 ? mem.getargs ?+16 1 ?+15 1 ?+14 1 ?+13 1 ?+12 1 .ptr 0 0
	0 ? int.print 0 0 0 0 0
	.tmp    .tmp    .loop
.intcon:
	mem.getargs.0 ? mem.getargs ?+16 1 ?+15 0 ?+14 0 ?+13 0 ?+12 0 .ptr 0 0
	0 ? int.print 0 0 0 0 0
	.tmp    .tmp    .loop
	#Variables
	0-2 0-1 .z:0 1
	.tmp:0
	.char:0
	.esc:0-string.escstart
	.nesc:string.escstart-string.escend
	#Formatting defaults
	.base:10
	.padchr:32


#String formatting escape codes. Define here so string.escstart >= 256.

string.escstart:
string.str:     0  #Reserved
string.strfmt:  1  #Reserved
string.uint:    2  #[num]
string.uintfmt: 3  #[num], [base], [padding], [pad char]
string.uintcon: 4  #[num], base, padding, pad char
string.int:     5  #[num]
string.intfmt:  6  #[num], [base], [padding], [pad char], [sign]
string.intcon:  7  #[num], base, padding, pad char, sign
string.escend:


