0 0 demo

demo:

	#Division
	0 ? uint.div .ret0 .ret1 .num .den
	0 ? print string.uint .num 32 47 32 string.uint .den 32 61 32 string.uint .ret0 32 114 101 109 97 105 110 100 101 114 32 string.uint .ret1 10 0

	#Random mod
	0 ? random.mod .ret0 .mod
	0 ? print 109 111 100 32 string.uint .mod 58 32 string.uint .ret0 10 0

	#Allocation
	0 ? mem.alloc .mem .len
	0 ? mem.free .mem

	0-1 0 0

	#Variables
	.ret0: 0
	.ret1: 0

	.num:  933
	.den:  51

	.mod:  20

	.mem:  0
	.len:  100


#|==============================================================================


Unileq Master Library


master.unl contains all basic libraries for ease of use in other projects.


Library index:


          File     |  Line
     --------------+--------
       string.unl  |    40
         uint.unl  |   211
          int.unl  |  1607
       random.unl  |  2584
       memory.unl  |  3074


================================================================================


This library should be included last. Display an error message and exit if it's
not.


|#


0 0 ?+1
0 ? print
	69 82 82 79 82 58 32 109 97 115 116 101 114 46 117
	110 108 32 109 117 115 116 32 98 101 32 105 110 99
	108 117 100 101 100 32 108 97 115 116 10 0
0-1 0 ?-2


#|==============================================================================


String Library - v1.02

Author: Alec Dee - alecdee.github.io - akdee144@gmail.com


--------------------------------------------------------------------------------
Version History


1.00
     Initial version.
     Created print function.
1.01
     Reorganized integer printing constants.
1.02
     Replaced built-in integer printing with uint.print and int.print.
     Library now handles strings instead of just printing.


--------------------------------------------------------------------------------
ASCII Table


  0  00  NUL |  26  1a      |  52  34   4  |  78  4e   N  | 104  68   h
  1  01      |  27  1b  ESC |  53  35   5  |  79  4f   O  | 105  69   i
  2  02      |  28  1c      |  54  36   6  |  80  50   P  | 106  6a   j
  3  03      |  29  1d      |  55  37   7  |  81  51   Q  | 107  6b   k
  4  04      |  30  1e      |  56  38   8  |  82  52   R  | 108  6c   l
  5  05      |  31  1f      |  57  39   9  |  83  53   S  | 109  6d   m
  6  06      |  32  20  SPC |  58  3a   :  |  84  54   T  | 110  6e   n
  7  07  BEL |  33  21   !  |  59  3b   ;  |  85  55   U  | 111  6f   o
  8  08  BCK |  34  22   "  |  60  3c   <  |  86  56   V  | 112  70   p
  9  09  TAB |  35  23   #  |  61  3d   =  |  87  57   W  | 113  71   q
 10  0a  LF  |  36  24   $  |  62  3e   >  |  88  58   X  | 114  72   r
 11  0b  VTB |  37  25   %  |  63  3f   ?  |  89  59   Y  | 115  73   s
 12  0c      |  38  26   &  |  64  40   @  |  90  5a   Z  | 116  74   t
 13  0d  CR  |  39  27   '  |  65  41   A  |  91  5b   [  | 117  75   u
 14  0e      |  40  28   (  |  66  42   B  |  92  5c   \  | 118  76   v
 15  0f      |  41  29   )  |  67  43   C  |  93  5d   ]  | 119  77   w
 16  10      |  42  2a   *  |  68  44   D  |  94  5e   ^  | 120  78   x
 17  11      |  43  2b   +  |  69  45   E  |  95  5f   _  | 121  79   y
 18  12      |  44  2c   ,  |  70  46   F  |  96  60   `  | 122  7a   z
 19  13      |  45  2d   -  |  71  47   G  |  97  61   a  | 123  7b   {
 20  14      |  46  2e   .  |  72  48   H  |  98  62   b  | 124  7c   |
 21  15      |  47  2f   /  |  73  49   I  |  99  63   c  | 125  7d   }
 22  16      |  48  30   0  |  74  4a   J  | 100  64   d  | 126  7e   ~
 23  17      |  49  31   1  |  75  4b   K  | 101  65   e  | 127  7f  DEL
 24  18  CAN |  50  32   2  |  76  4c   L  | 102  66   f  |
 25  19      |  51  33   3  |  77  4d   M  | 103  67   g  |


--------------------------------------------------------------------------------
String formatting escape codes


     string.uint      [num]
     string.uintfmt   [num], [base], [padding], [pad char]
     string.uintcon   [num], base, padding, pad char
     string.int       [num]
     string.intfmt    [num], [base], [padding], [pad char], [sign]
     string.intcon    [num], base, padding, pad char, sign


--------------------------------------------------------------------------------
TODO


|#


print:
	#Call  : 0 ? print char0 char1 char2 ... 0
	#Effect: Prints a zero terminated ASCII string. If an escape code is used,
	#the next value(s) are expected to be numbers or formatting.
	#
	.ptr    .ptr    ?+1
	.ptr    0       ?+1
	.ptr    .z-2    ?+1
	0       0       ?+2
	.ret:   .tmp
.loop:
	#Get the next character.
	.tmp    .ptr:0  ?+1
	.ptr    .z-1    ?+1
	.char   .char   ?+1
	.char   .tmp    ?+1
	#If [char]=0, we've reached the end of the string.
	.char   .z      .ret
	#If [tmp]<=[escape], then we want to print a non-character.
	.tmp    .esc    .escprint
	#Print [char].
	0-2     .char   ?+1
	.tmp    .tmp    .loop
.escprint:
	#Print something other than a character.
	0       .ptr    ?+1
	0       .z-2    ?+1
	#Determine what type of value we're printing.
	.tmp    .z      .str
	.tmp    .nesc   .invalid
	.tmp    .z+1    .intcon
	.tmp    .z+1    .intfmt
	.tmp    .z+1    .int
	.tmp    .z+1    .uintcon
	.tmp    .z+1    .uintfmt
	.tmp    .z+1    .uint
	.tmp    .z+1    .strfmt
.invalid:
	#Invalid format
	.tmp    .tmp    ?+1
	0       0       ?+1
	0 ? print 73 78 86 65 76 73 68 32 70 79 82 77 65 84 10 0
	0-1     0       ?-2
.str:
	#Reserved for string printing.
	0-1     0       ?-2
.strfmt:
	#Reserved for string printing.
	0-1     0       ?-2
.uint:
	mem.getargs.0 ? mem.getargs ?+8 1 .ptr 0 0
	0 ? uint.print 0 .base .z .padchr
	.tmp    .tmp    .loop
.uintfmt:
	mem.getargs.0 ? mem.getargs ?+14 1 ?+13 1 ?+12 1 ?+11 1 .ptr 0 0
	0 ? uint.print 0 0 0 0
	.tmp    .tmp    .loop
.uintcon:
	mem.getargs.0 ? mem.getargs ?+14 1 ?+13 0 ?+12 0 ?+11 0 .ptr 0 0
	0 ? uint.print 0 0 0 0
	.tmp    .tmp    .loop
.int:
	mem.getargs.0 ? mem.getargs ?+8 1 .ptr 0 0
	0 ? int.print 0 .base .z .padchr .z
	.tmp    .tmp    .loop
.intfmt:
	mem.getargs.0 ? mem.getargs ?+16 1 ?+15 1 ?+14 1 ?+13 1 ?+12 1 .ptr 0 0
	0 ? int.print 0 0 0 0 0
	.tmp    .tmp    .loop
.intcon:
	mem.getargs.0 ? mem.getargs ?+16 1 ?+15 0 ?+14 0 ?+13 0 ?+12 0 .ptr 0 0
	0 ? int.print 0 0 0 0 0
	.tmp    .tmp    .loop
	#Variables
	0-2 0-1 .z:0 1
	.tmp:0
	.char:0
	.esc:0-string.escstart
	.nesc:string.escstart-string.escend
	#Formatting defaults
	.base:10
	.padchr:32


#String formatting escape codes. Define here so string.escstart >= 256.

string.escstart:
string.str:     0  #Reserved
string.strfmt:  1  #Reserved
string.uint:    2  #[num]
string.uintfmt: 3  #[num], [base], [padding], [pad char]
string.uintcon: 4  #[num], base, padding, pad char
string.int:     5  #[num]
string.intfmt:  6  #[num], [base], [padding], [pad char], [sign]
string.intcon:  7  #[num], base, padding, pad char, sign
string.escend:


#|==============================================================================


Unsigned Integer Operations - v4.06

Author: Alec Dee - alecdee.github.io - akdee144@gmail.com


--------------------------------------------------------------------------------
Notes


This library provides functions for performing most of the common unsigned
integer operations. In particular, it handles: comparisons, arithmetic, and
bitwise operations.

All functions are bit length agnostic. They don't need to be modified even if
unileq uses a something other than 64 bit integers.

The 0 address will always be 0 upon function return, even if one of the return
value addresses is 0.

This library does not depend on any other libraries.

Worst case time complexity:


       Function  |  Time  |      O(n)
     ------------+--------+----------------
         print   |     -  |   -
          cmp    |    28  |  28
          min    |    34  |  34
          max    |    34  |  34
          set    |    24  |  24
          neg    |    25  |  25
          add    |    30  |  30
          sub    |    31  |  31
          mul    |   885  |  53 + 13*bits
          div    |   885  |  53 + 13*bits
          shl    |   168  |  40 +  2*bits
          shr    |   543  |  31 +  8*bits
          not    |    26  |  26
          and    |   485  |  44 +  7*bits
           or    |   486  |  45 +  7*bits
          xor    |   487  |  46 +  7*bits


--------------------------------------------------------------------------------
Index


Strings
uint.print num base padding padchar

Comparisons
uint.cmp a b lt eq gt
uint.min ret a b
uint.max ret a b

Integer Arithmetic
uint.set ret a
uint.neg ret a
uint.add ret a b
uint.sub ret a b
uint.mul high low a b
uint.div quot rem num den

Bitwise Arithmetic
uint.shl ret num shift
uint.shr ret num shift
uint.not ret a
uint.and ret a b
uint.or  ret a b
uint.xor ret a b


--------------------------------------------------------------------------------
Version History


1.00
     Initial version. Used uint.cmp, mem.get, and mem.set for proof of concept.
     Functions take tens of thousands of instructions.
2.00
     Unrolled functions so they don't use mem.get and mem.set.
     Functions take thousands of instructions.
3.00
     Optimized functions so they are all under or around 1K instructions.
3.01
     Optimized uint.and, or, and xor so the final value is stored in [a]. This
     removes the need for a temporary storage variable.
     Cleaned up uint.cmp so its branching is more straight forward.
3.02
     Optimized uint.set and uint.add to remove 1 instruction.
3.03
     Fixed an error in uint.mul when carrying from low to high. Removed need to
     offset [b] by 1 to check for carrying.
     Updated formatting for uint.cmp.
     Changed uint.div to abort with 0xd0 when dividing by 0.
     Optimized AND/OR/XOR by skipping first loop check.
3.04
     Optimized AND/OR/XOR by 18%. [a] and [b] only need to be offset by 1 on the
     first loop. This removes 2 decrement instructions per loop.
3.05
     Optimized AND/OR/XOR by 11%. Removed the iteration counter and instead
     check if [b]=0. We only set the bottom bit of [a] in 1/4 of cases, and only
     check if [b]=0 in 1/2 of cases. OR/XOR are based off of AND for their loop.
3.06
     Updated comments.
3.07
     Replaced average case time complexity with worst case time complexity.
     Standardized formatting to 8 spaces per column.
3.08
     Updated comments.
3.09
     Changed division-by-0 abort instruction.
     Made uint.shl bit length agnostic and lowered run time by 36%.
     Made uint.shr bit length agnostic and lowered run time by 11%.
3.10
     Added uint.min and uint.max.
     Updated timing measurements to not count calling instruction.
4.00
     Re-added calling instruction to timing measurements.
     Modified uint.shl to calculate bit length on first run.
     Updated descriptions for uint.mul, uint.div, and uint.and.
     Made uint.mul bit length agnostic and lowered run time by 5%.
     Made uint.div bit length agnostic and lowered run time by 6%.
     All functions are now bit length agnostic.
4.01
     Simplified loop termination in mul and div, and lowered run times by 5%.
     mul will skip calculating the high value if high=0. This is 44% faster.
     div will skip calculating the quotient if quot=0. This is 29% faster.
4.02
     Removed bit counting in uint.shl and lowered run time by 6%.
     Simplified uint.shr initialization.
4.03
     Removed a testing function for uint.shl that was included by accident.
     Cleaned up function descriptions.
4.04
     Added uint.print for string printing.
4.05
     Corrected timing for uint.cmp.
4.06
     Lowered run time of uint.min and uint.max from 38 to 34 instructions.
     Cleaned up variable names in uint.set, uint.neg, uint.add, and uint.sub.


--------------------------------------------------------------------------------
TODO


uint.shr
	Remove bit counting.
	Use the relation (n<<<k) - (n<<k) = n>>(64-k).
See if fibonacci multiplication is faster than uint.mul.
See if there's a way to perform functions for non 2^n mods.


|#


#--------------------------------------------------------------------------------
#Strings


uint.print:
	#Call  : 0 ? uint.print num base padding padchar
	#
	#Effect: Prints a number in an arbitrary base.
	#
	#This function works even if unileq's underlying integers are not a power of two.
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	#Get [num].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.nnum   .nnum   ?+1
	.nnum   .p0:0   ?+1
	.num    .num    ?+1
	.num    .nnum   ?+1
	#Get [pad].
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p2     .p2     ?+1
	.p2     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p2:0   ?+1
	.pad    .pad    ?+1
	.pad    .tmp    ?+1
	#Get [padchr].
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p3:0   ?+1
	.padchr .padchr ?+1
	.padchr .tmp    ?+1
	#Get [base].
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.nbase  .nbase  ?+1
	.nbase  .p1:0   ?+1
	.base   .base   ?+1
	.base   .nbase  ?+1
	.nbase  .base   ?+1
	#Make sure 1 <= [base] <= 16.
	.base   .z      ?+7
	.base   .z+1    .unary
	.base   .mxbase .notunary
	0-1     0       ?-2
.unary:
	#[base] = 1. Print 1's like hash marks.
	#Pad while [pad] > [num].
	.pad    .num    .unarypaddone
	0-2     .padchr ?+1
	.pad    .z+1    .unarypaddone
	0-2     .padchr ?-5
.unarypaddone:
	#Print 1's while [num] > 0.
	.num    .z      .ret
	0-2     .hex+2  ?+1
	.num    .z+1    .ret
	0-2     .hex+2  ?-5
.notunary:
	#Calculate the most significant digit and how many digits are in [num].
	.den    .den    ?+1
	.lden   .lden   ?+1
	.base   .base   ?+1
	.base   .nbase  ?+1
	.chr    .chr    ?+1
	.chr    .z-1    ?+1
.firstloop:
	.digits .z-1    ?+1
	#num-=den
	.chr    .base   ?+1
	.num    .den   .firstdone
	.num    .z+1    ?+1
	.chr    .z-2    ?-8
	#den=base*lden-1
	.lden   .lden   ?+1
	.lden   .den    ?+1
	.den    .den    ?+1
	.den    .nnum   ?+1
	.den    .num    ?+1
	.den    .z+1    ?+1
	.num    .num    ?+1
	.num    .nnum   .firstloop
.firstdone:
	#Print padding.
	.pad    .digits ?+10
	0-2     .padchr ?+1
	.pad    .z+1    ?+4
	0-2     .padchr ?-5
	#Correct [num], [base], and [den].
	.chr    .nbase  ?+1
	.base   .z+2    ?+1
	.tmp    .tmp    ?+1
	.tmp    .den    ?+1
	.num    .tmp    ?+1
	.den    .den    ?+1
	.den    .lden   .printdigit
.nextloop:
	#num=num*base
	.z+1    .base   ?+1
	.num    .lden   ?+1
	.nnum   .nnum   ?+1
	.nnum   .num    ?+1
	.num    .nnum   ?+1
	.z+1    .z-2    ?-5
.printdigit:
	#Print a digit.
	.chr    .nhex   ?+1
	0-2     .chr:0  ?+1
	.digits .z+1    .ret
	#digit=num/den
	.chr    .chr    ?+1
	.num    .den    .nextloop
	.num    .z+1    ?+1
	.chr    .z-2    ?-8
.ret:
	0       0       .arg6:6
	#Variables
	0-2 0-1 .z:0 1 2
	.nnum:0
	.num:0
	.mxbase:16-1
	.nbase:0
	.base:0
	.pad:0
	.padchr:32
	.digits:0
	.tmp:0
	.den:0
	.lden:0
	.hex:
		48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55
		56 56 57 57 65 65 66 66 67 67 68 68 69 69 70 70
	.nhex:0-.hex


#--------------------------------------------------------------------------------
#Comparisons


uint.cmp:
	#Call  : 0 ? uint.cmp a b lt eq gt
	#
	#Effect: if [a]<[b]: goto lt
	#      : if [a]=[b]: goto eq
	#      : if [a]>[b]: goto gt
	#
	#Time  : 29
	#
	#Setup stack pointer.
	.z      .arg2   ?+1
	0       .z      ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	0       0       ?+1
	#Get [a]
	.z      .z      ?+1
	.z      .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .z      ?+1
	.z      .z      ?+1
	.z      .p0:0   ?+1
	.a      .a      ?+1
	.a      .z      ?+1
	#Get [b]
	.z      .z      ?+1
	.z      .arg3:3 ?+1
	.b      .b      ?+1
	.b      .z      ?+1
	#Compute [a]-[b]
	.z      .z      ?+1
	.a      .b:0    .le
	#If [a]>[b]
	.z      .arg6:6 .ret
.le:
	.a      .z      .eq
	#If [a]<[b]
	.z      .arg4:4 .ret
.eq:
	#If [a]=[b]
	.z      .arg5:5 .ret
.ret:
	.r0     .r0     ?+1
	.r0     .z      ?+1
	.z      .z      .r0:0
	#Variables
	.a:0
	.z:0 1 2


uint.min:
	#Call  : 0 ? uint.min ret a b
	#
	#Effect: [ret] = min([a],[b])
	#
	#Time  : 34
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get ret
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.na     .na     ?+1
	.na     .p3:0   ?+1
	.a      .a      ?+1
	.a      .na     ?+1
	#Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p4     .p4     ?+1
	.p4     .tmp    ?+1
	#Set [ret]
	.tmp    .tmp    ?+1
	.a      .p4:0   ?+4
	.tmp    .a      ?+1
	.tmp    .ret0:0 ?+1
	.na     .tmp    ?+1
	.ret1:0 .na     ?+1
	#Return
	0       0       .arg5:5
	#Variables
	.off:2
	.tmp:0
	.a:0
	.na:0


uint.max:
	#Call  : 0 ? uint.max ret a b
	#
	#Effect: [ret] = max([a],[b])
	#
	#Time  : 34
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get ret
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.na     .na     ?+1
	.na     .p3:0   ?+1
	.a      .a      ?+1
	.a      .na     ?+1
	#Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p4     .p4     ?+1
	.p4     .tmp    ?+1
	#Set [ret]
	.a      .p4:0   ?+4
	.tmp    .tmp    ?+7
	.tmp    .tmp    ?+1
	.tmp    .a      ?+1
	.tmp    .ret0:0 ?+1
	.na     .tmp    ?+1
	.ret1:0 .na     ?+1
	#Return
	0       0       .arg5:5
	#Variables
	.off:2
	.tmp:0
	.a:0
	.na:0


#--------------------------------------------------------------------------------
#Integer Arithmetic


uint.set:
	#Call  : 0 ? uint.set ret a
	#
	#Effect: [ret] = [a]
	#
	#Time  : 24
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	#Get [ret]
	.ret0   .arg2:2 ?+1
	.ret1   .ret0   ?+1
	.ret2   .ret0   ?+1
	.tmp    .tmp    ?+1
	.tmp    .ret1   ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .tmp    ?+1
	#Set [ret]
	.tmp    .tmp    ?+1
	.tmp    .a0:0   ?+1
	.ret0:0 .ret1:0 ?+1
	.ret2:0 .tmp    ?+1
	0       0       .arg4:4
	#Variables
	.off:2
	.tmp:0


uint.neg:
	#Call  : 0 ? uint.neg ret a
	#
	#Effect: [ret] = -[a]
	#
	#Time  : 25
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	#Get [ret]
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .tmp    ?+1
	#Set [ret]
	.tmp    .tmp    ?+1
	.tmp    .a0:0   ?+1
	.tmp    .ret0:0 ?+1
	.val    .val    ?+1
	.val    .tmp    ?+1
	.ret1:0 .val    ?+1
	0       0       .arg4:4
	#Variables
	.off:2
	.val:0
	.tmp:0


uint.add:
	#Call  : 0 ? uint.add ret a b
	#
	#Effect: [ret] = [a] + [b]
	#
	#Time  : 30
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get [ret]
	.ret0   .arg2:2 ?+1
	.ret1   .ret0   ?+1
	.ret2   .ret0   ?+1
	.tmp    .tmp    ?+1
	.tmp    .ret1   ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .tmp    ?+1
	#Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.b0     .b0     ?+1
	.b0     .tmp    ?+1
	#Set [ret]
	.tmp    .tmp    ?+1
	.tmp    .a0:0   ?+1
	.tmp    .b0:0   ?+1
	.ret0:0 .ret1:0 ?+1
	.ret2:0 .tmp    ?+1
	#Return
	0       0       .arg5:5
	#Variables
	.off:2
	.tmp:0


uint.sub:
	#Call  : 0 ? uint.sub ret a b
	#
	#Effect: [ret]=[a]-[b]
	#
	#Time  : 31
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get [ret]
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .tmp    ?+1
	#Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.b0     .b0     ?+1
	.b0     .tmp    ?+1
	#Set [ret]
	.val    .val    ?+1
	.val    .ret1:0 ?+1
	.val    .b0:0   ?+1
	.tmp    .tmp    ?+1
	.tmp    .a0:0   ?+1
	.tmp    .val    ?+1
	.ret0:0 .tmp    ?+1
	#Return
	0       0       .arg5:5
	#Variables
	.off:2
	.val:0
	.tmp:0


uint.mul:
	#Call  : 0 ? uint.mul high low a b
	#
	#Effect: [high] = [a]*[b] / 2^64
	#      : [low]  = [a]*[b] % 2^64
	#
	#Time  : 53 + 13*bits = 885
	#Time  : 41 +  7*bits = 489 if high=0
	#
	#Use [hval] and [lval] to store the high and low values of [a]*[b]. During each
	#loop, shift [hval], [lval], and [b] to the left by 1. If the top bit of [b] is
	#set, add [a] to [lval] and carry into [hval].
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	#Get high. Only set if [hret]!=0.
	.hret   .hret   ?+1
	.hret   .arg2:2 ?+1
	#Get low
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.l0     .l0     ?+1
	.l0     .tmp    ?+1
	.l1     .l1     ?+1
	.l1     .tmp    ?+1
	#Get -[a]. Use -[a] for adding to [lval].
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.a0     .a0     ?+1
	.a0     .tmp    ?+1
	.a      .a      ?+1
	.a      .a0:0   ?+1
	#Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.b0     .b0     ?+1
	.b0     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .b0:0   ?+1
	.b      .b      ?+1
	.b      .tmp    ?+1
	#Offset [tmp] by 1 to force [b] to be odd.
	.tmp    .z+1    ?+1
	.lval   .lval   ?+1
	.hret   .z      .looplow
	#If -[a]=1, we have to manually set [low]=[b].
	.a      .z-1    ?+1
	.a      .z      .rethigh+3
	.hval   .hval   ?+1
	.lval   .z-1    .loophigh+3
	#-------- Calculate [lval] and [hval] --------
.loophigh:
	#If the highest bit of [b] is set, add [a] to [lval] and carry to [hval].
	.tmp    .b      ?+1
	.b      .tmp    ?+7
	.lval   .a      ?+10
	.hval   .z-1    ?+7
	#If [b]=0, we are done.
	.b      .z      .rethigh
	.lval   .z+1    ?+1
	#Left shift [hval].
	.htmp   .htmp   ?+1
	.htmp   .hval   ?+1
	.hval   .htmp   ?+1
	#Left shift [lval] and carry into [hval].
	.ltmp   .ltmp   ?+1
	.ltmp   .lval   ?+1
	.ltmp   .z+1    ?+1
	.lval   .ltmp   ?+4
	.hval   .z-1    ?+1
	.tmp    .tmp    .loophigh
	#----------- Only calculate [lval] -----------
.looplow:
	#If the highest bit of [b] is set, add [a] to [lval].
	.b      .tmp    ?+7
	.lval   .a      ?+1
	.tmp    .tmp    ?+7
	#If [b]=0, we are done.
	.b      .z      .retlow
	.tmp    .tmp    ?+1
	#Left shift [lval].
	.ltmp   .ltmp   ?+1
	.ltmp   .lval   ?+1
	.lval   .ltmp   ?+1
	.tmp    .b      .looplow
.rethigh:
	#Because we terminate 1 iteration late, return [htmp] and [ltmp] instead of
	#[hval] and [lval].
	.ltmp   .z-1    ?+7
	.ltmp   .ltmp   ?+1
	.htmp   .htmp   ?+1
	#Set [high]
	.h0     .h0     ?+1
	.h0     .hret   ?+1
	.h1     .h1     ?+1
	.h1     .hret   ?+1
	.tmp    .tmp    ?+1
	.tmp    .h0:0   ?+1
	.htmp   .tmp    ?+1
	.h1:0   .htmp   ?+1
.retlow:
	#Set [low]
	.b      .l0:0   ?+1
	.ltmp   .b      ?+1
	.l1:0   .ltmp   ?+1
	0       0       .arg6:6
	#Variables
	0-2 0-1 .z:0 1
	.tmp:0
	.a:0
	.b:0
	.hret:0
	.hval:0
	.htmp:0
	.lval:0
	.ltmp:0


uint.div:
	#Call  : 0 ? uint.div quot rem num den
	#
	#Effect: [quot] = [num] / [den] , rounded down
	#      : [rem]  = [num] % [den]
	#
	#Time  : 53 + 13*bits = 885
	#      : 45 +  9*bits = 621 if quot=0
	#
	#Every loop, shift [quot], [rem], and [num] left by 1. If the top bit of [num] is
	#set, add 1 to [rem]. Then, if [rem]>=[den], add 1 to [quot] and subtract [den]
	#from [rem].
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	#Get quot. Only set if qret!=0.
	.qret   .qret   ?+1
	.qret   .arg2:2 ?+1
	#Get rem
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.r2     .r2     ?+1
	.r2     .tmp    ?+1
	.r3     .r3     ?+1
	.r3     .tmp    ?+1
	#Get [den]
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.nden   .nden   ?+1
	.nden   .p1:0   ?+1
	#If [den]=0, abort.
	.nden   .z      .divz
	.nden   .z-1    ?+1
	.den    .den    ?+1
	.den    .nden   ?+1
	#Get [num]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1
	.num    .num    ?+1
	.num    .tmp    ?+1
	#Offset [tmp] by 1 to force [num] to be odd.
	.tmp    .z+1    ?+1
	.rem    .rem    ?+1
	.qret   .z      .looprem
	#-------- Calculate [rem] and [quot] --------
.loopquot:
	#[rem]+=[num]>>63, [num]<<=1. If [num]=0, abort.
	.num    .tmp    ?+4
	.rem    .z-1    ?+4
	.num    .z      .retquot
	#If [rem]>=[den], [quot]+=1
	.rem    .den    ?+7
	.rem    .z+1    ?+1
	.quot   .z-1    ?+4
	.rem    .nden   ?+1
	#[quot]<<=1.
	.qtmp   .qtmp   ?+1
	.qtmp   .quot   ?+1
	.quot   .qtmp   ?+1
	#[rem]<<=1
	.rtmp   .rtmp   ?+1
	.rtmp   .rem    ?+1
	.rem    .rtmp   ?+1
	.tmp    .tmp    ?+1
	.tmp    .num    .loopquot
	#----------- Only calculate [rem] -----------
.looprem:
	#[rem]+=[num]>>63, [num]<<=1. If [num]=0, abort.
	.num    .tmp    ?+4
	.rem    .z-1    ?+4
	.num    .z      .retrem
	#If [rem]>=[den], [quot]+=1
	.rem    .den    ?+7
	.rem    .z+1    ?+1
	.rtmp   .rtmp   ?+7
	.rem    .nden   ?+1
	.rtmp   .rtmp   ?+1
	#[rem]<<=1
	.rtmp   .rem    ?+1
	.rem    .rtmp   ?+1
	.tmp    .tmp    ?+1
	.tmp    .num    .looprem
.retquot:
	#Because we terminate 1 iteration late, return [qtmp] and [rtmp] instead of
	#[quot] and [rem].
	#Set [quot]
	.r0     .r0     ?+1
	.r0     .qret   ?+1
	.r1     .r1     ?+1
	.r1     .qret   ?+1
	.tmp    .tmp    ?+1
	.tmp    .r0:0   ?+1
	.qtmp   .tmp    ?+1
	.r1:0   .qtmp   ?+1
.retrem:
	#Set [rem]
	.num    .r2:0   ?+1
	.rtmp   .num    ?+1
	.r3:0   .rtmp   ?+1
	0       0       .arg6:6
.divz:
	#Abort
	0-1     0       ?-2
	#Variables
	0-2 0-1 .z:0 1
	.tmp:0
	.num:0
	.den:0
	.nden:0
	.qret:0
	.quot:0
	.qtmp:0
	.rem:0
	.rtmp:0


#--------------------------------------------------------------------------------
#Bitwise Arithmetic


uint.shl:
	#Call  : 0 ? uint.shl ret num shift
	#
	#Effect: [ret] = [num] << [shift]
	#
	#Time  : 56 + 16*((bits-1)/8) = 168
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get ret.
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	#Get [shift]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p1:0   ?+1
	.shift  .tmp    ?+1
	#Get -[num]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.num    .num    ?+1
	.num    .p0:0   .done8-3
	#[num]=[num]<<8. Abort if [num]=0.
.loop8:
	.num    .z      .ret
	.shift  .p8     .done8
	.tmp    .num    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.num    .tmp    ?+1
	.tmp    .num    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.num    .tmp    ?+1
	.tmp    .num    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .tmp    .loop8
.done8:
	.shift  .z      .loop8+6
	.shift  .n8     .done1
	#[num]=[num]<<3
	.shift  .z+2    .done3
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.num    .tmp    ?+1
	.tmp    .tmp    ?+1
	#[num]=[num]<<3
	.shift  .z+3    .done3
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.num    .tmp    ?+1
	.tmp    .tmp    ?+4
.done3:
	.shift  .z-3    ?+1
	#[num]=[num]<<1
	.shift  .z+1    .done1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .tmp    ?+1
	#[num]=[num]<<1
	.shift  .z+1    .done1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .tmp    ?+1
.ret:
	.shift  .shift  ?+1
.done1:
	#Set [ret].
	.tmp    .ret0:0 ?+1
	.num    .tmp    ?+1
	.ret1:0 .num    ?+1
	0       0       .arg5:5
	#Variables
	.num:0
	.shift:0
	.tmp:0
	0-3 0-2 0-1 .z:0 1 2 3
	.p8:8
	.n8:0-8


uint.shr:
	#Call  : 0 ? uint.shr ret num shift
	#
	#Effect: [ret] = [num] >> [shift]
	#
	#Time  : 31 + 8*bits = 543
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#On first run, calculate how many bits we are using.
	.tmp    .tmp    .firsts:?+1
	.firsts .firstv ?+1
	.num    .z-1    ?+1
.firstloop:
	.num    .z      .firstdone
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.nbits  .z+1    ?+1
	.tmp    .tmp    .firstloop
.firstdone:
	#Get ret
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	.rval   .rval   ?+1
	#Get [shift]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.tmp    .tmp    ?+1
	#If [shift]>=[bits], abort.
	.shift  .nbits  ?+1
	.shift  .p1:0   .ret
	#Get [num]
	.tmp    .arg3:3 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1
	.num    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .z+1    ?+1
.loop:
	#[num]<<=1. Carry into [rval].
	.num    .tmp    ?+4
	.rval   .z-1    ?+1
	.tmp    .tmp    ?+1
	.shift  .z+1    .ret+3
	#[rval]<<=1
	.tmp    .rval   ?+1
	.rval   .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .num    .loop
.ret:
	.shift  .shift  ?+1
	#Set [ret].
	.rval   .ret0:0 ?+1
	.tmp    .rval   ?+1
	.ret1:0 .tmp    ?+1
	0       0       .arg5:5
	#Variables
	.firstv:.firsts+1-.firstdone
	.nbits:0
	.num:0
	.rval:0
	.shift:0
	.tmp:0
	0-1 .z:0 1 2


uint.not:
	#Call  : 0 ? uint.not ret a
	#
	#Effect: [ret] = ~[a]
	#
	#Time  : 26
	#
	#Use the relation -1-[a]=~[a].
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	#Get [ret]
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p2     .p2     ?+1
	.p2     .tmp    ?+1
	#Set [ret]
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1
	.tmp    .p2:0   ?+1
	.tmp    .z+1    ?+1
	.ret    .ret    ?+1
	.ret    .tmp    ?+1
	.p1:0   .ret    ?+1
	0       0       .arg4:4
	#Variables
	.z:0 1 2
	.ret:0
	.tmp:0


uint.and:
	#Call  : 0 ? uint.and ret a b
	#
	#Effect: [ret] = [a] & [b]
	#
	#Time  : 44 + 7*bits = 485
	#
	#Make sure [a] and [b] are odd. Every loop, rotate [a] to the left and shift [b]
	#to the left. Depending on how the top bits of [a] and [b] are set, add 1 to [a].
	#Stop when [b]=0, and return [a]. Branches are organized in the loop to minimize
	#instructions.
	#
	#Setup stack pointer.
	.atmp   .arg2   ?+1
	0       .atmp   ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get [ret]
	.atmp   .atmp   ?+1
	.atmp   .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .atmp   ?+1
	.ret1   .ret1   ?+1
	.ret1   .atmp   ?+1
	#Get [a]
	.atmp   .atmp   ?+1
	.atmp   .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .atmp   ?+1
	.atmp   .atmp   ?+1
	.atmp   .a0:0   ?+1
	.a      .a      ?+1
	.a      .atmp   ?+1
	#Get [b]
	.btmp   .btmp   ?+1
	.btmp   .arg4:4 ?+1
	.b0     .b0     ?+1
	.b0     .btmp   ?+1
	.btmp   .btmp   ?+1
	.btmp   .b0:0   ?+1
	.b      .btmp   ?+1
	#Perform the first iteration outside of the loop. We need [a] and [b] to be odd
	#so that we can efficiently check for carrying in the loop. Flag if the top bit
	#needs to be set at the end.
	        .atmp   .z+1    ?+1
	        .btmp   .z+1    ?+1
	        .a      .atmp   .l0x
	.l1x:   .b      .btmp   .l00
	.l11:   .atmp   .atmp   .loop
	.l0x:   .b      .btmp   .l00
	.l00:   .top    .z+1    ?+1
	        .atmp   .atmp   .loop
	#Loop until [b]=0.
.loop:
	#Prepare [b] for shift and carry.
	        .btmp   .btmp   ?+1
	        .btmp   .b      ?+1
	#Left shift [a] and [b] and check for carry. Set low bit of [a] if needed.
	#If [b]<=[btmp] and [b]=0, then we are done.
	        .b      .btmp   .f0x
	.f1x:   .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f11:   .a      .z-1    .f00
	.f0x:   .b      .z      .done
	        .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f00:   .atmp   .atmp   .loop
.done:
	#Check if the top bit needs to be zero'd.
	.top    .top:.z ?+4
	.a      .btmp   ?+1
	#We have [a]=[a]&[b]+-[btmp] and [btmp]=2^(n-1).
	.a      .ret0:0 ?+1
	.btmp   .a      ?+1
	.ret1:0 .btmp   ?+1
	0       0       .arg5:5
	#Variables
	0-1 .z:0 1 2
	.a:0 .atmp:0
	.b:0 .btmp:0


uint.or:
	#Call  : 0 ? uint.or ret a b
	#
	#Effect: [ret] = [a] | [b]
	#
	#Time  : 45 + 7*bits = 486
	#
	#Use bitwise AND and the relation A|B=-1-(~A)&(~B).
	#
	#Setup stack pointer.
	.atmp   .arg2   ?+1
	0       .atmp   ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get [ret]
	.atmp   .atmp   ?+1
	.atmp   .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .atmp   ?+1
	.ret1   .ret1   ?+1
	.ret1   .atmp   ?+1
	#Get -[a]
	.atmp   .atmp   ?+1
	.atmp   .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .atmp   ?+1
	.a      .a      ?+1
	.a      .a0:0   ?+1
	.atmp   .atmp   ?+1
	.atmp   .a      ?+1
	#Get -[b]
	.btmp   .btmp   ?+1
	.btmp   .arg4:4 ?+1
	.b0     .b0     ?+1
	.b0     .btmp   ?+1
	.b      .b0:0   ?+1
	.btmp   .btmp   ?+1
	.btmp   .b      ?+1
	#Perform the first iteration outside of the loop. We need [a] and [b] to be odd
	#so that we can efficiently check for carrying in the loop. Flag if the top bit
	#needs to be set.
	        .a      .z+1    ?+1
	        .b      .z+1    ?+1
	        .a      .atmp   .l0x
	.l1x:   .b      .btmp   .l00
	.l11:   .atmp   .atmp   .loop
	.l0x:   .b      .btmp   .l00
	.l00:   .top    .z+1    ?+1
	        .atmp   .atmp   .loop
	#Loop until [b]=0.
.loop:
	#Prepare [b] for shift and carry.
	        .btmp   .btmp   ?+1
	        .btmp   .b      ?+1
	#Left shift [a] and [b] and check for carry. Set low bit of [a] if needed.
	#If [b]<=[btmp] and [b]=0, then we are done.
	        .b      .btmp   .f0x
	.f1x:   .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f11:   .a      .z-1    .f00
	.f0x:   .b      .z      .done
	        .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f00:   .atmp   .atmp   .loop
.done:
	#Check if the top bit needs to be zero'd.
	.top    .top:.z ?+4
	.a      .btmp   ?+1
	#We have [a]=[a]&[b]+-[btmp] and [btmp]=2^(n-1).
	#A|B=-1-(~A)&(~B)
	.a      .z-1    ?+1
	.btmp   .ret0:0 ?+1
	.a      .btmp   ?+1
	.ret1:0 .a      ?+1
	0       0       .arg5:5
	#Variables
	0-1 .z:0 1 2
	.a:0 .atmp:0
	.b:0 .btmp:0


uint.xor:
	#Call  : 0 ? uint.xor ret a b
	#
	#Effect: [ret] = [a] ^ [b]
	#
	#Time  : 46 + 7*bits = 487
	#
	#Use bitwise AND and the relation A^B=A+B-2(A&B).
	#
	#Setup stack pointer.
	.atmp   .arg2   ?+1
	0       .atmp   ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get [ret]
	.atmp   .atmp   ?+1
	.atmp   .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .atmp   ?+1
	.ret1   .ret1   ?+1
	.ret1   .atmp   ?+1
	#Get [a]
	.atmp   .atmp   ?+1
	.atmp   .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .atmp   ?+1
	.atmp   .atmp   ?+1
	.atmp   .a0:0   ?+1
	.a      .a      ?+1
	.a      .atmp   ?+1
	#Get [b]
	.btmp   .btmp   ?+1
	.btmp   .arg4:4 ?+1
	.b0     .b0     ?+1
	.b0     .btmp   ?+1
	.btmp   .btmp   ?+1
	.btmp   .b0:0   ?+1
	.b      .btmp   ?+1
	#Perform the first iteration outside of the loop. We need [a] and [b] to be odd
	#so that we can efficiently check for carrying in the loop.
	.off    .off    ?+1
	.off    .atmp   ?+1
	.off    .btmp   ?+1
	.atmp   .z+1    ?+1
	.btmp   .z+1    ?+1
	.a      .atmp   ?+1
	.b      .btmp   ?+1
	.atmp   .atmp   .loop
	#Loop until [b]=0.
.loop:
	#Prepare [b] for shift and carry.
	        .btmp   .btmp   ?+1
	        .btmp   .b      ?+1
	#Left shift [a] and [b] and check for carry. Set low bit of [a] if needed.
	#If [b]<=[btmp] and [b]=0, then we are done.
	        .b      .btmp   .f0x
	.f1x:   .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f11:   .a      .z-1    .f00
	.f0x:   .b      .z      .done
	        .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f00:   .atmp   .atmp   .loop
.done:
	#We have [a]=[a]&[b]+-[btmp] and [btmp]=2^(n-1).
	#Use A^B=A+B-2(A&B).
	.off    .a      ?+1
	.off    .ret0:0 ?+1
	.a      .off    ?+1
	.ret1:0 .a      ?+1
	0       0       .arg5:5
	#Variables
	0-1 .z:0 1 2
	.a:0 .atmp:0
	.b:0 .btmp:0
	.off:0


#|==============================================================================


Signed Integer Operations - v1.02

Author: Alec Dee - alecdee.github.io - akdee144@gmail.com


--------------------------------------------------------------------------------
Notes


This library provides functions for performing the signed integer operations
that uint.unl doesn't cover.

If unileq's underlying integers are mod N, then we consider an integer to be
negative if x >= floor((N+1)/2). The negative value of x is x' = x - N.

All functions are bit length agnostic. They don't need to be modified even if
unileq uses a something other than 64 bit integers.

The 0 address will always be 0 upon function return, even if one of the return
value addresses is 0.

This library does not depend on any other libraries.

Worst case time complexity:


       Function  |  Time  |      O(n)
     ------------+--------+----------------
         print   |     -  |  -
          cmp    |    37  |  37
          min    |    43  |  43
          max    |    43  |  43
          abs    |    30  |  30
          mul    |   898  |  66 + 13*bits
          div    |   904  |  72 + 13*bits
          shr    |   555  |  43 +  8*bits


--------------------------------------------------------------------------------
Index


Strings
int.print num base padding padchar sign

Comparisons
int.cmp a b lt eq gt
int.min ret a b
int.max ret a b
int.abs ret a

Integer Arithmetic
int.mul high low a b
int.div quot rem num den

Bitwise Arithmetic
int.shr ret num shift


--------------------------------------------------------------------------------
Version History


1.00
     Initial version.
     Most functions are based off of their unsigned equivalents.
1.01
     Added int.cmp, int.min, int.max, int.abs, int.mul, int.div, and int.shr.
1.02
     Removed a temporary variable in int.abs.


--------------------------------------------------------------------------------
TODO


Optimize sign extension for int.shr.
Optimize int.cmp.


|#


#--------------------------------------------------------------------------------
#Strings


int.print:
	#Call  : 0 ? int.print num base padding padchar sign
	#
	#Effect: Prints a signed number in an arbitrary base. If the padding
	#character is whitespace, print the sign after padding.
	#
	#This function works even if unileq's underlying integers are not a power of two.
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	.arg7   0       ?+1
	#Get [num].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.nnum   .nnum   ?+1
	.nnum   .p0:0   ?+1
	.num    .num    ?+1
	.num    .nnum   ?+1
	#Check if [num] < 0.
	.nnum   .z+1    ?+1
	.num    .nnum   .notneg
	#Set [nnum] = [num].
	.tmp    .tmp    ?+1
	.tmp    .num    ?+1
	.nnum   .tmp    ?+1
	.sign   .nneg   .isneg
.notneg:
	.nnum   .z-1    ?+1
	#Load [sign].
	.tmp    .tmp    ?+1
	.tmp    .arg6:6 ?+1
	.p4     .p4     ?+1
	.p4     .tmp    ?+1
	.p4:0   .z      .isneg
	.sign   .nplus  ?+1
.isneg:
	.num    .num    ?+1
	.num    .nnum   ?+1
	#Get [pad].
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p2     .p2     ?+1
	.p2     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p2:0   ?+1
	.pad    .pad    ?+1
	.pad    .tmp    ?+1
	#Get [padchr].
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p3:0   ?+1
	.padchr .padchr ?+1
	.padchr .tmp    ?+1
	#If [padchr] is not whitespace, print [sign] before padding.
	.sign   .z      .nosign
	.pad    .z      ?+4
	.pad    .z+1    ?+1
	.padchr .white  ?+7
	0-2     .sign   ?+1
	.sign   .sign   ?+1
	.padchr .nwhite ?+1
.nosign:
	#Get [base].
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.nbase  .nbase  ?+1
	.nbase  .p1:0   ?+1
	.base   .base   ?+1
	.base   .nbase  ?+1
	.nbase  .base   ?+1
	#Make sure 1 <= [base] <= 16.
	.base   .z      ?+7
	.base   .z+1    .unary
	.base   .mxbase .notunary
	0-1     0       ?-2
.unary:
	#[base] = 1. Print 1's like hash marks.
	#Pad while [pad] > [num].
	.pad    .num    .unarypaddone
	0-2     .padchr ?+1
	.pad    .z+1    .unarypaddone
	0-2     .padchr ?-5
.unarypaddone:
	#Print the sign if we haven't yet.
	.sign   .z      ?+7
	0-2     .sign   ?+1
	.sign   .sign   ?+1
	#Print 1's while [num] > 0.
	.num    .z      .ret
	0-2     .hex+2  ?+1
	.num    .z+1    .ret
	0-2     .hex+2  ?-5
.notunary:
	#Calculate the most significant digit and how many digits are in [num].
	.den    .den    ?+1
	.lden   .lden   ?+1
	.base   .base   ?+1
	.base   .nbase  ?+1
	.chr    .chr    ?+1
	.chr    .z-1    ?+1
.firstloop:
	.digits .z-1    ?+1
	#num-=den
	.chr    .base   ?+1
	.num    .den   .firstdone
	.num    .z+1    ?+1
	.chr    .z-2    ?-8
	#den=base*lden-1
	.lden   .lden   ?+1
	.lden   .den    ?+1
	.den    .den    ?+1
	.den    .nnum   ?+1
	.den    .num    ?+1
	.den    .z+1    ?+1
	.num    .num    ?+1
	.num    .nnum   .firstloop
.firstdone:
	#Print padding.
	.pad    .digits ?+10
	0-2     .padchr ?+1
	.pad    .z+1    ?+4
	0-2     .padchr ?-5
	#Print the sign if we haven't yet.
	.sign   .z      ?+7
	0-2     .sign   ?+1
	.sign   .sign   ?+1
	#Correct [num], [base], and [den].
	.chr    .nbase  ?+1
	.base   .z+2    ?+1
	.tmp    .tmp    ?+1
	.tmp    .den    ?+1
	.num    .tmp    ?+1
	.den    .den    ?+1
	.den    .lden   .printdigit
.nextloop:
	#num=num*base
	.z+1    .base   ?+1
	.num    .lden   ?+1
	.nnum   .nnum   ?+1
	.nnum   .num    ?+1
	.num    .nnum   ?+1
	.z+1    .z-2    ?-5
.printdigit:
	#Print a digit.
	.chr    .nhex   ?+1
	0-2     .chr:0  ?+1
	.digits .z+1    .ret
	#digit=num/den
	.chr    .chr    ?+1
	.num    .den    .nextloop
	.num    .z+1    ?+1
	.chr    .z-2    ?-8
.ret:
	0       0       .arg7:7
	#Variables
	0-2 0-1 .z:0 1 2
	.nnum:0
	.num:0
	.mxbase:16-1
	.nbase:0
	.base:0
	.pad:0
	.padchr:32
	.digits:0
	.tmp:0
	.den:0
	.lden:0
	.white:32
	.nwhite:0-32
	.sign:0
	.nplus:0-43
	.nneg:0-45
	.hex:
		48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55
		56 56 57 57 65 65 66 66 67 67 68 68 69 69 70 70
	.nhex:0-.hex


#--------------------------------------------------------------------------------
#Comparisons


int.cmp:
	#Call  : 0 ? int.cmp a b lt eq gt
	#
	#Effect: For signed [a] and [b].
	#      : if [a]<[b]: goto lt
	#      : if [a]=[b]: goto eq
	#      : if [a]>[b]: goto gt
	#
	#Time  : 37
	#
	#Setup stack pointer.
	.z      .arg2   ?+1
	0       .z      ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	0       0       ?+1
	#Get [a]
	.z      .z      ?+1
	.z      .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .z      ?+1
	.na     .na     ?+1
	.na     .p0:0   ?+1
	.a      .a      ?+1
	.a      .na     ?+1
	.na     .z+1    ?+1
	#Get [b]
	.z      .z      ?+1
	.z      .arg3:3 ?+1
	.p1     .p1     ?+1
	.p1     .z      ?+1
	.nb     .nb     ?+1
	.nb     .p1:0   ?+1
	.b      .b      ?+1
	.b      .nb     ?+1
	.nb     .z+1    ?+1
	.z      .z      ?+1
	#Check if [a]>=0 or [b]>=0.
	.a      .na     .age0
	.b      .nb     .alt0bge0
.age0bge0:
	.na     .nb     .ge
.alt0bge0:
	#If [a]<[b]
	.z      .arg4:4 .ret
.age0:
	.b      .nb     .age0bge0
.ge:
	.na     .z      .eq
.gt:
	#If [a]>[b]
	.z      .arg6:6 .ret
.eq:
	#If [a]=[b]
	.z      .arg5:5 .ret
.ret:
	.r0     .r0     ?+1
	.r0     .z      ?+1
	.z      .z      .r0:0
	#Variables
	.a:0
	.na:0
	.b:0
	.nb:0
	.z:0 1 2


int.min:
	#Call  : 0 ? int.min ret a b
	#
	#Effect: [ret] = min([a],[b]) for signed [a] and [b].
	#
	#Time  : 43
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get ret
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.na     .na     ?+1
	.na     .p3:0   ?+1
	.a      .a      ?+1
	.a      .na     ?+1
	#Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p4     .p4     ?+1
	.p4     .tmp    ?+1
	.nb     .nb     ?+1
	.nb     .p4:0   ?+1
	.b      .b      ?+1
	.b      .nb     ?+1
	#Set [ret]
	.tmp    .tmp    ?+1
	.val    .val    ?+1
	.a      .na     .age0
	.b      .nb     .alt0bge0
.age0bge0:
	.a      .b      ?+4
	.val    .nb     .ret
.alt0bge0:
	.b      .z      .beq0
	.val    .na     .ret
.beq0:
	.nb     .z      ?-5
	.val    .nb     .ret
.age0:
	.b      .nb     .age0bge0
	.a      .z      .aeq0
	.val    .nb     .ret
.aeq0:
	.na     .z      ?-5
	.val    .na     .ret
.ret:
	.val    .ret0:0 ?+1
	.tmp    .val    ?+1
	.ret1:1 .tmp    ?+1
	#Return
	0       0       .arg5:5
	#Variables
	.z:0 1 2
	.tmp:0
	.a:0
	.na:0
	.b:0
	.nb:0
	.val:0


int.max:
	#Call  : 0 ? int.max ret a b
	#
	#Effect: [ret] = max([a],[b]) for signed [a] and [b].
	#
	#Time  : 43
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get ret
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.na     .na     ?+1
	.na     .p3:0   ?+1
	.a      .a      ?+1
	.a      .na     ?+1
	#Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p4     .p4     ?+1
	.p4     .tmp    ?+1
	.nb     .nb     ?+1
	.nb     .p4:0   ?+1
	.b      .b      ?+1
	.b      .nb     ?+1
	#Set [ret]
	.tmp    .tmp    ?+1
	.val    .val    ?+1
	.a      .na     .age0
	.b      .nb     .alt0bge0
.age0bge0:
	.a      .b      ?+4
	.val    .na     .ret
.alt0bge0:
	.b      .z      .beq0
	.val    .nb     .ret
.beq0:
	.nb     .z      ?-5
	.val    .na     .ret
.age0:
	.b      .nb     .age0bge0
	.a      .z      .aeq0
	.val    .na     .ret
.aeq0:
	.na     .z      ?-5
	.val    .nb     .ret
.ret:
	.val    .ret0:0 ?+1
	.tmp    .val    ?+1
	.ret1:1 .tmp    ?+1
	#Return
	0       0       .arg5:5
	#Variables
	.z:0 1 2
	.tmp:0
	.a:0
	.na:0
	.b:0
	.nb:0
	.val:0


int.abs:
	#Call  : 0 ? int.abs ret a
	#
	#Effect: [ret] = abs([a])
	#
	#Time  : 30
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	#Get [ret]
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	#Get [val]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.nval   .nval   ?+1
	.nval   .p0:0   ?+1
	.val    .val    ?+1
	.val    .nval   ?+1
	#Check if [val] < 0.
	.tmp    .tmp    ?+1
	.nval   .z+1    ?+1
	.val    .nval   ?+4
	.tmp    .val    ?+4
	.nval   .z-1    ?+1
	#Set [ret].
	.tmp    .ret0:0 ?+1
	.nval   .tmp    ?+1
	.ret1:0 .nval   ?+1
	0       0       .arg4:4
	#Variables
	0-1 .z:0 1 2
	.tmp:0
	.val:0
	.nval:0


#--------------------------------------------------------------------------------
#Integer Arithmetic


int.mul:
	#Call  : 0 ? int.mul high low a b
	#
	#Effect: [high] = [a]*[b] / 2^64 , sign extended
	#      : [low]  = [a]*[b] % 2^64
	#
	#Time  : 66 + 13*bits = 898
	#Time  : 45 +  7*bits = 493 if high=0
	#
	#Use [hval] and [lval] to store the high and low values of [a]*[b]. During each
	#loop, shift [hval], [lval], and [b] to the left by 1. If the top bit of [b] is
	#set, add [a] to [lval] and carry into [hval].
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	#Get high. Only set if [hret]!=0.
	.hret   .hret   ?+1
	.hret   .arg2:2 ?+1
	#Get low
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.l0     .l0     ?+1
	.l0     .tmp    ?+1
	.l1     .l1     ?+1
	.l1     .tmp    ?+1
	#Get -[a]. Use -[a] for adding to [lval].
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.a0     .a0     ?+1
	.a0     .tmp    ?+1
	.na     .na     ?+1
	.na     .a0:0   ?+1
	.a      .a      ?+1
	.a      .na     ?+1
	#Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.b0     .b0     ?+1
	.b0     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .b0:0   ?+1
	.b      .b      ?+1
	.b      .tmp    ?+1
	.nb     .nb     ?+1
	.nb     .b      ?+1
	#Offset [tmp] by 1 to force [b] to be odd.
	.tmp    .z+1    ?+1
	.lval   .lval   ?+1
	.hret   .z      .looplow
	#If -[a]=1, we have to manually set [low]=[b].
	.na     .z-1    ?+1
	.na     .z      .rethigh+3
	.hval   .hval   ?+1
	.lval   .z-1    .loophigh+3
	#-------- Calculate [lval] and [hval] --------
.loophigh:
	#If the highest bit of [b] is set, add [a] to [lval] and carry to [hval].
	.tmp    .b      ?+1
	.b      .tmp    ?+7
	.lval   .na     ?+10
	.hval   .z-1    ?+7
	#If [b]=0, we are done.
	.b      .z      .rethigh
	.lval   .z+1    ?+1
	#Left shift [hval].
	.htmp   .htmp   ?+1
	.htmp   .hval   ?+1
	.hval   .htmp   ?+1
	#Left shift [lval] and carry into [hval].
	.ltmp   .ltmp   ?+1
	.ltmp   .lval   ?+1
	.ltmp   .z+1    ?+1
	.lval   .ltmp   ?+4
	.hval   .z-1    ?+1
	.tmp    .tmp    .loophigh
	#----------- Only calculate [lval] -----------
.looplow:
	#If the highest bit of [b] is set, add [a] to [lval].
	.b      .tmp    ?+7
	.lval   .na     ?+1
	.tmp    .tmp    ?+7
	#If [b]=0, we are done.
	.b      .z      .retlow
	.tmp    .tmp    ?+1
	#Left shift [lval].
	.ltmp   .ltmp   ?+1
	.ltmp   .lval   ?+1
	.lval   .ltmp   ?+1
	.tmp    .b      .looplow
.rethigh:
	#Because we terminate 1 iteration late, return [htmp] and [ltmp] instead of
	#[hval] and [lval].
	.ltmp   .z-1    ?+7
	.ltmp   .ltmp   ?+1
	.htmp   .htmp   ?+1
	#If [a]<0, sub [b] from [high].
	.na     .z+2    ?+1
	.a      .na     ?+4
	.htmp   .nb     ?+1
	#If [b]<0, sub [a] from [high].
	.tmp    .tmp    ?+1
	.tmp    .nb     ?+1
	.nb     .z+1    ?+1
	.tmp    .nb     ?+7
	.htmp   .na     ?+1
	.htmp   .z+1    ?+1
	#Set [high]
	.h0     .h0     ?+1
	.h0     .hret   ?+1
	.h1     .h1     ?+1
	.h1     .hret   ?+1
	.tmp    .tmp    ?+1
	.tmp    .h0:0   ?+1
	.htmp   .tmp    ?+1
	.h1:0   .htmp   ?+1
.retlow:
	#Set [low]
	.b      .l0:0   ?+1
	.ltmp   .b      ?+1
	.l1:0   .ltmp   ?+1
	0       0       .arg6:6
	#Variables
	0-2 0-1 .z:0 1 2
	.tmp:0
	.a:0
	.na:0
	.b:0
	.nb:0
	.hret:0
	.hval:0
	.htmp:0
	.lval:0
	.ltmp:0


int.div:
	#Call  : 0 ? int.div quot rem num den
	#
	#Effect: [quot] = [num] / [den] , rounded towards 0
	#      : [rem]  = [num] % [den]
	#
	#Time  : 72 + 13*bits = 904
	#      : 64 +  9*bits = 640 if quot=0
	#
	#Every loop, shift [quot], [rem], and [num] left by 1. If the top bit of [num] is
	#set, add 1 to [rem]. Then, if [rem]>=[den], add 1 to [quot] and subtract [den]
	#from [rem].
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	#Get quot. Only set if qret!=0.
	.qret   .qret   ?+1
	.qret   .arg2:2 ?+1
	#Get rem
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.r2     .r2     ?+1
	.r2     .tmp    ?+1
	.r3     .r3     ?+1
	.r3     .tmp    ?+1
	#Get [den]
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.nden   .nden   ?+1
	.nden   .p1:0   ?+1
	#If [den]=0, abort.
	.nden   .z      .divz
	#Check if [den]<0.
	.den    .den    ?+1
	.den    .nden   ?+1
	.nden   .z+1    ?+1
	.den    .nden   .denpos
	.tmp    .tmp    ?+1
	.tmp    .den    ?+1
	.nden   .tmp    ?+1
	.nden   .z-1    ?+1
	.qsign  .z-1    ?+4
.denpos:
	#Correct [den].
	.nden   .z-2    ?+1
	.den    .den    ?+1
	.den    .nden   ?+1
	#Get [num]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1
	.num    .num    ?+1
	.num    .tmp    ?+1
	#If [num]<0.
	.tmp    .z+1    ?+1
	.num    .tmp    .numpos
	.rsign  .num    ?+1
	.tmp    .rsign  ?+1
	.qsign  .z      ?+4
	.qsign  .qsign  .numpos+3
	.qsign  .z-1    .numpos+3
.numpos:
	.tmp    .z-1    ?+1
	.num    .num    ?+1
	.num    .tmp    ?+1
	#Offset [tmp] by 1 to force [num] to be odd.
	.tmp    .z+1    ?+1
	.rem    .rem    ?+1
	.qret   .z      .looprem
	#-------- Calculate [rem] and [quot] --------
.loopquot:
	#[rem]+=[num]>>63, [num]<<=1. If [num]=0, abort.
	.num    .tmp    ?+4
	.rem    .z-1    ?+4
	.num    .z      .retquot
	#If [rem]>=[den], [quot]+=1
	.rem    .den    ?+7
	.rem    .z+1    ?+1
	.quot   .z-1    ?+4
	.rem    .nden   ?+1
	#[quot]<<=1.
	.qtmp   .qtmp   ?+1
	.qtmp   .quot   ?+1
	.quot   .qtmp   ?+1
	#[rem]<<=1
	.rtmp   .rtmp   ?+1
	.rtmp   .rem    ?+1
	.rem    .rtmp   ?+1
	.tmp    .tmp    ?+1
	.tmp    .num    .loopquot
	#----------- Only calculate [rem] -----------
.looprem:
	#[rem]+=[num]>>63, [num]<<=1. If [num]=0, abort.
	.num    .tmp    ?+4
	.rem    .z-1    ?+4
	.num    .z      .retrem
	#If [rem]>=[den], [quot]+=1
	.rem    .den    ?+7
	.rem    .z+1    ?+1
	.rtmp   .rtmp   ?+7
	.rem    .nden   ?+1
	.rtmp   .rtmp   ?+1
	#[rem]<<=1
	.rtmp   .rem    ?+1
	.rem    .rtmp   ?+1
	.tmp    .tmp    ?+1
	.tmp    .num    .looprem
.retquot:
	#Because we terminate 1 iteration late, return [qtmp] and [rtmp] instead of
	#[quot] and [rem].
	#If the signs of [num] and [den] mismatch, negate [qtmp].
	.tmp    .tmp    ?+1
	.qsign  .z      ?+7
	.qsign  .qsign  ?+1
	.tmp    .quot   ?+1
	#Set [quot]
	.r0     .r0     ?+1
	.r0     .qret   ?+1
	.r1     .r1     ?+1
	.r1     .qret   ?+1
	.tmp    .r0:0   ?+1
	.qtmp   .tmp    ?+1
	.r1:0   .qtmp   ?+1
.retrem:
	#If [num]<0, negate [rem].
	.rsign  .z      ?+7
	.rsign  .rsign  ?+1
	.num    .rem    ?+1
	#Set [rem]
	.num    .r2:0   ?+1
	.rtmp   .num    ?+1
	.r3:0   .rtmp   ?+1
	0       0       .arg6:6
.divz:
	#Abort
	0-1     0       ?-2
	#Variables
	0-2 0-1 .z:0 1
	.tmp:0
	.num:0
	.den:0
	.nden:0
	.qret:0
	.quot:0
	.qtmp:0
	.qsign:0
	.rem:0
	.rtmp:0
	.rsign:0


#--------------------------------------------------------------------------------
#Bitwise Arithmetic


int.shr:
	#Call  : 0 ? int.shr ret num shift
	#
	#Effect: [ret] = [num] >> [shift]. Sign extend if [num]<0.
	#
	#Time  : 43 + 8*bits = 555
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#On first run, calculate how many bits we are using.
	.tmp    .tmp    .firsts:?+1
	.firsts .firstv ?+1
	.num    .z-1    ?+1
.firstloop:
	.num    .z      .firstdone
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.nbits  .z+1    ?+1
	.tmp    .tmp    .firstloop
.firstdone:
	#Get ret
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	.rval   .rval   ?+1
	#Get [shift]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.tmp    .tmp    ?+1
	#Get [num]
	.tmp    .arg3:3 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1
	.num    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .z+1    ?+1
	#If [num]<0, set [tmp]=~[num].
	.num    .tmp    .numpos
	.neg    .num    ?+1
	.tmp    .neg    ?+1
.numpos:
	#If [shift]>=[bits], abort.
	.shift  .nbits  ?+1
	.shift  .p1:0   .ret
	.num    .num    ?+1
	.num    .tmp    ?+1
	.num    .z+1    ?+1
.loop:
	#[num]<<=1. Carry into [rval].
	.num    .tmp    ?+4
	.rval   .z-1    ?+1
	.tmp    .tmp    ?+1
	.shift  .z+1    .ret+6
	#[rval]<<=1
	.tmp    .rval   ?+1
	.rval   .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .num    .loop
.ret:
	.tmp    .tmp    ?+1
	.shift  .shift  ?+1
	#If [num]<0, set [rval]=~[rval].
	.neg    .z      .notneg
	.neg    .neg    ?+1
	.num    .num    ?+1
	.num    .rval   ?+1
	.tmp    .num    ?+1
	.tmp    .z-1    ?+1
	.rval   .rval   ?+1
.notneg:
	#Set [ret].
	.rval   .ret0:0 ?+1
	.tmp    .rval   ?+1
	.ret1:0 .tmp    ?+1
	0       0       .arg5:5
	#Variables
	.firstv:.firsts+1-.firstdone
	.nbits:0
	.num:0
	.rval:0
	.shift:0
	.tmp:0
	.neg:0
	0-1 .z:0 1 2


#|==============================================================================

Random Number Generator - v1.04

Author: Alec Dee - alecdee.github.io - akdee144@gmail.com

--------------------------------------------------------------------------------
Index

random.seed    [num]
random.jump    [num]
random.get     [dst]
random.mod     [dst] [mod]
random.shuffle [[arr]] [len]

--------------------------------------------------------------------------------
Version History

1.00
     Initial version.
1.01
     Added shuffling.
1.02
     Optimized random.generate by removing offsets during shitfing.
1.03
     Initial seed is generate by system time.
1.04
     Optimized jump, mod, and shuffle and made them bit length agnostic.
     Merged random.generate and random.get.
     Added random.init to initialize random.get and seed using current time.

--------------------------------------------------------------------------------
TODO

Generate hash constants when initializing.
Only use 2 constants for hashing. See if there's an optimal pair.
|#

random.table:
	#For the hash output to be unique, the bottom 8 bits of the table elements
	#need be unique. Add 128 to compensate for shifting in random.generate.
	0x98f570cabbbe2960 0x911fe275124571d3 0xc4b49b92decb87b8 0x2cd974e264a1471e
	0xf25c1cd4ec741993 0x6ac38c14e315ff72 0x532a643077bdeaf3 0xe73da4ddf4ea21ce
	0xf482feb36863db2c 0xb0b08786cdd32bff 0x2912bb15798712d5 0xaa3c40a2341958ba
	0xa56c2aec8d398c9f 0xb571c4090f4e31b5 0xcfbbfe93f0333090 0x4d08908eb0d3773f
	0x902c693a21a631cb 0x9b35783a62da3801 0xeb23e76d74a030bd 0x148e78184600d905
	0x93cdff03f57a90f0 0xdc500bc795c0db4b 0x70da57814f7632c1 0x036633f4013f2582
	0x0c8b76d2def52fc2 0xa45d1da2dba14a25 0x28dbc12379f88e00 0xcf437f8d91ddbc86
	0x0e04a0cdced858ab 0xc7ad971bd5fd8b40 0x29c4517860f09471 0x651bab92d762f10c
	0x9e5f7051205bcc26 0xdcf588711bbcf16c 0xb511a1dded21dd29 0x3679f6456f3452f6
	0xe38dc026335be06b 0xc11d3c759a573da9 0x69410c19157a935a 0xbcc29a4c1b48f135
	0x178c1f951bb7690d 0xd0fc4d498b3e96cf 0xb5b221282132f91f 0x3406dfcb2f0366c6
	0xa18219fffb9a29fc 0xf389feeac4bde69c 0x7b0c200137dd9f57 0x2ecc7eb7f4962591
	0x92ac81ab67b51beb 0x9009eb7acc6a5c7d 0x3182a4ab17f0d814 0xde30902e8d338137
	0x3f3b76e6cccfc642 0xb90d0547d1666133 0x8829b84121f35da7 0xaf509317565b19e7
	0x8fa5742b4f4eeeac 0xbfb86e765ab97f32 0x42b8d16ac3cc3a7f 0x33b8fda60fa07180
	0x68b9f22c1b7ba74d 0x0cee1ee11bc6d449 0x0dce2401a6399421 0x052188c95763afdb
	0x4cd0743f96271244 0x8ab6545393a1ebf9 0x768742f4f5d2cab3 0x2505089bf7de1def
	0xc77ddf5d4bcb4fe8 0x3b861ae62a54910f 0xbba48529fa2859a1 0x9364a79693182e69
	0x29da3184545bf7ed 0xae8efc34c79dd8d0 0xefb805aef57bab34 0xf78943322ead0764
	0x9c357259e48eb6af 0x1dcf0b5f98e2b294 0xa84cb6e4e7897551 0x9054b2308f7ff5a8
	0xdea01eccc8cb3002 0x46be28419fcd8f73 0x5c466247cab9ce7a 0x1034bef3c280cb12
	0x8595486352ef7b07 0xe9c864d995472116 0x9d17d691fa40b9d8 0x1b0a781d7f42e5c0
	0x9260768bc3848498 0x32b48273b8447b6e 0xa630dd7aa9926f68 0x6a5f0a3586db52e5
	0xbeda047a0761a9de 0xeeedd85395df432a 0x9fa214fd946164b7 0xd76c7fadfb1b9f27
	0xe2679809cd7c7195 0x4dbb967cba099877 0x9e611d7eb7c16511 0xde11e3858421c4dd
	0x8f60a79abb8d57a4 0xb69e8632011f0476 0x3a1b15a9d57b3adc 0x6ec8bf7ca6e952f4
	0x18ab73ed10808a85 0xccf19063a89d6ed6 0x9ddaae641e0d371d 0x349a6b56eb499da3
	0xdebee3f7288eabe9 0x6d75b7185e043496 0xbfe68ee59f24e009 0xe2f755c64a184728
	0xe3956041e0330606 0x1684ec84b22cf1a6 0xe547786c47fe87e1 0x7aaf255ec884c10b
	0xb9a7b0be91eca4fa 0x18a85229e8fbe317 0x9b6dad19e7415bc4 0xdab2c6a930db6224
	0xd745efee27085597 0x76f406eb0c7428d4 0x3f779c073097aad9 0xbd0f440b38d1bb66
	0x6ebf3706f695fc55 0x5fbeb72a136c5f89 0xd1c85045aafa5699 0x9b0cf77eb69cfe5b
	0x96bc972c67aeefe2 0xb878518614240efb 0x915a36484cec1b5d 0xa020e164db74d519
	0x875a2ac9e4b98658 0xe34b6b0a580b7d50 0xcd30c71286948c3b 0xf0e6820ef3e9dedf
	0x5dd7e2048d695b67 0xc631ad2b02402fe4 0xc04e99806aa6b8b0 0x5c3304efe897203a
	0x8470f7bb68304a7e 0x4667d0d2c455a98f 0x627165e1b5e16941 0xcd115b2a371d7253
	0x9d6959acac5178f2 0x2722e04d0a4a143e 0x9da126422bd82cb6 0xef7d31df6da70b9b
	0x8419df95b52ed518 0x8744bd266232eec9 0xfec4fb7d4a39b7b4 0x653e09ad754e9663
	0x2608342e20aa3b1b 0xcaacecdf21d87d83 0x60760dd379bb46ea 0xb3f7371bd3167bee
	0x83456546a5d4b0c8 0x3b873a2c613d06d2 0x12c3d73474334dec 0xbec28771231d6d4f
	0x1e0915b280ca6d78 0x12f9adbc60d758f8 0x9fb08c027989eee0 0xbe06995c7b3a3a8d
	0xa018541f0b2d74fe 0xcb0dd0f03d00ed20 0xcea6dda8960694ae 0x903aaea97447f361
	0xa790fbe394d3a1f1 0x40efcea66b9f4687 0xce2e0082770418c3 0x648d7efc4101d2c7
	0x77554a83e487e00e 0x88a954411c963eca 0x5e50a70702f25e70 0x0f71bbe7c9f8888e
	0xe10b0dd69b525b39 0xb6e0722926754946 0xf170a88f296f535f 0x3c04bceebe44795e
	0x68bba5422fffc54a 0x3532437701d42d5c 0x0f193926db9f9f03 0xe3e8936f5cc07b75
	0xeb05b184ecbc0781 0xcfb13169fb869a04 0x42a0202293da976a 0xf2b6c837dd71ec52
	0x384cbe585d4a284c 0xaa3111a39a9aeffd 0x6c8ab832cf881743 0x0483dd6ad0cc54da
	0x720a2dd6094fc823 0x03107a9e669770bc 0x1668b4ba38718ed7 0x771106507afb5788
	0x5054ac481b535308 0x7e485aae5cf0843c 0x881766ced977c01c 0x2eb2c7255ded91e6
	0xeeb1ca030d19f04e 0x68138ac1b21f7030 0xe5de8ba1badd73c5 0x03a8f78e3114d636
	0xde62bdde8d42596d 0xcb15fc108b83a222 0x47e32cf9f7cb1038 0xdd46c0bcb1b2ed8b
	0x24966b07ce5abb74 0x107257fa9545c5d1 0xbb6bed3a3715a192 0xca941e35cb1a8ab9
	0x3ea5389dbca69e2d 0x0b84722da650e37c 0x0ddd81bdedcd05ad 0xa55ee070874ab6be
	0x4856d854cdc81015 0xaf3482758939f02f 0x80547b7b42c6082b 0x32a83053658a73aa
	0xb4e0f4a4bd383c9e 0x86c52d7ce1b79e0a 0x1567a7aa94e4fcb1 0x71fc8c1a6dfa442e
	0x381ae7272b68bb48 0x85632a5c9280d6f7 0x141c9e3bdecc42f5 0xae184e25976dae1a
	0x6fd0f1321084317b 0xb95e50ee69ed5f9d 0x786f68e44c0f0ea2 0x88ac24917ce632bb
	0x88fca453535915bf 0x6c6e38b0bf5b979a 0x4b42cfc646897ccd 0x2a18e1dbbded9bb2
	0x8c75ad2c94462045 0xde14e4d24fc9bb62 0x88d304a2898a4584 0xf7e1e0b52d45f0cc
	0x9d8a8dd7d1bafba0 0x5ba48bfee8d17479 0x5d2d0cfc9a48fa56 0x85e41916f3616c6f
	0xedfc0c68c0217147 0x067e32a00b210665 0x04440fe6a9b7ad3d 0xe0942f02c01f838c
	0x86c8c765b04b7031 0x03edd68c2c9f6259 0xa82b24db8deaf410 0x66337c5333e8c4a5
	0x305d36e368598b13 0xbdd8330fbb889ee3 0xc146c702c618a08a 0x377d5bd4c5c6b854


random.init:
	#Get the calling address and original stack pointner.
	.orig   .0      ?+1
	.0      .0      ?+1
	.0      0       ?+1
	0       0       ?+1
	#Make sure we only initialize once.
	random.seed+2 .z-3 ?+1
	random.jump+2 .z-3 ?+1
	random.get +2 .z-3 ?+1
	#Count how many times we need to iterate in random.get.
.loop:
	.z-1    .z      .done
	random.get.i0 .z+1 ?+1
	#[z-1]<<8
	.z      .z-1    ?+1
	.z-1    .z      ?+1
	.z      .z-1    ?+1
	.z-1    .z      ?+1
	.z      .z-1    ?+1
	.z      .z-1    ?+1
	.z-1    .z      ?+1
	.z-1    .z      ?+1
	.z      .z-1    ?+1
	.z      .z-1    ?+1
	.z-1    .z      ?+1
	.z-1    .z      ?+1
	.z-1    .z      ?+1
	.z      .z      .loop
.done:
	.z-1    .z+1    ?+1
	#Randomly seed the generator.
	0 ? random.seed 0-4
	#Return to the calling function.
	0       .0      .orig:0-4
	#Variables
	.0:0
	0-3 0-2 0-1 .z:0 1


random.seed:
	#Call  : 0 ? random.seed num
	#Effect: Sets the PRNG state based on the value of [num].
	#Setup the stack.
	.tmp    .tmp    ?+1
	random.init.0 ? random.init
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	0       0       ?+1
	#Get [num].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.num    .p0:0   ?+1
	#Reset the generator state.
	random.get.state random.get.state ?+1
	random.get.inc   random.get.inc   ?+1
	#Set [inc] make sure it's odd.
	random.get.state .num ?+1
	0 ? random.get .tmp
	random.get.inc .tmp ?+1
	random.get.inc .tmp ?+1
	random.get.inc .z-1 ?+1
	#Set [state].
	random.get.state .tmp ?+1
	0 ? random.get random.get.state
	.num    .num    .arg3:3
	#Variables
	0-2 0-1 .z:0
	.tmp:0
	.num:0


random.jump:
	#Call  : 0 ? random.jump num
	#Effect: Jumps the PRNG state forward or backwards [num] number of steps.
	#Time  : 21 + 7*bits = 469
	#Setup the stack.
	.tmp    .tmp    ?+1
	random.init.0 ? random.init
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	#Get [num].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.num    .num    ?+1
	.num    .p0:0   ?+1
	.tmp    .tmp    ?+1
	.tmp    .num    ?+1
	#Offset [tmp] by 1 to force [num] to be odd.
	.tmp    .z+1    ?+1
	.mul    .mul    ?+1
	#Calculate [inc]*[num].
.loop:
	#If the highest bit of [b] is set, add [a] to [lval].
	.num    .tmp    ?+7
	.mul    random.get.inc ?+1
	.tmp    .tmp    ?+7
	#If [b]=0, we are done.
	.num    .z      .done
	.tmp    .tmp    ?+1
	#Left shift [mul].
	.mtmp   .mtmp   ?+1
	.mtmp   .mul    ?+1
	.mul    .mtmp   ?+1
	.tmp    .num    .loop
.done:
	#[state]+=[inc]*[num]
	random.get.state .mtmp ?+1
	#Return
	0       0       .arg3:3
	#Variables
	.tmp:0
	.mtmp:0
	.num:0
	.mul:0
	0-2 0-1 .z:0 1


random.get:
	#Call  : 0 ? random.get dst
	#Effect: [dst] = a random 64 bit integer
	#Time  : 20 + 36*((bits+7)/8) = 308
	#Setup the stack.
	.tmp    .tmp    ?+1
	random.init.0 ? random.init
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	#Get dst.
	.dst0   .arg2:2 ?+1
	.dst1   .dst0   ?+1
	.dst2   .dst0   ?+1
	.tmp    .tmp    ?+1
	.tmp    .dst1   ?+1
	.dst0   .dst0   ?+1
	.dst0   .tmp    ?+1
.reenter:
	#Advance state.
	.state  .inc    ?+1
	.rnd    .rnd    ?+1
	.rnd    .state  ?+1
	.i      .i0     ?+4
.loop:
	.i      .z+1    .done
	#Set [rnd]=[rnd]*256+128 and [t0]=[table+([rnd]>>56)]. Offset [rnd] by 1 so
	#we can detect if a carry occurs.
	.tmp .tmp ?+1 .tmp .rnd ?+1 .tmp .z+1 ?+1 .rnd .tmp ?+4
	.tbl .l+0 ?+4 .tbl .l+8 ?+1
	.tmp .tmp ?+1 .tmp .rnd ?+1 .rnd .tmp ?+4 .tbl .l+1 ?+1
	.tmp .tmp ?+1 .tmp .rnd ?+1 .rnd .tmp ?+4 .tbl .l+2 ?+1
	.tmp .tmp ?+1 .tmp .rnd ?+1 .rnd .tmp ?+4 .tbl .l+3 ?+1
	.tmp .tmp ?+1 .tmp .rnd ?+1 .rnd .tmp ?+4 .tbl .l+4 ?+1
	.tmp .tmp ?+1 .tmp .rnd ?+1 .rnd .tmp ?+4 .tbl .l+5 ?+1
	.tmp .tmp ?+1 .tmp .rnd ?+1 .rnd .tmp ?+4 .tbl .l+6 ?+1
	.tmp .tmp ?+1 .tmp .rnd ?+1 .rnd .tmp ?+4 .tbl .l+7 ?+1
	#[rnd]-=table+128
	.rnd    .tbl:0  ?+1
	.tbl    .tbl    .loop
.done:
	#Set [dst] and return.
	.dst0:0 .dst1:0 ?+1
	.dst2:0 .rnd    ?+1
	0       0       .arg3:3
	#Variables
	.z:0 1 2
	.l:0-128-random.table 0-64 0-32 0-16 0-8 0-4 0-2 0-1 0-random.table
	.rnd:0
	.tmp:0
	.i:0
	.i0:0
	.state:0
	.inc:1


random.mod:
	#Call  : 0 ? random.get dst mod
	#Effect: [dst] = a random number in [0,[mod]).
	#Setup the stack.
	.tmp0   .tmp0   ?+1
	.tmp0   .arg2   ?+1
	0       .tmp0   ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	0       0       ?+1
	#Get dst.
	.tmp0   .tmp0   ?+1
	.tmp0   .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .tmp0   ?+1
	.p1     .p1     ?+1
	.p1     .tmp0   ?+1
	#Get [mod].
	.tmp0   .tmp0   ?+1
	.tmp0   .arg3:3 ?+1
	.p2     .p2     ?+1
	.p2     .tmp0   ?+1
	.nmod   .nmod   ?+1
	.nmod   .p2:0   ?+1
	.nmod   .z      .div0
	.nmod   .z-1    ?+1
	.mod    .mod    ?+1
	.mod    .nmod   ?+1
	#Get our first random number and set up successive random.get calls.
	.tmp1   .tmp1   ?+1
	0 ?+2 random.get .randloop+1
.randloop:
	#Skip setting up random.get on successive calls.
	.tmp1   .tmp1   random.get.reenter .rand
	.tmp1   .rand   ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .tmp1   ?+1
	.tmp1   .z+1    ?+1
	.rem    .rem    .modloop+6
	#Caculate [rem]=[rand]%[mod].
.modloop:
	#[rem]+=[num]>>63, [num]<<=1. If [num]=0, abort.
	.rtmp   .rtmp   ?+1
	.tmp1   .tmp0   ?+1
	.tmp0   .tmp1   ?+4
	.rtmp   .z+1    ?+4
	.tmp0   .z      .moddone
	.rtmp   .rem    ?+1
	.rem    .rtmp   ?+1
	#If [rem]>=[mod], [rem]-=[mod]
	.rem    .mod    ?+7
	.rem    .z+1    ?+1
	.tmp1   .tmp1   .modloop
	.rem    .nmod   ?+1
	#[rem]<<=1
	.tmp1   .tmp1   .modloop
.moddone:
	#Rejection sampling. Accept if rand-rem<=-mod.
	.nmod   .z+1    ?+1
	.rand   .rem    ?+1
	.rand   .nmod   .modaccept
	.nmod   .z-1    .randloop
.modaccept:
	.rem    .p0:0   ?+1
	.tmp0   .rem    ?+1
	.p1:0   .tmp0   ?+1
	0       0       .arg4:4
.div0:
	0-1     0       ?-2
	#Variables
	.nmod:0
	.mod:0
	.rand:0
	.rem:0
	.rtmp:0
	.tmp0:0
	.tmp1:0
	0-1 .z:0 1 2


random.shuffle:
	#Call  : 0 ? random.shuffle arr len
	#Effect: Randomly shuffles [[arr]] from [0,[len]).
	#Setup the stack.
	.tmp0   .tmp0   ?+1
	.tmp0   .arg2   ?+1
	0       .tmp0   ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	0       0       ?+1
	#Get [len].
	.tmp0   .tmp0   ?+1
	.tmp0   .arg3:3 ?+1
	.p1     .p1     ?+1
	.p1     .tmp0   ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .p1:0   ?+1
	.len    .len    ?+1
	.len    .tmp0   ?+1
	#Return if [len]<=1.
	.len    .z+1    .done
	#Get -[arr].
	.tmp0   .tmp0   ?+1
	.tmp0   .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .tmp0   ?+1
	.narr   .narr   ?+1
	.narr   .p0:0   ?+1
	#Set array pointers.
	.i0     .i0     ?+1
	.i0     .narr   ?+1
	.i1     .i1     ?+1
	.i1     .narr   ?+1
	.nmod   .nmod   ?+1
	.nmod   .z+1    ?+1
	.mod    .mod    ?+1
	.mod    .nmod   ?+1
	#Get our first random number and set up successive random.get calls.
	.tmp1   .tmp1   ?+1
	0 ?+2 random.get .randloop+1
.shuffleloop:
	.len    .z+1    .done
	#Get a random number in [0,i+1).
.randloop:
	#Skip setting up random.get on successive calls.
	.tmp1   .tmp1   random.get.reenter .rand
	.tmp1   .rand   ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .tmp1   ?+1
	.tmp1   .z+1    ?+1
	.rem    .rem    .modloop+6
	#Caculate [rem]=[rand]%[mod].
.modloop:
	#[rem]+=[num]>>63, [num]<<=1. If [num]=0, abort.
	.rtmp   .rtmp   ?+1
	.tmp1   .tmp0   ?+1
	.tmp0   .tmp1   ?+4
	.rtmp   .z+1    ?+4
	.tmp0   .z      .moddone
	.rtmp   .rem    ?+1
	.rem    .rtmp   ?+1
	#If [rem]>=[mod], [rem]-=[mod]
	.rem    .mod    ?+7
	.rem    .z+1    ?+1
	.tmp1   .tmp1   .modloop
	.rem    .nmod   ?+1
	#[rem]<<=1
	.tmp1   .tmp1   .modloop
.moddone:
	#Rejection sampling. Accept if rand-rem<=-mod.
	.nmod   .z+1    ?+1
	.rand   .rem    ?+1
	.rand   .nmod   .modaccept
	.nmod   .z-1    .randloop
.modaccept:
	#Increment i.
	.i0     .z-1    ?+1
	.i1     .z-1    ?+1
	#Set j=arr+[rand]%(i+1).
	.rem    .j0     ?+1
	.rem    .narr   ?+1
	.tmp0   .rem    ?+1
	.j0     .tmp0   ?+1
	.j1     .tmp0   ?+1
	#Swap [i] and [j].
	.tmp0   .tmp0   ?+1
	.tmp0   .i0:0   ?+1
	.tmp1   .tmp1   ?+1
	.tmp1   .j0:0   ?+1
	#[tmp1]=[i]-[j]
	.tmp1   .tmp0   ?+1
	.i1:0   .tmp1   ?+1
	#[tmp0]=[j]-[i]
	.tmp0   .tmp0   ?+1
	.tmp0   .tmp1   ?+1
	.j1:0   .tmp0   ?+1
	#Next loop.
	.mod    .z-1    .shuffleloop
.done:
	0       0       .arg4:4
	#Variables
	.tmp0:0
	.tmp1:0
	.narr:0
	.rem:0
	.rtmp:0
	.nmod:0
	.mod:0
	.len:0
	.rand:0
	0-1 .z:0 1 2


#|==============================================================================

Memory - v1.01

Author: Alec Dee - alecdee.github.io - akdee144@gmail.com

--------------------------------------------------------------------------------
About

This library handles common memory management functions. If it is concatenated
with other files, it must be included last for memory allocation to work.

--------------------------------------------------------------------------------
Index

Dereferencing
mem.getargs dst0 refs0 dst1 refs1 ... 0
mem.get    val mem
mem.getidx val mem idx
mem.set    mem val
mem.setidx mem idx val

Bulk Operations
mem.zero dst len
mem.copy dst src len

Allocation
mem.alloc   mem len
mem.realloc ret mem len
mem.free    mem
mem.alloc.verifyfree

--------------------------------------------------------------------------------
Version History

1.00
     Initial version.
     Supports referencing, zeroing, copying, and allocation.
1.01
     Fixed comments.
     Renamed get/set functions.

--------------------------------------------------------------------------------
TODO

Replace alloc hash table with AVL tree.
Simplify mem.alloc.verify using mem.get and mem.cmp.
mem.sort
	Have comparison function. use jumps.
mem.binsearch mem len val cmp
	use +-2^n instead of division by 2
Optimize mem.realloc. Don't use mem.zero, just mem.copy.
|#

mem.debug: 1


#--------------------------------------------------------------------------------
#Dereferencing


mem.getargs:
	#Call  : mem.getargs.0 ? mem.getargs dst0 refs0 dst1 refs1 ... 0
	#Effect:
	#     Simplifies parsing arguments from the 0 stack.
	#     For example, when calling "0 ? SomeFunc arg1 arg2".
	#     Stops parsing arguments when dst=0.
	#     Sets [0]=0.
	#
	#     refs=0: [dst]=[0]
	#     refs=1: [dst]=[[0]]
	#     refs=2: [dst]=[[[0]]]
	#
	#Time  : 12+(18+6*refs)*args
	0       .z+2    ?+1
	.0      .z+2    ?+1
	.arg2   .arg2   ?+1
	.arg2   .0      ?+1
	.0      .z+1    ?+1
	.arg3   .arg3   ?+1
	.arg3   .0      ?+1
.argloop:
	.0      .0      ?+1
	.tmp    .arg2:0 ?+1
	#If dst=0, we're done.
	.tmp    .z      .done
	.arg2   .z-2    ?+1
	#Setup the destination address.
	.dst0   .dst0   ?+1
	.dst0   .tmp    ?+1
	.dst1   .dst1   ?+1
	.dst1   .tmp    .done+4
.done:
	0       0       ?+1
	.ref
	#Get the dereferencing depth.
	.ref    .arg3:0 ?+1
	.arg3   .z-2    ?+1
	#Get argument from original stack and dereference.
	.val    .val    ?+1
	.val    0       ?+1
	0       .z+1    ?+1
.refloop:
	.ref    .z      .ref0
	.tmp    .tmp    ?+1
	.tmp    .val:0  ?+1
	.val    .val    ?+1
	.val    .tmp    ?+1
	.ref    .z-1    .refloop
.ref0:
	#Write dereferenced argument to the destination address.
	.val    .dst0:0 ?+1
	.z      .val    ?+1
	.dst1:0 .z      ?+1
	.tmp    .tmp    .argloop
	#Variables
	0-2 0-1 .0:.z:0 1 2
	.ref:0
	.tmp:0


mem.get:
	#Call  : 0 ? mem.get0 val mem
	#Effect: [val]=[[mem]]
	#Time  : 27
	#Setup the stack.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	#Get val.
	.val0   .arg2:2 ?+1
	.val1   .val0   ?+1
	.val2   .val0   ?+1
	.tmp    .tmp    ?+1
	.tmp    .val1   ?+1
	.val0   .val0   ?+1
	.val0   .tmp    ?+1
	#Get -[mem].
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.m0     .m0     ?+1
	.m0     .tmp    ?+1
	#Set [val]=[[mem]]
	.tmp    .tmp    ?+1
	.tmp    .m0:0   ?+1
	.m1     .m1     ?+1
	.m1     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .m1:0   ?+1
	.val0:0 .val1:0 ?+1
	.val2:0 .tmp    ?+1
	0       0       .arg4:4
	#Variables
	.off:2
	.tmp:0


mem.getidx:
	#Call  : 0 ? mem.getidx val mem idx
	#Effect: [val]=[[mem]+[idx]]
	#Time  : 33
	#Setup the stack.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get val.
	.val0   .arg2:2 ?+1
	.val1   .val0   ?+1
	.val2   .val0   ?+1
	.tmp    .tmp    ?+1
	.tmp    .val1   ?+1
	.val0   .val0   ?+1
	.val0   .tmp    ?+1
	#Get -[mem].
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.m0     .m0     ?+1
	.m0     .tmp    ?+1
	#Get -[idx].
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.i0     .i0     ?+1
	.i0     .tmp    ?+1
	#Set [val]=[[mem]+[idx]]
	.tmp    .tmp    ?+1
	.tmp    .m0:0   ?+1
	.tmp    .i0:0   ?+1
	.mi     .mi     ?+1
	.mi     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .mi:0   ?+1
	.val0:0 .val1:0 ?+1
	.val2:0 .tmp    ?+1
	0       0       .arg5:5
	#Variables
	.off:2
	.tmp:0


mem.set:
	#Call  : 0 ? mem.set mem val
	#Effect: [[mem]]=[val]
	#Time  : 27
	#Setup the stack.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	#Get -[mem].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.m0     .m0     ?+1
	.m0     .tmp    ?+1
	.m1     .m0:0   ?+1
	#Get val.
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.val0   .val0   ?+1
	.val0   .tmp    ?+1
	#Set [[mem]]=[val]
	.m2     .m1     ?+1
	.m3     .m1     ?+1
	.tmp    .tmp    ?+1
	.tmp    .m2     ?+1
	.m1     .m1     ?+1
	.m1     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .val0:0 ?+1
	.m1:0   .m2:0   ?+1
	.m3:0   .tmp    ?+1
	0       0       .arg4:4
	#Variables
	.off:2
	.tmp:0


mem.setidx:
	#Call  : 0 ? mem.setidx mem idx val
	#Effect: [[mem]+[idx]]=[val]
	#Time  : 33
	#Setup the stack.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get -[mem].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.m0     .m0     ?+1
	.m0     .tmp    ?+1
	.mi0    .m0:0   ?+1
	#Get -[idx].
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.i0     .i0     ?+1
	.i0     .tmp    ?+1
	.mi0    .i0:0   ?+1
	#Get val.
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.val0   .val0   ?+1
	.val0   .tmp    ?+1
	#Set [[mem]+[idx]]=[val]
	.mi1    .mi0    ?+1
	.mi2    .mi0    ?+1
	.tmp    .tmp    ?+1
	.tmp    .mi1    ?+1
	.mi0    .mi0    ?+1
	.mi0    .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .val0:0 ?+1
	.mi0:0  .mi1:0  ?+1
	.mi2:0  .tmp    ?+1
	0       0       .arg5:5
	#Variables
	.off:2
	.tmp:0


#--------------------------------------------------------------------------------
#Bulk Operations


mem.zero:
	#Call  : 0 ? mem.zero mem len
	#Effect: Zeroes out memory addresses in [[mem],[mem]+[len]).
	#Time  : 24+4*len
	#Setup the stack.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	#Get [len]. Return if [len]=0.
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.len0   .len0   ?+1
	.len0   .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .len0:0 ?+1
	.tmp    .z      .done
	.len    .tmp    ?+1
	#Get [mem].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.mem0   .mem0   ?+1
	.mem0   .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .mem0:0 ?+1
	#Setup the initial memory pointers.
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	#Zero loop.
.loop:
	.p0:0   .p1:0   ?+1
	.len    .z+1    .done
	.p0     .z-1    ?+1
	.p1     .z-1    .loop
.done:
	0       0       .arg4:4
	#Variables
	0-1 .len:.z:0 1 2
	.tmp:0


mem.copy:
	#Call  : 0 ? mem.copy dst src len
	#Effect: Copies data from [[src],[src]+[len]) onto [[dst],[dst]+[len]).
	#Time  : 39+9*len
	#Setup the stack.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get [len]. Return if [len]=0.
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.len0   .len0   ?+1
	.len0   .tmp    ?+1
	.nlen   .nlen   ?+1
	.nlen   .len0:0 ?+1
	.nlen   .z      .done
	#Get [src].
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.s0     .s0     ?+1
	.s0     .tmp    ?+1
	#Get [dst].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.d0     .d0     ?+1
	.d0     .tmp    ?+1
	.ndst   .ndst   ?+1
	.ndst   .d0:0   ?+1
	.tmp    .tmp    ?+1
	.tmp    .ndst   ?+1
	#Determine our copy direction.
	.inc    .inc    ?+1
	.tmp    .s0:0   .le
	#Copy back to front.
	.len    .nlen   ?+1
	.ndst   .len    ?+1
	.ndst   .z-1    ?+1
	.inc    .z-1    .setup
.le:
	#Copy front to back. If [dst]=[src], return.
	.tmp    .z      .done
	.len    .nlen   ?+1
	.inc    .z+1    .setup
.setup:
	#Setup the data pointers.
	.src    .src    ?+1
	.src    .tmp    ?+1
	.src    .ndst   ?+1
	.tmp    .tmp    ?+1
	.tmp    .dst0   ?+1
	.ndst   .tmp    ?+1
	.dst0   .ndst   ?+1
	.dst1   .ndst   ?+1
	.dst2   .ndst   ?+1
	.tmp    .tmp    ?+1
	#Copy the data.
.loop:
	.tmp    .src:0  ?+1
	.dst0:0 .dst1:0 ?+1
	.dst2:0 .tmp    ?+1
	.len    .z+1    .done
	.dst0   .inc    ?+1
	.dst1   .inc    ?+1
	.dst2   .inc    ?+1
	.src    .inc    ?+1
	.tmp    .tmp    .loop
.done:
	0       0       .arg5:5
	#Variables
	0-1 .z:0 1 2
	.tmp:0
	.ndst:0
	.inc:0
	.len:0
	.nlen:0


#|-------------------------------------------------------------------------------
Allocation

The memory module must be included at the end of the program so that
mem.alloc.start can mark the beginning of unused space.


     +------------------+---------+---------+---------+---------+---------+
     | mem.alloc.start: | Buckets | Block 0 | Block 1 | Block 2 |   ...   |
     +------------------+---------+---------+---------+---------+---------+


The layout after mem.alloc.start is:


      0: [2^1, 2^2)
      1: [2^2, 2^3)
      2: [2^3, 2^4)
     ....
     62: [2^63, 2^64)
     63: Pointer to start+64
     64: Catch-all block
     65: First actual block


A free block with space for data will have links for the bucket it's in.


     +--------------------------------------------------------------------+
     |                             Free Block                             |
     +-----------+-----------+------------+------------+------------------+
     | blocknext | blockprev | bucketprev | bucketnext | unused cells ... |
     +-----------+-----------+------------+------------+------------------+


When a block becomes allocated, blockprev and blocknext will be swapped. The
rest of the cells will be used for data.


     +--------------------------------------------------------------------+
     |                          Allocated Block                           |
     +-----------+-----------+------------+------------+------------------+
     | blockprev | blocknext |   data 0   |   data 1   |       ...        |
     +-----------+-----------+------------+------------+------------------+


If blockprev<blocknext, then the block is allocated. The last block will have
blocknext=mem.alloc.end.
|#


mem.error:
	#Call  : mem.error.z ? mem.error str
	#Effect: Prints str and aborts.
	#Get str.
	.msg    .z      ?+1
.loop:
	.z      .z      ?+1
	.z      .msg:2  ?+1
	.char   .char   ?+1
	.z      .char   .done
	.char   .z      ?+1
	0-2     .char   ?+1
	.msg    .z-1    .loop
.done:
	#Variables/Abort
	0-1 .z:0 .char:0


mem.alloc.init:
	#Call  : mem.alloc.init.z ? mem.alloc.init
	#Effect: An internal function that initializes the memory allocator for use. Only
	#runs once.
	#Setup return and original 0.
	.ret    .z      ?+1
	.z      .z      ?+1
	.tmp0   0       ?+1
	0       0       ?+1
	#Modify allocation functions so mem.alloc.init only runs once.
	mem.alloc+2        .z-3 ?+1
	mem.free+2         .z-3 ?+1
	mem.realloc+2      .z-3 ?+1
	mem.alloc.verify+2 .z-3 ?+1
	#If we're debugging, make sure the first 2048 cells after the starting address
	#are 0.
	mem.debug .z    .dbgzdone
.dbgzloop:
	.zcheck .z+1    .dbgzdone
	.p0:mem.alloc.start .z .dbgzgood
	#ERROR: Alloc memory not 0
	mem.error.z ? mem.error 69 82 82 79 82 58 32 65 108 108 111 99 32 109 101 109 111 114 121 32 110 111 116 32 48 10 0
.dbgzgood:
	.p0     .z-1    .dbgzloop
.dbgzdone:
	#len=end-start-65-2. Need len>=2, hence end-(start+69)>=0.
	.minend mem.alloc.end .hasmem
	#ERROR: Not enough memory
	mem.error.z ? mem.error 69 82 82 79 82 58 32 78 111 116 32 101 110 111 117 103 104 32 109 101 109 111 114 121 10 0
.hasmem:
	#Setup the catch-all block.
	mem.alloc.start+63 .s63 ?+1
	mem.alloc.start+64 .s64 ?+1
	#Setup a free block spanning all available memory.
	#Block next
	.z mem.alloc.end ?+1
	mem.alloc.start+65 .z ?+1
	.z      .z      ?+1
	#Block prev, leave 0.
	#Bucket pointer.
	#len=-minend+2
	.z      .minend ?+1
	.z      .z-2    ?+1
	0 ? mem.alloc.getbucket .bkt0 .z
	.z      .z      ?+1
	.bkt0:0 .bkt65  ?+1
	#Bucket prev.
	.z      .bkt0   ?+1
	.z      .z-3    ?+1
	mem.alloc.start+67 .z ?+1
	#Bucket next, leave 0.
	0       .tmp0   .ret:2
	#Variables.
	0-3 0-2 0-1 .z:0 1
	.tmp0:0
	.zcheck:2049
	.s63:0-mem.alloc.start-64
	.s64:0-1+mem.alloc.start+64+2
	.bkt65:0-mem.alloc.start-65
	.minend:mem.alloc.start+69


mem.alloc.getbucket:
	#Call  : 0 ? mem.alloc.getbucket ret len
	#Effect: [ret]=log2([len])+mem.alloc.start-1
	#This is used to figure out what bucket a given length falls in.
	#Time  : 76
	#Expect len>=2.
	#Setup the stack.
	.tmp0   .tmp0   ?+1
	.tmp0   .arg2   ?+1
	0       .tmp0   ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	#Get ret.
	.tmp0   .tmp0   ?+1
	.tmp0   .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp0   ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp0   ?+1
	#Get [len].
	.tmp0   .tmp0   ?+1
	.tmp0   .arg3:3 ?+1
	.l0     .l0     ?+1
	.l0     .tmp0   ?+1
	.nlen   .nlen   ?+1
	.nlen   .l0:0   ?+1
	#Setup the loop counter and tree pointer.
	.i      .i0     ?+1
	.t0     .t0     ?+1
	.t0     .off+0  ?+4
.loop:
	#If len<=mem[tree+i], branch left (i*2+1).
	#Otherwise, branch right (i*2+2).
	.i      .z+1    .done
	.tmp0   .tmp0   ?+1
	.tmp0   .nlen   ?+1
	.tmp0   .t0:0   ?+4
	.tmp1   .off+2  ?+4  #len>tree[i]
	.tmp1   .off+1  ?+1  #len<=tree[i]
	.tmp1   .t0     ?+1
	.t0     .tmp1   ?+1
	.tmp1   .tmp1   .loop
.done:
	.t0     .last   ?+1
	.t0     .ret0:0 ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .t0     ?+1
	.ret1:0 .tmp0   ?+1
	0       0       .arg4:4
	#Variables
	0-1 .z:0 1 2
	.tmp0:0
	.tmp1:0
	.nlen:0
	.i:0
	.i0:0-6
	.off:0-.tree 1-.tree 2-.tree
	.tree:
		0xffffffff 0xffff 0xffffffffffff 0xff 0xffffff 0xffffffffff 0xffffffffffffff 
		0xf 0xfff 0xfffff 0xfffffff 0xfffffffff 0xfffffffffff 0xfffffffffffff 
		0xfffffffffffffff 0x3 0x3f 0x3ff 0x3fff 0x3ffff 0x3fffff 0x3ffffff 0x3fffffff 
		0x3ffffffff 0x3fffffffff 0x3ffffffffff 0x3fffffffffff 0x3ffffffffffff 
		0x3fffffffffffff 0x3ffffffffffffff 0x3fffffffffffffff 0x1 0x7 0x1f 0x7f 0x1ff 
		0x7ff 0x1fff 0x7fff 0x1ffff 0x7ffff 0x1fffff 0x7fffff 0x1ffffff 0x7ffffff 
		0x1fffffff 0x7fffffff 0x1ffffffff 0x7ffffffff 0x1fffffffff 0x7fffffffff 
		0x1ffffffffff 0x7ffffffffff 0x1fffffffffff 0x7fffffffffff 0x1ffffffffffff 
		0x7ffffffffffff 0x1fffffffffffff 0x7fffffffffffff 0x1ffffffffffffff 
		0x7ffffffffffffff 0x1fffffffffffffff 0x7fffffffffffffff
	.last:.last-mem.alloc.start+1


mem.alloc.verifyfree:
	#Call  : 0 ? mem.alloc.verify
	#Effect: Verifies that all blocks are free.
	mem.alloc.verify.valc mem.alloc.verify.z-1 ?+1
mem.alloc.verify:
	#Call  : 0 ? mem.alloc.verify
	#Effect: Verifies all blocks.
	#Setup return.
	.arg2 .arg2 ?+1
	mem.alloc.init.z ? mem.alloc.init
	0     .z+2  ?+1
	.arg2 0     ?+1
	0     0     ?+1
	#Verify buckets. Want to show bucket head->bktprev+3=bkt.
	.bkt0   .sbkt   ?+4
.bktloop:
	#Get the head of the current bucket.
	.bkt0   .nbkt   ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .bkt0:1 ?+1
	.tmp0   .z      .nullblock
	.tmp0   .z+2    ?+1
	.blk0   .blk0   ?+1
	.blk0   .tmp0   ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .blk0:0 ?+1
	#Want mem[blk+2]-bkt+3=0.
	.tmp1   .tmp1   ?+1
	.tmp1   .bkt0   ?+1
	.tmp0   .tmp1   ?+1
	.tmp0   .z+3    ?+1
	.tmp0   .z      .nullblock
	.z      .z      .errormeta
.nullblock:
	.bkt0   .lbkt   .bktloop
	#Verify catch-all.
	#Verify catch-all bucket. Want mem[start+63]=start+64.
	.tmp0   .tmp0   ?+1
	.tmp0   .catch0 ?+1
	.tmp0   mem.alloc.start+63 ?+1
	.tmp0   .z      ?+4
	.z      .z      .errormeta
	#verify catch-all size. Want mem[start+64]=-1+(start+64+2).
	.tmp0   .tmp0   ?+1
	.tmp0   .catch1 ?+1
	.tmp0   mem.alloc.start+64 ?+1
	.tmp0   .z      ?+4
	.z      .z      .errormeta
	#Go through each block and verify it.
	.blk1   .blk1   ?+1
	.blk1   .sblk   ?+1
	.lblk   .lblk   ?+1
	.lblk   mem.alloc.end ?+1
	.alloc  .alloc  ?+1
.blkloop:
	#If mem.alloc.end<=blk, we're done.
	.tmp0   .tmp0   ?+1
	.tmp0   .lblk   ?+1
	.tmp0   .blk1   .blkdone
	0 ? mem.alloc.verifyblock .blk1
	#Get prev=mem[blk+0].
	.tmp0   .tmp0   ?+1
	.tmp0   .blk1:0 ?+1
	.prv    .prv    ?+1
	.prv    .tmp0   ?+1
	#Get next=mem[blk+1].
	.tmp1   .tmp1   ?+1
	.tmp1   .blk1   ?+1
	.tmp1   .z+1    ?+1
	.blk2   .blk2   ?+1
	.blk2   .tmp1   ?+1
	.tmp1   .tmp1   ?+1
	.tmp1   .blk2:0 ?+1
	.blk1   .blk1   ?+1
	.blk1   .tmp1   ?+1
	#if prev>=blk
	.alloc  .z-1    ?+1
	.prv    .blk1   .blkloop
	#The block is free. Set blk=prv.
	.alloc  .z+1    ?+1
	.blk1   .blk1   ?+1
	.blk1   .tmp0   .blkloop
.blkdone:
	#Verify blk=mem.alloc.end.
	.tmp0   .z      ?+4
	.z      .z      .errormeta
	#If we have any allocated memory. Use valc to toggle verifying that all blocks
	#are free.
	.valc   .z     .noalloc
	.valc   .valc   ?+1
	.alloc  .z      ?+4
	.z      .z      .errorfree
.noalloc:
	#Return.
	0       0       .arg2:2
.errormeta:
	#ERROR: Corrupt memory metadata
	mem.error.z ? mem.error 69 82 82 79 82 58 32 67 111 114 114 117 112 116 32 109 101 109 111 114 121 32 109 101 116 97 100 97 116 97 10 0
.errorfree:
	#ERROR: Unfreed memory
	mem.error.z ? mem.error 69 82 82 79 82 58 32 85 110 102 114 101 101 100 32 109 101 109 111 114 121 10 0
	#Variables
	0-1 .z:0 1 2 3
	.tmp0:0
	.tmp1:0
	.sbkt:   1-mem.alloc.start #start bucket, sbkt=-1+start
	.lbkt:  61+mem.alloc.start #last bucket,  lbkt=start+(bits-3)
	.nbkt:0-62-mem.alloc.start #next bucket,  nbkt=-1-lbkt
	.catch0:0-mem.alloc.start-64
	.catch1:0-1+mem.alloc.start+64+2
	.sblk:0-65-mem.alloc.start
	.lblk:0
	.prv:0
	.alloc:0
	.valc:0


mem.alloc.verifyblock:
	#Call  : 0 ? mem.alloc.verifyblock blk
	#Effect: Verifies the metadata of [blk].
	#Setup the stack.
	.tmp0   .arg2   ?+1
	0       .tmp0   ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	0       0       ?+1
	#Get [blk].
	.tmp0   .tmp0   ?+1
	.tmp0   .arg2:2 ?+1
	.blk0   .blk0   ?+1
	.blk0   .tmp0   ?+1
	.nblk   .nblk   ?+1
	.nblk   .blk0:0 ?+1
	.blk    .blk    ?+1
	.blk    .nblk   ?+1
	#Setup block pointers we'll use later.
	.prv0   .blk    ?+1
	.nxt0   .prv0   ?+1
	.prv3   .prv0   ?+1
	.nxt5   .prv0   ?+1
	.prv0   .prv0   ?+1
	.prv0   .nblk   ?+1
	#
	#Make sure we're not about to read out of bounds memory.
	#
	.tmp0   .tmp0   ?+1
	.tmp0   mem.alloc.end ?+1
	.tmp1   .tmp1   ?+1
	.tmp1   .tmp0   ?+1     #[tmp1]=[end]
	.tmp1   .blk    .error  #if end<=blk
	.tmp1   .z+2    .error  #if end-blk<=2
	#
	#Determine if the block is free and get the previous and next blocks.
	#
	.free   .free   ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .prv0:0 ?+1
	.prev   .prev   ?+1
	.prev   .tmp0   ?+1     #[blkprv]=mem[blk+0]
	.tmp1   .tmp1   ?+1
	.tmp1   .nxt0:1 ?+1
	.next   .next   ?+1
	.next   .tmp1   ?+1     #[blknxt]=mem[blk+1]
	#if prev<=next, the bucket is allocated
	.prev   .next   .isallocated
	#Swap prev and next.
	.free   .z-1    ?+1
	.next   .next   ?+1
	.next   .tmp0   ?+1
	.prev   .prev   ?+1
.isallocated:
	.prev   .tmp1   ?+1
	#
	#Verify previous block's properties.
	#
	#No block should come before mem.start.
	#Only the first block should have prev=0.
	.tmp0   .tmp0   ?+1
	.tmp0   .nblk   ?+1
	.tmp0   .strt65 .firstblock
	#We're past the first block. Verify blkprev!=0.
	.prev   .z      .error
	.z      .z      .firstdone
.firstblock:
	#This is the first block. Verify blk-start-65=0 and blkprev=0.
	.z+1    .tmp0   .error
	.z+1    .prev   .error
.firstdone:
	#The previous block should be at least 4 cells behind the current one.
	.tmp0   .tmp0   ?+1
	.tmp0   .nblk   ?+1
	.tmp0   .prev   .error  #if [blk]<=[blkprv]
	.tmp0   .z+3    .error  #if [blk]-[blkprv]<=3
	#If this block is free, the previous block should be allocated. Thus
	#mem[prev+1]=block. Otherwise, either of the previous pointers could point to
	#this block.
	.prev   .z      .blkprvdone
	#Get the previous block's pointers.
	.prv1   .prev   ?+1
	.prv2   .prv1   ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .prev   ?+1
	.prv1   .prv1   ?+1
	.prv1   .tmp0   ?+1
	.tmp1   .tmp1   ?+1
	.tmp1   .prv2:1 ?+1
	.tmp1   .nblk   ?+1          #[tmp1]=-mem[prev+1]+blk
	.tmp1   .z      .blkprvdone  #if mem[prev+1]=blk, done
	#Previous block is free, error if this block is free too.
	.z+1    .free   .error
	#This block is allocated. Verify mem[prev]=blk.
	.tmp1   .tmp1   ?+1
	.tmp1   .prv1:0 ?+1
	.tmp1   .nblk   ?+1     #[tmp1]=-mem[prev+0]+blk
	.z+1    .tmp1   .error
.blkprvdone:
	#
	#Verify the next block's properties.
	#
	#The next block should be at least 4 cells ahead of the current one.
	.tmp0   .tmp0   ?+1
	.tmp0   .next   ?+1
	.tmp1   .tmp1   ?+1
	.tmp1   .tmp0   ?+1
	.tmp1   .blk    .error  #if [blknxt]<=[blk]
	.tmp1   .z+3    .error  #if [blknxt]-[blk]<=3
	#Get the bucket for later.
	.tmp1   .z-1    ?+1
	0 ? mem.alloc.getbucket .bkt .tmp1
	#If this block is free, the next block should be allocated. Thus
	#mem[prev]=block. Otherwise, either of the next pointers could point to this
	#block.
	.tmp0   .tmp0   ?+1
	.tmp0   mem.alloc.end ?+1
	.tmp1   .tmp1   ?+1
	.tmp1   .tmp0   ?+1
	.tmp1   .next   .lastblock  #if [end]<=[next]
	#Get the next block's pointers.
	.nxt1   .next   ?+1
	.nxt2   .nxt1   ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .next   ?+1
	.nxt1   .nxt1   ?+1
	.nxt1   .tmp0   ?+1
	.tmp1   .tmp1   ?+1
	.tmp1   .nxt1:0 ?+1
	.tmp1   .nblk   ?+1          #[tmp1]=-mem[next]+blk
	.tmp1   .z      .blknxtdone  #if mem[next]=blk, done
	#Next block is free, error if this block is free too.
	.z+1    .free   .error
	#This block is allocated. Verify mem[next+1]=blk.
	.tmp1   .tmp1   ?+1
	.tmp1   .nxt2:1 ?+1
	.tmp1   .nblk   ?+1     #[tmp1]=-mem[prev+0]+blk
	.z+1    .tmp1   .error
	.z      .z      .blknxtdone
.lastblock:
	#If the next block is past the end of memory.
	.z+1    .tmp1   .error
.blknxtdone:
	#
	#Verify the block's previous bucket block.
	#
	.free   .z      .bktdone
	#Since the block will point to another block or a header, bktprv will never be
	#0. Verify bktprv->bktnxt=blk. Also verify both blocks are assigned to the same
	#bucket by length.
	.nprev  .nprev  ?+1
	.nprev  .prv3:2 ?+1
	.prev   .prev   ?+1
	.prev   .nprev  ?+1     #bktprv=mem[blk+2]
	.nxt3   .nxt3   ?+1
	.nxt3   .nprev  ?+1
	.nxt3   .z-3    ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .nxt3:0 ?+1
	.tmp0   .nblk   ?+1     #[tmp0]=-mem[bktprv+3]+[blk]
	.z+1    .tmp0   .error  #if bktprv->bktnxt!=block
	#Verify bucket head or previous block's bucket size.
	.tmp0   .tmp0   ?+1
	.tmp0   .nprev  ?+1
	.tmp0   .strt62 .bktprvhead
	.nxt4   .nxt4   ?+1
	.nxt4   .nprev  ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .nxt4:0 ?+1
	.tmp1   .tmp1   ?+1
	.tmp1   .tmp0   ?+1
	.tmp1   .prev   ?+1
	.tmp1   .z+2    ?+1     #[tmp1]=mem[bktprv]-bktprv-2
	0 ? mem.alloc.getbucket .tmp0 .tmp1
	.bkt    .tmp0   ?+1
	.z+1    .bkt    .error  #if bucket(blk)!=bucket(prev)
	.z      .z      .bktprvdone
.bktprvhead:
	#The previous pointer is to a bucket. Verify bktprv+3=bkt.
	.bkt    .prev   ?+1
	.bkt    .z+3    ?+1
	.z+1    .bkt    .error  #if bktprv+3!=bkt
.bktprvdone:
	#
	#Verify the block's next bucket block.
	#
	#Verify bktnxt->bktprv=blk.
	.nnext  .nnext  ?+1
	.nnext  .nxt5:3 ?+1
	.nnext  .z      .bktnxtdone
	.next   .next   ?+1
	.next   .nnext  ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   mem.alloc.end ?+1
	.tmp1   .tmp1   ?+1
	.tmp1   .tmp0   ?+1
	.tmp1   .next   .error  #if [end]<=[bktnxt]
	.tmp1   .z+3    .error  #if [end]-[bktnxt]<=3
	.prv4   .prv4   ?+1
	.prv4   .nnext  ?+1
	.prv4   .z-2    ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .prv4:0 ?+1
	.tmp0   .nblk   ?+1     #[tmp0]=-mem[bktnxt+2]+blk
	.z+1    .tmp0   .error  #if mem[bktnxt+2]!=blk
.bktnxtdone:
.bktdone:
	#We're done verifying.
	.tmp0   .tmp0   .arg3:3
.error:
	0       0       mem.alloc.verify.errormeta
	#Variables
	0-3 0-2 0-1 .z:0 1 2 3
	.tmp0:0
	.tmp1:0
	.blk:0
	.nblk:0
	.free:0
	.nprev:0
	.prev:0
	.nnext:0
	.next:0
	.strt62:mem.alloc.start+62
	.strt65:mem.alloc.start+65
	.bkt:0


mem.alloc:
	#Call  : 0 ? mem.alloc mem len
	#Effect: Sets [mem] to a memory address with [len] free cells. Cells are
	#initialized to 0.
	#Time  : 1041+4*len
	.tmp0   .tmp0   ?+1
	mem.alloc.init.z ? mem.alloc.init
	.tmp0   .arg2   ?+1
	0       .tmp0   ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	0       0       ?+1
	#Get mem.
	.ret0   .arg2:2 ?+1
	.ret1   .ret0   ?+1
	.ret2   .ret0   ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .ret1   ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp0   ?+1
	#Get [len]. If [len]=0, set [mem]=0 and return.
	.nblk   .nblk   ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .arg3:3 ?+1
	.p0     .p0     ?+1
	.p0     .tmp0   ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .p0:0   ?+1
	.tmp0   .z      .ret
	.len    .len    ?+1
	.len    .tmp0   ?+1
	#[len] must be at least 2.
	.len    .z+1    ?+4
	.p1     .p1     ?+7
	.len    .z-1    ?+1
	.p1     .p1     ?+1
	#Search through the buckets until we find a block such that len<=blocklen.
	.p1     .nstart ?+4
.loop:
	.p1     .z-1    ?+1
	.nblk   .nblk   ?+1
	.nblk   .p1:0   ?+1
	.nblk   .z      .loop
	.blk    .blk    ?+1
	.blk    .nblk   ?+1
	#[nbln]=-next+blk+2=-block.len
	.tmp1   .tmp1   ?+1
	.tmp1   .blk:0  ?+1
	.tmp1   .nblk   ?+1
	.tmp1   .z-2    ?+1
	.slen   .slen   ?+1
	.slen   .tmp1   ?+1
	.slen   .len    .loop
	#If this is the catch-all bucket, abort.
	.p1     .catch  ?+4
	0-1     0       ?-2
	#If there's enough slack space, split the block.
	#split=blk+2+len, want next-split>=4
	#slen=next-blk-2-(len-1)=next-split+1
	#Need slen-1>=4 or tmp0>=5
	.slen   .z+4    .nosplit0
	.len    .z-3    ?+1
	.s0     .blk    ?+1
	.s0     .len    ?+1
	.len    .z-4    ?+1
	.slen   .z-1    .didsplit0
.nosplit0:
	#We're not splitting, so we want len=next-blk.
	#tmp1=-next+blk+2
	.len    .len    ?+1
	.len    .tmp1   ?+1
	.len    .z-2    ?+1
	.slen   .slen   ?+1
.didsplit0:
	.b00    .blk    ?+1
	.b01    .b00    ?+1
	.b10    .b00    ?+1
	.b11    .b00    ?+1
	.b2     .b00    ?+1
	.b3     .b00    ?+1
	.b00    .b00    ?+1
	.b00    .nblk   ?+1
	#Get the block neighbors.
	.nnext  .nnext  ?+1
	.nnext  .b00:0  ?+1
	.nprev  .nprev  ?+1
	.nprev  .b10:1  ?+1
	#Remove from bucket. We already know bktprev.next=bktnext.prev=blk.
	#Get bktprev
	.tmp0   .tmp0   ?+1
	.tmp0   .b2:2   ?+1
	.n1     .tmp0   ?+1
	#Get bktnext
	.tmp1   .tmp1   ?+1
	.tmp1   .b3:3   ?+1
	.n2     .tmp1   ?+1
	#Set bktprev.next
	.n1     .z-3    ?+1
	.tmp1   .nblk   ?+1
	.n1:0   .tmp1   ?+1
	.n1     .n1     ?+1
	#Set bktnext.prev
	.n2     .z      .nonext0
	.n2     .z-2    ?+1
	.tmp0   .nblk   ?+1
	.n2:0   .tmp0   ?+1
	.n2     .n2     ?+1
.nonext0:
	0 ? mem.zero .blk .len
	#Setup the split block.
	.slen   .z      .nosplit1
	.s1     .s0     ?+1
	.s2     .s0     ?+1
	.s3     .s0     ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .s1     ?+1
	.tmp0   .z-1    ?+1
	.s0     .s0     ?+1
	.s0     .tmp0   ?+1
	#Set the split block's neighbors.
	.s0:0   .nnext  ?+1
	.s1:1   .nblk   ?+1
	#Add split block to a free bucket.
	0 ? mem.alloc.getbucket .bkt .slen
	.tmp0   .tmp0   ?+1
	.tmp0   .bkt:0  ?+1
	.tmp1   .tmp1   ?+1
	.tmp1   .bkt    ?+1
	#mem[blk+3]=next
	.s3:3   .tmp0   ?+1
	#next=mem[bkt]
	#if next: mem[next+2]=blk. Note mem[next+2]=bkt-3.
	.nxt2   .nxt2   ?+1
	.nxt2   .z-2    ?+1
	.tmp0   .z      .nonext1
	.bkt    .s3     ?+1
	.nxt2   .tmp0   ?+1
	.nxt2:0 .bkt    ?+1
.nonext1:
	#mem[bkt]=split
	.n4     .n4     ?+1
	.n4     .tmp1   ?+1
	.nxt2   .s2     ?+1
	.n4:0   .nxt2   ?+1
	#mem[split+2]=bkt-3
	.tmp1   .z-3    ?+1
	.s2:2   .tmp1   ?+1
	#Change the next block's prev pointer to split.
	.n3     .nnext  ?+1
	.n3     mem.alloc.end ?+1
	.n3     .z      .nonext2
	.n3     .n3     ?+1
	.n3     .nnext  ?+1
	.blk    .s0     ?+1
	.n3:0   .blk    ?+1
	.n3     .n3     ?+1
.nonext2:
	#Change the block's next pointer to split.
	.nnext  .nnext  ?+1
	.nnext  .s0     ?+1
.nosplit1:
	#Swap block next and prev.
	.b01:0  .nprev  ?+1
	.b11:1  .nnext  ?+1
	#Shift -blk to the data section.
	.nblk   .z+2    ?+1
.ret:
	.ret0:0 .ret1:0 ?+1
	.ret2:0 .nblk   ?+1
	0       0       .arg4:4
	#Variables
	0-4 0-3 0-2 0-1 .z:0 1 2 3 4
	.tmp0:0
	.tmp1:0
	.nblk:0
	.len:0
	.nstart:0-mem.alloc.start
	.catch:mem.alloc.start+62
	.slen:0
	.nnext:0
	.nprev:0


mem.realloc:
	#Call  : 0 ? mem.alloc ret mem len
	#Effect: Sets [ret] to a memory address with [len] free cells. Copies contents
	#of [mem] and frees it. Set uninitialized cells to 0.
	.tmp    .tmp    ?+1
	mem.alloc.init.z ? mem.alloc.init
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	0       0       ?+1
	#Get [ret].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	#Get [len].
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.l0     .l0     ?+1
	.l0     .tmp    ?+1
	.nlen   .nlen   ?+1
	.nlen   .l0:0   ?+1
	.len    .len    ?+1
	.len    .nlen   ?+1
	#Get [mem].
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.m0     .m0     ?+1
	.m0     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .m0:0   ?+1
	.mem    .mem    ?+1
	.mlen   .mlen   ?+1
	#Get the length of mem's block.
	.tmp    .z      .memnull
	.mem    .tmp    ?+1
	.mem    .z+1    ?+1
	.tmp    .tmp    ?+1
	.tmp    .mem:0  ?+1
	.mlen   .tmp    ?+1
	.mem    .z-1    ?+1
	.mlen   .mem    ?+1
	#Set mlen to min(mlen,len).
	.mlen   .len    ?+4
	.mlen   .mlen   ?+1
	.mlen   .nlen   ?+1
.memnull:
	#Allocate the new block and copy data.
	0 ? mem.alloc .ret .len
	0 ? mem.copy .ret .mem .mlen
	0 ? mem.free .mem
	#Set ret.
	.tmp    .tmp    ?+1
	.ret    .ret0:0 ?+1
	.tmp    .ret    ?+1
	.ret1:0 .tmp    ?+1
	0       0       .arg5:5
	#Variables
	0-1 .z:0 1 2
	.tmp:0
	.mlen:0
	.nlen:0
	.len:0
	.ret:0


mem.free:
	#Call  : 0 ? mem.free mem
	#Effect: Frees the memory block at [mem] that was allocated by mem.alloc. If
	#[mem]=0, do nothing.
	#Time  : 387+6*len, no debug: 210
	.tmp0   .arg2   ?+1
	mem.alloc.init.z ? mem.alloc.init
	.tmp0   .z-2    ?+1
	0       .tmp0   ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	0       0       ?+1
	#Get [blk]. Note [mem]=[blk]+2. If [mem]=0, we're done.
	.tmp0   .tmp0   ?+1
	.tmp0   .arg2:2 ?+1
	.b0     .b0     ?+1
	.b0     .tmp0   ?+1
	.nblk   .nblk   ?+1
	.nblk   .b0:0   ?+1
	.nblk   .z      .done
	.nblk   .z-2    ?+1
	.blk    .blk    ?+1
	.blk    .nblk   ?+1
	#Verify [blk] is a valid block and we're not double freeing. Randomize the data
	#section to help prevent using the memory after freeing.
	mem.debug .z .dbgdone0
	0 ? mem.alloc.verifyblock .blk
	mem.alloc.verifyblock.free .z .dbgdone0
	#ERROR: Double free
	mem.error.z ? mem.error 69 82 82 79 82 58 32 68 111 117 98 108 101 32 102 114 101 101 10 0
.dbgdone0:
	#prev=mem[blk+0]
	.nprev  .nprev  ?+1
	.nprev  .blk:0  ?+1
	.prev   .prev   ?+1
	.prev   .nprev  ?+1
	#next=mem[blk+1]
	.p1     .p1     ?+1
	.p1     .nblk   ?+1
	.p1     .z-1    ?+1
	.nnext  .nnext  ?+1
	.nnext  .p1:0   ?+1
	.next   .next   ?+1
	.next   .nnext  ?+1
	#Randomize the entire block to prevent using after freeing.
	mem.debug .z .dbgdone1
	.rand   0-4     ?+1
	#Get the block start and length.
	.dbg0   .dbg0   ?+1
	.dbg0   .nblk   ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .nnext  ?+1
	.tmp0   .dbg0   ?+1
	.tmp1   .tmp1   ?+1
	.tmp1   .blk    ?+4
.dbgrandloop:
	.tmp0   .z+1    .dbgdone1
	.dbg0:0 .rand   ?+1
	.tmp1   .rand   ?+1
	.rand   .tmp1   ?+7
	.rand   .rcon0  ?+1
	.dbg0   .z-1    .dbgrandloop
	.rand   .rcon1  ?+1
	.dbg0   .z-1    .dbgrandloop
	#Random variables.
	.rand: 0xdb38ab4d4d3b3ece
	.rcon0:0x1e8352fef1e4be80
	.rcon1:0xf5819f19ab244199
.dbgdone1:
	#If the next block is free, unlink and merge it. This needs to occur before prev.
	#if next<end
	.tmp0   .tmp0   ?+1
	.tmp0   mem.alloc.end ?+1
	.tmp1   .tmp1   ?+1
	.tmp1   .tmp0   ?+1
	.tmp1   .next   .nextdone
	#Setup next block pointers.
	.n0     .next   ?+1
	.n1     .n0     ?+1
	.n2     .n0     ?+1
	.n3     .n0     ?+1
	.n0     .n0     ?+1
	.n0     .nnext  ?+1
	#if mem[next]==blk, skip
	.tmp0   .tmp0   ?+1
	.tmp0   .n1:0   ?+1
	.tmp0   .nblk   ?+1
	.tmp0   .z      .nextdone
	#next.prev=mem[next+2]
	.tmp0   .tmp0   ?+1
	.tmp0   .n2:2   ?+1
	.prv0   .prv0   ?+1
	.prv0   .tmp0   ?+1
	#next.next=mem[next+3]
	.tmp1   .tmp1   ?+1
	.tmp1   .n3:3   ?+1
	.nxt0   .nxt0   ?+1
	.nxt0   .tmp1   ?+1
	#mem[next.prev+3]=next.next. Note mem[next.prev+3]=next.
	.prv0   .z-3    ?+1
	.tmp1   .nnext  ?+1
	.prv0:0 .tmp1   ?+1
	#if next.next: mem[next.next+2]=next.prev. Note mem[next.next+2]=next.
	.nxt0   .z      ?+10
	.nxt0   .z-2    ?+1
	.tmp0   .nnext  ?+1
	.nxt0:0 .tmp0   ?+1
	#next=mem[next]
	.nnext  .nnext  ?+1
	.nnext  .n0:0   ?+1
	.next   .next   ?+1
	.next   .nnext  ?+1
.nextdone:
	#If the previous block is free, unlink and merge it.
	#if prev!=0
	.prev   .z      .prevdone
	#Setup previous block pointers.
	.r0     .prev   ?+1
	.r1     .r0     ?+1
	.r2     .r0     ?+1
	.r3     .r0     ?+1
	.r0     .r0     ?+1
	.r0     .nprev  ?+1
	#if mem[prev]==blk
	.tmp0   .tmp0   ?+1
	.tmp0   .r0:0   ?+1
	.tmp0   .nblk   ?+1
	.tmp0   .z      ?+4
	.tmp0   .tmp0   .prevdone
	#blk=prev
	.nblk   .nblk   ?+1
	.nblk   .prev   ?+1
	.blk    .blk    ?+1
	.blk    .nblk   ?+1
	#prev.prev=mem[prev+2]
	.tmp0   .tmp0   ?+1
	.tmp0   .r2:2   ?+1
	.prv1   .prv1   ?+1
	.prv1   .tmp0   ?+1
	#prev.next=mem[prev+3]
	.tmp1   .tmp1   ?+1
	.tmp1   .r3:3   ?+1
	.nxt1   .nxt1   ?+1
	.nxt1   .tmp1   ?+1
	#mem[prev.prev+3]=prev.next. Note mem[prev.prev+3]=prev.
	.prv1   .z-3    ?+1
	.tmp1   .nprev  ?+1
	.prv1:0 .tmp1   ?+1
	#if prev.next: mem[prev.next+2]=prev.prev. Note mem[prev.next+2]=prev.
	.nxt1   .z      ?+10
	.nxt1   .z-2    ?+1
	.tmp0   .nprev  ?+1
	.nxt1:0 .tmp0   ?+1
	#prev=mem[prev+1]
	.nprev  .nprev  ?+1
	.nprev  .r1:1   ?+1
.prevdone:
	#If next<end, set mem[next]=blk.
	mem.alloc.end .next .nonext0
	.p22    .next   ?+1
	.p23    .p22    ?+1
	.p24    .p22    ?+1
	.p22    .p22    ?+1
	.p22    .nnext  ?+1
	.p22:0  .p23:0  ?+1
	.p24:0  .nblk   ?+1
.nonext0:
	mem.alloc.end .nnext ?+1
	#Setup block pointers.
	.b1     .blk    ?+1
	.b2     .b1     ?+1
	.b3     .b1     ?+1
	.b4     .b1     ?+1
	.b5     .b1     ?+1
	.b6     .b1     ?+1
	.b7     .b1     ?+1
	.b8     .b1     ?+1
	.b9     .b1     ?+1
	.b10    .b1     ?+1
	.b11    .b1     ?+1
	.b12    .b1     ?+1
	.b1     .b1     ?+1
	.b1     .nblk   ?+1
	#mem[blk+0]=next
	.b1:0   .b2:0   ?+1
	.b3:0   .nnext  ?+1
	#mem[blk+1]=prev
	.b4:1   .b5:1   ?+1
	.b6:1   .nprev  ?+1
	#Add block to a free bucket.
	#len=next-blk-2
	#bkt=self.getbucket(len)
	.next   .blk    ?+1
	.next   .z+2    ?+1
	0 ? mem.alloc.getbucket .bkt .next
	.nnext  .nnext  ?+1
	.nnext  .bkt:0  ?+1
	.tmp0   .tmp0   ?+1
	.tmp0   .bkt    ?+1
	#mem[blk+3]=next
	.b7:3   .b8:3   ?+1
	.b9:3   .nnext  ?+1
	#next=mem[bkt]
	#if next: mem[next+2]=blk. Note mem[next+2]=bkt-3.
	.nxt2   .nxt2   ?+1
	.nxt2   .z-2    ?+1
	.nnext  .z      .nonext1
	.bkt    .b7     ?+1
	.nxt2   .nnext  ?+1
	.nxt2:0 .bkt    ?+1
.nonext1:
	#mem[bkt]=blk
	.p31    .p31    ?+1
	.p31    .tmp0   ?+1
	.nxt2   .b10    ?+1
	.p31:0  .nxt2   ?+1
	#mem[blk+2]=bkt-3
	.tmp0   .z-3    ?+1
	.b10:2  .b11:2  ?+1
	.b12:2  .tmp0   ?+1
.done:
	.tmp0   .tmp0   .arg3:3
	#Variables
	0-3 0-2 0-1 .z:0 1 2
	.tmp0:0
	.tmp1:0
	.nblk:0
	.nprev:0
	.prev:0
	.nnext:0
	.next:0


mem.alloc.end: 0-32
mem.alloc.start:

#The end of the universe and the start of unused memory. Nothing should come
#after this label.

