#|==============================================================================


Signed Integer Operations - v1.03

Author: Alec Dee - alecdee.github.io - akdee144@gmail.com


--------------------------------------------------------------------------------
Notes


int.unl provides functions for performing the signed integer operations that
uint.unl doesn't cover.

If unileq's underlying integers are mod N, then we consider an integer to be
negative if x >= floor((N+1)/2). The negative value of x is x' = x - N.

All functions are bit length agnostic. They don't need to be modified even if
unileq uses a something other than 64 bit integers.

The 0 address will always be 0 upon function return, even if one of the return
value addresses is 0.

This library does not depend on any other libraries.

Worst case time complexity:


       Function  |  Time  |      O(n)
     ------------+--------+----------------
         print   |     -  |  -
          cmp    |    37  |  37
          min    |    43  |  43
          max    |    43  |  43
          abs    |    30  |  30
          mul    |   898  |  66 + 13*bits
          div    |   904  |  72 + 13*bits
          shr    |   555  |  43 +  8*bits


--------------------------------------------------------------------------------
Index


Strings
int.print [num] [base] [padding] [padchar] [sign]

Comparisons
int.cmp [a] [b] lt eq gt
int.min [ret] [a] [b]
int.max [ret] [a] [b]
int.abs [ret] [a]

Integer Arithmetic
int.mul [high] [low] [a] [b]
int.div [quot] [rem] [num] [den]

Bitwise Arithmetic
int.shr [ret] [num] [shift]


--------------------------------------------------------------------------------
Version History


1.00
     Initial version.
     Most functions are based off of their unsigned equivalents.
1.01
     Added int.cmp, int.min, int.max, int.abs, int.mul, int.div, and int.shr.
1.02
     Removed a temporary variable in int.abs.
1.03
     Removed unnecessary instructions from int.mul when high=0.


--------------------------------------------------------------------------------
TODO


Optimize sign extension for int.shr.
Optimize int.cmp.
Unroll first loop in mul, div, and shr to check for sign.


|#


#--------------------------------------------------------------------------------
#Strings


int.print:
	#Call  : 0 ? int.print num base padding padchar sign
	#
	#Effect: Prints a signed number in an arbitrary base. If the padding
	#character is whitespace, print the sign after padding.
	#
	#This function works even if unileq's underlying integers are not a power of two.
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	.arg7   0       ?+1
	#Get [num].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.nnum   .nnum   ?+1
	.nnum   .p0:0   ?+1
	.num    .num    ?+1
	.num    .nnum   ?+1
	#Check if [num] < 0.
	.nnum   .z+1    ?+1
	.num    .nnum   .notneg
	#Set [nnum] = [num].
	.tmp    .tmp    ?+1
	.tmp    .num    ?+1
	.nnum   .tmp    ?+1
	.sign   .nneg   .isneg
.notneg:
	.nnum   .z-1    ?+1
	#Load [sign].
	.tmp    .tmp    ?+1
	.tmp    .arg6:6 ?+1
	.p4     .p4     ?+1
	.p4     .tmp    ?+1
	.p4:0   .z      .isneg
	.sign   .nplus  ?+1
.isneg:
	.num    .num    ?+1
	.num    .nnum   ?+1
	#Get [pad].
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p2     .p2     ?+1
	.p2     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p2:0   ?+1
	.pad    .pad    ?+1
	.pad    .tmp    ?+1
	#Get [padchr].
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p3:0   ?+1
	.padchr .padchr ?+1
	.padchr .tmp    ?+1
	#If [padchr] is not whitespace, print [sign] before padding.
	.sign   .z      .nosign
	.pad    .z      ?+4
	.pad    .z+1    ?+1
	.padchr .white  ?+7
	0-2     .sign   ?+1
	.sign   .sign   ?+1
	.padchr .nwhite ?+1
.nosign:
	#Get [base].
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.nbase  .nbase  ?+1
	.nbase  .p1:0   ?+1
	.base   .base   ?+1
	.base   .nbase  ?+1
	.nbase  .base   ?+1
	#Make sure 1 <= [base] <= 16.
	.base   .z      ?+7
	.base   .z+1    .unary
	.base   .mxbase .notunary
	0-1     0       ?-2
.unary:
	#[base] = 1. Print 1's like hash marks.
	#Pad while [pad] > [num].
	.pad    .num    .unarypaddone
	0-2     .padchr ?+1
	.pad    .z+1    .unarypaddone
	0-2     .padchr ?-5
.unarypaddone:
	#Print the sign if we haven't yet.
	.sign   .z      ?+7
	0-2     .sign   ?+1
	.sign   .sign   ?+1
	#Print 1's while [num] > 0.
	.num    .z      .ret
	0-2     .hex+2  ?+1
	.num    .z+1    .ret
	0-2     .hex+2  ?-5
.notunary:
	#Calculate the most significant digit and how many digits are in [num].
	.den    .den    ?+1
	.lden   .lden   ?+1
	.base   .base   ?+1
	.base   .nbase  ?+1
	.chr    .chr    ?+1
	.chr    .z-1    ?+1
.firstloop:
	.digits .z-1    ?+1
	#num-=den
	.chr    .base   ?+1
	.num    .den   .firstdone
	.num    .z+1    ?+1
	.chr    .z-2    ?-8
	#den=base*lden-1
	.lden   .lden   ?+1
	.lden   .den    ?+1
	.den    .den    ?+1
	.den    .nnum   ?+1
	.den    .num    ?+1
	.den    .z+1    ?+1
	.num    .num    ?+1
	.num    .nnum   .firstloop
.firstdone:
	#Print padding.
	.pad    .digits ?+10
	0-2     .padchr ?+1
	.pad    .z+1    ?+4
	0-2     .padchr ?-5
	#Print the sign if we haven't yet.
	.sign   .z      ?+7
	0-2     .sign   ?+1
	.sign   .sign   ?+1
	#Correct [num], [base], and [den].
	.chr    .nbase  ?+1
	.base   .z+2    ?+1
	.tmp    .tmp    ?+1
	.tmp    .den    ?+1
	.num    .tmp    ?+1
	.den    .den    ?+1
	.den    .lden   .printdigit
.nextloop:
	#num=num*base
	.z+1    .base   ?+1
	.num    .lden   ?+1
	.nnum   .nnum   ?+1
	.nnum   .num    ?+1
	.num    .nnum   ?+1
	.z+1    .z-2    ?-5
.printdigit:
	#Print a digit.
	.chr    .nhex   ?+1
	0-2     .chr:0  ?+1
	.digits .z+1    .ret
	#digit=num/den
	.chr    .chr    ?+1
	.num    .den    .nextloop
	.num    .z+1    ?+1
	.chr    .z-2    ?-8
.ret:
	0       0       .arg7:7
	#Variables
	0-2 0-1 .z:0 1 2
	.nnum:0
	.num:0
	.mxbase:16-1
	.nbase:0
	.base:0
	.pad:0
	.padchr:32
	.digits:0
	.tmp:0
	.den:0
	.lden:0
	.white:32
	.nwhite:0-32
	.sign:0
	.nplus:0-43
	.nneg:0-45
	.hex:
		48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55
		56 56 57 57 65 65 66 66 67 67 68 68 69 69 70 70
	.nhex:0-.hex


#--------------------------------------------------------------------------------
#Comparisons


int.cmp:
	#Call  : 0 ? int.cmp a b lt eq gt
	#
	#Effect: For signed [a] and [b].
	#      : if [a]<[b]: goto lt
	#      : if [a]=[b]: goto eq
	#      : if [a]>[b]: goto gt
	#
	#Time  : 37
	#
	#Setup stack pointer.
	.z      .arg2   ?+1
	0       .z      ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	0       0       ?+1
	#Get [a]
	.z      .z      ?+1
	.z      .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .z      ?+1
	.na     .na     ?+1
	.na     .p0:0   ?+1
	.a      .a      ?+1
	.a      .na     ?+1
	.na     .z+1    ?+1
	#Get [b]
	.z      .z      ?+1
	.z      .arg3:3 ?+1
	.p1     .p1     ?+1
	.p1     .z      ?+1
	.nb     .nb     ?+1
	.nb     .p1:0   ?+1
	.b      .b      ?+1
	.b      .nb     ?+1
	.nb     .z+1    ?+1
	.z      .z      ?+1
	#Check if [a]>=0 or [b]>=0.
	.a      .na     .age0
	.b      .nb     .alt0bge0
.age0bge0:
	.na     .nb     .ge
.alt0bge0:
	#If [a]<[b]
	.z      .arg4:4 .ret
.age0:
	.b      .nb     .age0bge0
.ge:
	.na     .z      .eq
.gt:
	#If [a]>[b]
	.z      .arg6:6 .ret
.eq:
	#If [a]=[b]
	.z      .arg5:5 .ret
.ret:
	.r0     .r0     ?+1
	.r0     .z      ?+1
	.z      .z      .r0:0
	#Variables
	.a:0
	.na:0
	.b:0
	.nb:0
	.z:0 1 2


int.min:
	#Call  : 0 ? int.min ret a b
	#
	#Effect: [ret] = min([a],[b]) for signed [a] and [b].
	#
	#Time  : 43
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get ret
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.na     .na     ?+1
	.na     .p3:0   ?+1
	.a      .a      ?+1
	.a      .na     ?+1
	#Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p4     .p4     ?+1
	.p4     .tmp    ?+1
	.nb     .nb     ?+1
	.nb     .p4:0   ?+1
	.b      .b      ?+1
	.b      .nb     ?+1
	#Set [ret]
	.tmp    .tmp    ?+1
	.val    .val    ?+1
	.a      .na     .age0
	.b      .nb     .alt0bge0
.age0bge0:
	.a      .b      ?+4
	.val    .nb     .ret
.alt0bge0:
	.b      .z      .beq0
	.val    .na     .ret
.beq0:
	.nb     .z      ?-5
	.val    .nb     .ret
.age0:
	.b      .nb     .age0bge0
	.a      .z      .aeq0
	.val    .nb     .ret
.aeq0:
	.na     .z      ?-5
	.val    .na     .ret
.ret:
	.val    .ret0:0 ?+1
	.tmp    .val    ?+1
	.ret1:1 .tmp    ?+1
	#Return
	0       0       .arg5:5
	#Variables
	.z:0 1 2
	.tmp:0
	.a:0
	.na:0
	.b:0
	.nb:0
	.val:0


int.max:
	#Call  : 0 ? int.max ret a b
	#
	#Effect: [ret] = max([a],[b]) for signed [a] and [b].
	#
	#Time  : 43
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get ret
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.na     .na     ?+1
	.na     .p3:0   ?+1
	.a      .a      ?+1
	.a      .na     ?+1
	#Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p4     .p4     ?+1
	.p4     .tmp    ?+1
	.nb     .nb     ?+1
	.nb     .p4:0   ?+1
	.b      .b      ?+1
	.b      .nb     ?+1
	#Set [ret]
	.tmp    .tmp    ?+1
	.val    .val    ?+1
	.a      .na     .age0
	.b      .nb     .alt0bge0
.age0bge0:
	.a      .b      ?+4
	.val    .na     .ret
.alt0bge0:
	.b      .z      .beq0
	.val    .nb     .ret
.beq0:
	.nb     .z      ?-5
	.val    .na     .ret
.age0:
	.b      .nb     .age0bge0
	.a      .z      .aeq0
	.val    .na     .ret
.aeq0:
	.na     .z      ?-5
	.val    .nb     .ret
.ret:
	.val    .ret0:0 ?+1
	.tmp    .val    ?+1
	.ret1:1 .tmp    ?+1
	#Return
	0       0       .arg5:5
	#Variables
	.z:0 1 2
	.tmp:0
	.a:0
	.na:0
	.b:0
	.nb:0
	.val:0


int.abs:
	#Call  : 0 ? int.abs ret a
	#
	#Effect: [ret] = abs([a])
	#
	#Time  : 30
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	#Get [ret]
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	#Get [val]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.nval   .nval   ?+1
	.nval   .p0:0   ?+1
	.val    .val    ?+1
	.val    .nval   ?+1
	#Check if [val] < 0.
	.tmp    .tmp    ?+1
	.nval   .z+1    ?+1
	.val    .nval   ?+4
	.tmp    .val    ?+4
	.nval   .z-1    ?+1
	#Set [ret].
	.tmp    .ret0:0 ?+1
	.nval   .tmp    ?+1
	.ret1:0 .nval   ?+1
	0       0       .arg4:4
	#Variables
	0-1 .z:0 1 2
	.tmp:0
	.val:0
	.nval:0


#--------------------------------------------------------------------------------
#Integer Arithmetic


int.mul:
	#Call  : 0 ? int.mul high low a b
	#
	#Effect: [high] = [a]*[b] / 2^64 , sign extended
	#      : [low]  = [a]*[b] % 2^64
	#
	#Time  : 66 + 13*bits = 898
	#Time  : 40 +  7*bits = 488 if high=0
	#
	#Use [hval] and [lval] to store the high and low values of [a]*[b]. During each
	#loop, shift [hval], [lval], and [b] to the left by 1. If the top bit of [b] is
	#set, add [a] to [lval] and carry into [hval].
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	#Get low
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.l0     .l0     ?+1
	.l0     .tmp    ?+1
	.l1     .l1     ?+1
	.l1     .tmp    ?+1
	#Get -[a]. Use -[a] for adding to [lval].
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.a0     .a0     ?+1
	.a0     .tmp    ?+1
	.na     .na     ?+1
	.na     .a0:0   ?+1
	#Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.b0     .b0     ?+1
	.b0     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .b0:0   ?+1
	.b      .b      ?+1
	.b      .tmp    ?+1
	#Offset [tmp] by 1 to force [b] to be odd.
	.tmp    .z+1    ?+1
	.lval   .lval   ?+1
	#Get high. Only set if [hret]!=0.
	.hret   .arg2:2 ?+1
	.hret   .z      .looplow
	#Record [a] and -[b] for sign correction.
	.a      .a      ?+1
	.a      .na     ?+1
	.nb     .nb     ?+1
	.nb     .b      ?+1
	#If -[a]=1, we have to manually set [low]=[b].
	.na     .z-1    ?+1
	.na     .z      .rethigh+3
	.hval   .hval   ?+1
	.lval   .z-1    .loophigh+3
	#-------- Calculate [lval] and [hval] --------
.loophigh:
	#If the highest bit of [b] is set, add [a] to [lval] and carry to [hval].
	.tmp    .b      ?+1
	.b      .tmp    ?+7
	.lval   .na     ?+10
	.hval   .z-1    ?+7
	#If [b]=0, we are done.
	.b      .z      .rethigh
	.lval   .z+1    ?+1
	#Left shift [hval].
	.htmp   .htmp   ?+1
	.htmp   .hval   ?+1
	.hval   .htmp   ?+1
	#Left shift [lval] and carry into [hval].
	.ltmp   .ltmp   ?+1
	.ltmp   .lval   ?+1
	.ltmp   .z+1    ?+1
	.lval   .ltmp   ?+4
	.hval   .z-1    ?+1
	.tmp    .tmp    .loophigh
	#----------- Only calculate [lval] -----------
.looplow:
	#If the highest bit of [b] is set, add [a] to [lval].
	.b      .tmp    ?+7
	.lval   .na     ?+1
	.tmp    .tmp    ?+7
	#If [b]=0, we are done.
	.b      .z      .retlow
	.tmp    .tmp    ?+1
	#Left shift [lval].
	.ltmp   .ltmp   ?+1
	.ltmp   .lval   ?+1
	.lval   .ltmp   ?+1
	.tmp    .b      .looplow
.rethigh:
	#Because we terminate 1 iteration late, return [htmp] and [ltmp] instead of
	#[hval] and [lval].
	.ltmp   .z-1    ?+7
	.ltmp   .ltmp   ?+1
	.htmp   .htmp   ?+1
	#If [a]<0, sub [b] from [high].
	.na     .z+2    ?+1
	.a      .na     ?+4
	.htmp   .nb     ?+1
	#If [b]<0, sub [a] from [high].
	.tmp    .tmp    ?+1
	.tmp    .nb     ?+1
	.nb     .z+1    ?+1
	.tmp    .nb     ?+7
	.htmp   .na     ?+1
	.htmp   .z+1    ?+1
	#Set [high]
	.h0     .h0     ?+1
	.h0     .hret   ?+1
	.h1     .h1     ?+1
	.h1     .hret   ?+1
	.hret   .hret   ?+1
	.tmp    .tmp    ?+1
	.tmp    .h0:0   ?+1
	.htmp   .tmp    ?+1
	.h1:0   .htmp   ?+1
.retlow:
	#Set [low]
	.b      .l0:0   ?+1
	.ltmp   .b      ?+1
	.l1:0   .ltmp   ?+1
	0       0       .arg6:6
	#Variables
	0-2 0-1 .z:0 1 2
	.tmp:0
	.a:0
	.na:0
	.b:0
	.nb:0
	.hret:0
	.hval:0
	.htmp:0
	.lval:0
	.ltmp:0


int.div:
	#Call  : 0 ? int.div quot rem num den
	#
	#Effect: [quot] = [num] / [den] , rounded towards 0
	#      : [rem]  = [num] % [den]
	#
	#Time  : 72 + 13*bits = 904
	#      : 64 +  9*bits = 640 if quot=0
	#
	#Every loop, shift [quot], [rem], and [num] left by 1. If the top bit of [num] is
	#set, add 1 to [rem]. Then, if [rem]>=[den], add 1 to [quot] and subtract [den]
	#from [rem].
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	#Get quot. Only set if qret!=0.
	.qret   .qret   ?+1
	.qret   .arg2:2 ?+1
	#Get rem
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.r2     .r2     ?+1
	.r2     .tmp    ?+1
	.r3     .r3     ?+1
	.r3     .tmp    ?+1
	#Get [den]
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.nden   .nden   ?+1
	.nden   .p1:0   ?+1
	#If [den]=0, abort.
	.nden   .z      .divz
	#Check if [den]<0.
	.den    .den    ?+1
	.den    .nden   ?+1
	.nden   .z+1    ?+1
	.den    .nden   .denpos
	.tmp    .tmp    ?+1
	.tmp    .den    ?+1
	.nden   .tmp    ?+1
	.nden   .z-1    ?+1
	.qsign  .z-1    ?+4
.denpos:
	#Correct [den].
	.nden   .z-2    ?+1
	.den    .den    ?+1
	.den    .nden   ?+1
	#Get [num]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1
	.num    .num    ?+1
	.num    .tmp    ?+1
	#If [num]<0.
	.tmp    .z+1    ?+1
	.num    .tmp    .numpos
	.rsign  .num    ?+1
	.tmp    .rsign  ?+1
	.qsign  .z      ?+4
	.qsign  .qsign  .numpos+3
	.qsign  .z-1    .numpos+3
.numpos:
	.tmp    .z-1    ?+1
	.num    .num    ?+1
	.num    .tmp    ?+1
	#Offset [tmp] by 1 to force [num] to be odd.
	.tmp    .z+1    ?+1
	.rem    .rem    ?+1
	.qret   .z      .looprem
	#-------- Calculate [rem] and [quot] --------
.loopquot:
	#[rem]+=[num]>>63, [num]<<=1. If [num]=0, abort.
	.num    .tmp    ?+4
	.rem    .z-1    ?+4
	.num    .z      .retquot
	#If [rem]>=[den], [quot]+=1
	.rem    .den    ?+7
	.rem    .z+1    ?+1
	.quot   .z-1    ?+4
	.rem    .nden   ?+1
	#[quot]<<=1.
	.qtmp   .qtmp   ?+1
	.qtmp   .quot   ?+1
	.quot   .qtmp   ?+1
	#[rem]<<=1
	.rtmp   .rtmp   ?+1
	.rtmp   .rem    ?+1
	.rem    .rtmp   ?+1
	.tmp    .tmp    ?+1
	.tmp    .num    .loopquot
	#----------- Only calculate [rem] -----------
.looprem:
	#[rem]+=[num]>>63, [num]<<=1. If [num]=0, abort.
	.num    .tmp    ?+4
	.rem    .z-1    ?+4
	.num    .z      .retrem
	#If [rem]>=[den], [quot]+=1
	.rem    .den    ?+7
	.rem    .z+1    ?+1
	.rtmp   .rtmp   ?+7
	.rem    .nden   ?+1
	.rtmp   .rtmp   ?+1
	#[rem]<<=1
	.rtmp   .rem    ?+1
	.rem    .rtmp   ?+1
	.tmp    .tmp    ?+1
	.tmp    .num    .looprem
.retquot:
	#Because we terminate 1 iteration late, return [qtmp] and [rtmp] instead of
	#[quot] and [rem].
	#If the signs of [num] and [den] mismatch, negate [qtmp].
	.tmp    .tmp    ?+1
	.qsign  .z      ?+7
	.qsign  .qsign  ?+1
	.tmp    .quot   ?+1
	#Set [quot]
	.r0     .r0     ?+1
	.r0     .qret   ?+1
	.r1     .r1     ?+1
	.r1     .qret   ?+1
	.tmp    .r0:0   ?+1
	.qtmp   .tmp    ?+1
	.r1:0   .qtmp   ?+1
.retrem:
	#If [num]<0, negate [rem].
	.rsign  .z      ?+7
	.rsign  .rsign  ?+1
	.num    .rem    ?+1
	#Set [rem]
	.num    .r2:0   ?+1
	.rtmp   .num    ?+1
	.r3:0   .rtmp   ?+1
	0       0       .arg6:6
.divz:
	#Abort
	0-1     0       ?-2
	#Variables
	0-2 0-1 .z:0 1
	.tmp:0
	.num:0
	.den:0
	.nden:0
	.qret:0
	.quot:0
	.qtmp:0
	.qsign:0
	.rem:0
	.rtmp:0
	.rsign:0


#--------------------------------------------------------------------------------
#Bitwise Arithmetic


int.shr:
	#Call  : 0 ? int.shr ret num shift
	#
	#Effect: [ret] = [num] >> [shift]. Sign extend if [num]<0.
	#
	#Time  : 43 + 8*bits = 555
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#On first run, calculate how many bits we are using.
	.tmp    .tmp    .firsts:?+1
	.firsts .firstv ?+1
	.num    .z-1    ?+1
.firstloop:
	.num    .z      .firstdone
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.nbits  .z+1    ?+1
	.tmp    .tmp    .firstloop
.firstdone:
	#Get ret
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	.rval   .rval   ?+1
	#Get [shift]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.tmp    .tmp    ?+1
	#Get [num]
	.tmp    .arg3:3 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1
	.num    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .z+1    ?+1
	#If [num]<0, set [tmp]=~[num].
	.num    .tmp    .numpos
	.neg    .num    ?+1
	.tmp    .neg    ?+1
.numpos:
	#If [shift]>=[bits], abort.
	.shift  .nbits  ?+1
	.shift  .p1:0   .ret
	.num    .num    ?+1
	.num    .tmp    ?+1
	.num    .z+1    ?+1
.loop:
	#[num]<<=1. Carry into [rval].
	.num    .tmp    ?+4
	.rval   .z-1    ?+1
	.tmp    .tmp    ?+1
	.shift  .z+1    .ret+6
	#[rval]<<=1
	.tmp    .rval   ?+1
	.rval   .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .num    .loop
.ret:
	.tmp    .tmp    ?+1
	.shift  .shift  ?+1
	#If [num]<0, set [rval]=~[rval].
	.neg    .z      .notneg
	.neg    .neg    ?+1
	.num    .num    ?+1
	.num    .rval   ?+1
	.tmp    .num    ?+1
	.tmp    .z-1    ?+1
	.rval   .rval   ?+1
.notneg:
	#Set [ret].
	.rval   .ret0:0 ?+1
	.tmp    .rval   ?+1
	.ret1:0 .tmp    ?+1
	0       0       .arg5:5
	#Variables
	.firstv:.firsts+1-.firstdone
	.nbits:0
	.num:0
	.rval:0
	.shift:0
	.tmp:0
	.neg:0
	0-1 .z:0 1 2


