#|==============================================================================


Signed Integer Operations - v2.01

Author: Alec Dee - alecdee.github.io - akdee144@gmail.com


--------------------------------------------------------------------------------
Notes


int.unl provides functions for performing the signed integer operations that
uint.unl doesn't cover.

If unileq's underlying integers are mod N, then we consider an integer to be
negative if x >= floor((N+1)/2). The negative value of x is x' = x - N.

Unileq typically uses integers modulo 2^64. However, string printing, integer
arithmetic, and comparisons will work with any modulo. Bitwise functions, on
the other hand, require integers modulo 2^n.

The 0 address will always be 0 upon function return, even if one of the return
value addresses is 0.

This library does not depend on any other libraries.

Worst case time complexity:


       Function  |    Complexity     |  Instructions
                 |                   |   (64 bits)
     ------------+-------------------+----------------
         print   |  --               |       --
          cmp    |  37               |       37
          min    |  43               |       43
          max    |  43               |       43
          abs    |  30               |       30
          mul    |  63 + 12.97*bits  |      893
          div    |  87 +  8.65*bits  |      640
          shr    |  43 +  8.00*bits  |      555


--------------------------------------------------------------------------------
Index


Strings
int.print [num] [base] [padding] [padchar] [sign]

Comparisons
int.cmp [a] [b] lt eq gt
int.min [ret] [a] [b]
int.max [ret] [a] [b]
int.abs [ret] [a]

Integer Arithmetic
int.mul [high] [low] [a] [b]
int.div [quot] [rem] [num] [den]

Bitwise Arithmetic
int.shr [ret] [num] [shift]


--------------------------------------------------------------------------------
Version History


1.00
     Initial version.
     Most functions are based off of their unsigned equivalents.
1.01
     Added int.cmp, int.min, int.max, int.abs, int.mul, int.div, and int.shr.
1.02
     Removed a temporary variable in int.abs.
1.03
     Removed unnecessary instructions from int.mul when high=0.
2.00
     All integer arithmetic functions work with any modulo on the underlying
     integers.
     Remade int.div and int.mul to work with any modulo, even non power-of-two,
     by using the fibonacci sequence.
     int.div is 30% faster and int.mul is 1% faster.
2.01
     Updated comments.


--------------------------------------------------------------------------------
TODO


Optimize sign extension for int.shr.
Optimize comparison functions.


|#


#--------------------------------------------------------------------------------
#Strings


int.print:
	#Call  : 0 ? int.print num base padding padchar sign
	#
	#Effect: Prints a signed number in an arbitrary base. If the padding
	#character is whitespace, print the sign after padding.
	#
	#Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	.arg7   0       ?+1
	#Get [num].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.nnum   .nnum   ?+1
	.nnum   .p0:0   ?+1
	.num    .num    ?+1
	.num    .nnum   ?+1
	#Check if [num] < 0.
	.nnum   .z+1    ?+1
	.num    .nnum   .notneg
	#Set [nnum] = [num].
	.tmp    .tmp    ?+1
	.tmp    .num    ?+1
	.nnum   .tmp    ?+1
	.sign   .nneg   .isneg
.notneg:
	.nnum   .z-1    ?+1
	#Load [sign].
	.tmp    .tmp    ?+1
	.tmp    .arg6:6 ?+1
	.p4     .p4     ?+1
	.p4     .tmp    ?+1
	.p4:0   .z      .isneg
	.sign   .nplus  ?+1
.isneg:
	.num    .num    ?+1
	.num    .nnum   ?+1
	#Get [pad].
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p2     .p2     ?+1
	.p2     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p2:0   ?+1
	.pad    .pad    ?+1
	.pad    .tmp    ?+1
	#Get [padchr].
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p3:0   ?+1
	.padchr .padchr ?+1
	.padchr .tmp    ?+1
	#If [padchr] is not whitespace, print [sign] before padding.
	.sign   .z      .nosign
	.pad    .z      ?+4
	.pad    .z+1    ?+1
	.padchr .white  ?+7
	0-2     .sign   ?+1
	.sign   .sign   ?+1
	.padchr .nwhite ?+1
.nosign:
	#Get [base].
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.nbase  .nbase  ?+1
	.nbase  .p1:0   ?+1
	.base   .base   ?+1
	.base   .nbase  ?+1
	.nbase  .base   ?+1
	#Make sure 1 <= [base] <= 16.
	.base   .z      ?+7
	.base   .z+1    .unary
	.base   .mxbase .notunary
	0-1     0       ?-2
.unary:
	#[base] = 1. Print 1's like hash marks.
	#Pad while [pad] > [num].
	.pad    .num    .unarypaddone
	0-2     .padchr ?+1
	.pad    .z+1    .unarypaddone
	0-2     .padchr ?-5
.unarypaddone:
	#Print the sign if we haven't yet.
	.sign   .z      ?+7
	0-2     .sign   ?+1
	.sign   .sign   ?+1
	#Print 1's while [num] > 0.
	.num    .z      .ret
	0-2     .hex+2  ?+1
	.num    .z+1    .ret
	0-2     .hex+2  ?-5
.notunary:
	#Calculate the most significant digit and how many digits are in [num].
	.den    .den    ?+1
	.lden   .lden   ?+1
	.base   .base   ?+1
	.base   .nbase  ?+1
	.chr    .chr    ?+1
	.chr    .z-1    ?+1
.firstloop:
	.digits .z-1    ?+1
	#num-=den
	.chr    .base   ?+1
	.num    .den   .firstdone
	.num    .z+1    ?+1
	.chr    .z-2    ?-8
	#den=base*lden-1
	.lden   .lden   ?+1
	.lden   .den    ?+1
	.den    .den    ?+1
	.den    .nnum   ?+1
	.den    .num    ?+1
	.den    .z+1    ?+1
	.num    .num    ?+1
	.num    .nnum   .firstloop
.firstdone:
	#Print padding.
	.pad    .digits ?+10
	0-2     .padchr ?+1
	.pad    .z+1    ?+4
	0-2     .padchr ?-5
	#Print the sign if we haven't yet.
	.sign   .z      ?+7
	0-2     .sign   ?+1
	.sign   .sign   ?+1
	#Correct [num], [base], and [den].
	.chr    .nbase  ?+1
	.base   .z+2    ?+1
	.tmp    .tmp    ?+1
	.tmp    .den    ?+1
	.num    .tmp    ?+1
	.den    .den    ?+1
	.den    .lden   .printdigit
.nextloop:
	#num=num*base
	.z+1    .base   ?+1
	.num    .lden   ?+1
	.nnum   .nnum   ?+1
	.nnum   .num    ?+1
	.num    .nnum   ?+1
	.z+1    .z-2    ?-5
.printdigit:
	#Print a digit.
	.chr    .nhex   ?+1
	0-2     .chr:0  ?+1
	.digits .z+1    .ret
	#digit=num/den
	.chr    .chr    ?+1
	.num    .den    .nextloop
	.num    .z+1    ?+1
	.chr    .z-2    ?-8
.ret:
	0       0       .arg7:7
	#Variables
	0-2 0-1 .z:0 1 2
	.nnum:0
	.num:0
	.mxbase:16-1
	.nbase:0
	.base:0
	.pad:0
	.padchr:32
	.digits:0
	.tmp:0
	.den:0
	.lden:0
	.white:32
	.nwhite:0-32
	.sign:0
	.nplus:0-43
	.nneg:0-45
	.hex:
		48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56
		56 57 57 97 97 98 98 99 99 100 100 101 101 102 102
	.nhex:0-.hex


#--------------------------------------------------------------------------------
#Comparisons


int.cmp:
	#Call  : 0 ? int.cmp a b lt eq gt
	#
	#Effect: For signed [a] and [b].
	#      : if [a]<[b]: goto lt
	#      : if [a]=[b]: goto eq
	#      : if [a]>[b]: goto gt
	#
	#Time  : 37
	#
	#Use [0] to get the calling address.
	.z      .arg2   ?+1
	0       .z      ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	0       0       ?+1
	#Get [a]
	.z      .z      ?+1
	.z      .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .z      ?+1
	.na     .na     ?+1
	.na     .p0:0   ?+1
	.a      .a      ?+1
	.a      .na     ?+1
	.na     .z+1    ?+1
	#Get [b]
	.z      .z      ?+1
	.z      .arg3:3 ?+1
	.p1     .p1     ?+1
	.p1     .z      ?+1
	.nb     .nb     ?+1
	.nb     .p1:0   ?+1
	.b      .b      ?+1
	.b      .nb     ?+1
	.nb     .z+1    ?+1
	.z      .z      ?+1
	#Check if [a]>=0 or [b]>=0.
	.a      .na     .age0
	.b      .nb     .alt0bge0
.age0bge0:
	.na     .nb     .ge
.alt0bge0:
	#If [a]<[b]
	.z      .arg4:4 .ret
.age0:
	.b      .nb     .age0bge0
.ge:
	.na     .z      .eq
.gt:
	#If [a]>[b]
	.z      .arg6:6 .ret
.eq:
	#If [a]=[b]
	.z      .arg5:5 .ret
.ret:
	.r0     .r0     ?+1
	.r0     .z      ?+1
	.z      .z      .r0:0
	#Variables
	.z:0 1 2
	.a:0
	.na:0
	.b:0
	.nb:0


int.min:
	#Call  : 0 ? int.min ret a b
	#
	#Effect: [ret] = min([a],[b]) for signed [a] and [b].
	#
	#Time  : 43
	#
	#Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get ret
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.na     .na     ?+1
	.na     .p3:0   ?+1
	.a      .a      ?+1
	.a      .na     ?+1
	#Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p4     .p4     ?+1
	.p4     .tmp    ?+1
	.nb     .nb     ?+1
	.nb     .p4:0   ?+1
	.b      .b      ?+1
	.b      .nb     ?+1
	#Set [ret]
	.tmp    .tmp    ?+1
	.val    .val    ?+1
	.a      .na     .age0
	.b      .nb     .alt0bge0
.age0bge0:
	.a      .b      ?+4
	.val    .nb     .ret
.alt0bge0:
	.b      .z      .beq0
	.val    .na     .ret
.beq0:
	.nb     .z      ?-5
	.val    .nb     .ret
.age0:
	.b      .nb     .age0bge0
	.a      .z      .aeq0
	.val    .nb     .ret
.aeq0:
	.na     .z      ?-5
	.val    .na     .ret
.ret:
	.val    .ret0:0 ?+1
	.tmp    .val    ?+1
	.ret1:1 .tmp    ?+1
	#Return
	0       0       .arg5:5
	#Variables
	.z:0 1 2
	.tmp:0
	.a:0
	.na:0
	.b:0
	.nb:0
	.val:0


int.max:
	#Call  : 0 ? int.max ret a b
	#
	#Effect: [ret] = max([a],[b]) for signed [a] and [b].
	#
	#Time  : 43
	#
	#Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get ret
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.na     .na     ?+1
	.na     .p3:0   ?+1
	.a      .a      ?+1
	.a      .na     ?+1
	#Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p4     .p4     ?+1
	.p4     .tmp    ?+1
	.nb     .nb     ?+1
	.nb     .p4:0   ?+1
	.b      .b      ?+1
	.b      .nb     ?+1
	#Set [ret]
	.tmp    .tmp    ?+1
	.val    .val    ?+1
	.a      .na     .age0
	.b      .nb     .alt0bge0
.age0bge0:
	.a      .b      ?+4
	.val    .na     .ret
.alt0bge0:
	.b      .z      .beq0
	.val    .nb     .ret
.beq0:
	.nb     .z      ?-5
	.val    .na     .ret
.age0:
	.b      .nb     .age0bge0
	.a      .z      .aeq0
	.val    .na     .ret
.aeq0:
	.na     .z      ?-5
	.val    .nb     .ret
.ret:
	.val    .ret0:0 ?+1
	.tmp    .val    ?+1
	.ret1:1 .tmp    ?+1
	#Return
	0       0       .arg5:5
	#Variables
	.z:0 1 2
	.tmp:0
	.a:0
	.na:0
	.b:0
	.nb:0
	.val:0


int.abs:
	#Call  : 0 ? int.abs ret a
	#
	#Effect: [ret] = abs([a])
	#
	#Time  : 30
	#
	#Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	#Get [ret]
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	#Get [val]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.nval   .nval   ?+1
	.nval   .p0:0   ?+1
	.val    .val    ?+1
	.val    .nval   ?+1
	#Check if [val] < 0.
	.tmp    .tmp    ?+1
	.nval   .z+1    ?+1
	.val    .nval   ?+4
	.tmp    .val    ?+4
	.nval   .z-1    ?+1
	#Set [ret].
	.tmp    .ret0:0 ?+1
	.nval   .tmp    ?+1
	.ret1:0 .nval   ?+1
	#Return
	0       0       .arg4:4
	#Variables
	0-1 .z:0 1 2
	.tmp:0
	.val:0
	.nval:0


#--------------------------------------------------------------------------------
#Integer Arithmetic


int.mul:
	#Call  : 0 ? int.mul high low a b
	#
	#Effect: [high] = [a]*[b] / MOD sign extended
	#      : [low]  = [a]*[b] % MOD
	#
	#Time  : 63 + 12.97*bits = 893
	#Time  : 47 +  7.21*bits = 508 if high=0
	#
	#Deconstruct [b] into a sum of fibonacci numbers (ex: 15=11+3+1). At the same
	#time, calculate [a]*[b] by building up a separate fibonacci sequence and adding
	#[a] to it every time a fibonacci number is a part of [b]'s sum.
	#
	#The actual time complexity is
	#
	#     n(F) = ceil(log_phi(F*sqrt(5)-1/2))
	#     time = 40 + 9*n(F)
	#     time = 34 + 5*n(F) if high=0
	#
	#Use [0] to get the calling address.
	.tmp    .tmp    .firstrun
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	#Get low
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.l0     .l0     ?+1
	.l0     .tmp    ?+1
	.l1     .l1     ?+1
	.l1     .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.a0     .a0     ?+1
	.a0     .tmp    ?+1
	.na     .na     ?+1
	.na     .a0:0   ?+1
	.a      .a      ?+1
	.a      .na     ?+1
	#Get -[b]. We will flip the sign of the result later.
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.b0     .b0     ?+1
	.b0     .tmp    ?+1
	.nb     .nb     ?+1
	.nb     .b0:0   ?+1
	.lval0  .lval0  ?+1
	.lval1  .lval1  ?+1
	#Get high. If [hret]=0, skip calculating the high value.
	.hret   .arg2:2 ?+1
	.hret   .z      .lowonly
	#------- Calculate [lval] and [hval] --------
	.hval0  .hval0  ?+1
	.hval1  .hval1  ?+1
	.nb     .z      .highzero
	.na     .z      .highzero
	#Record [b] for sign correction.
	.b      .b      ?+1
	.b      .nb     ?+1
	.nfib0  .fib0i  ?+1
	.fib0   .nfib0i ?+1
	.nfib1  .fib1i  ?+1
	.fib1   .nfib1i .hstart:.highfib0+9
	#During each loop, fibonacci decrement the [nb]. If [nb]>[fib], reduce [nb] and
	#add [a] to the return value. Then fibonacci increment the return value.
.highfib0:
	.fib1   .fib0   .highret
	.hval0  .hval1  ?+1
	#If [lval0]<=[lval1], check for a carry into [hval0].
	.lval0  .lval1  .highfib1-6
	#If [nb]>[fib0], add [a] to [lval0] and check for a carry into [hval0].
	.nb     .fib0   ?+16
	.lval0  .na     ?+7
	.hval0  .z+1    ?+1
	.nfib0  .nfib1  .highfib1
	.lval0  .z      ?-8
	.nfib0  .nfib1  .highfib1
	#[nb]<=[fib0], so restore [nb].
	.nb     .nfib0  ?+1
	.nfib0  .nfib1  .highfib1
	#Checking for a carry from [lval0]-[lval1].
	.lval0  .z      .highfib0+9
	.hval0  .z-1    .highfib0+9
.highfib1:
	.fib0   .fib1   .highret
	.hval1  .hval0  ?+1
	#If [lval1]<=[lval0], check for a carry into [hval1].
	.lval1  .lval0  .lowonly-6
	#If [nb]>[fib1], subtract [a] from [lval1] and check for a carry into [hval1].
	.nb     .fib1   ?+13
	.lval1  .a      ?+4
	.nfib1  .nfib0  .highfib0
	.lval1  .z      ?-5
	.hval1  .z-1    ?-8
	#[nb]<=[fib1], so restore [nb].
	.nb     .nfib1  ?+1
	.nfib1  .nfib0  .highfib0
	#Checking for a carry from [lval1]-[lval0].
	.lval1  .z      .highfib1+9
	.hval1  .z-1    .highfib1+9
	#---------- Only calculate [lval] -----------
.lowonly:
	.nb     .z      .lowret+3
	.nfib0  .fib0i  ?+1
	.fib0   .nfib0i ?+1
	.nfib1  .fib1i  ?+1
	.fib1   .nfib1i .lstart:.lowfib0+6
	#During each loop, fibonacci decrement the [nb]. If [nb]>[fib], reduce [nb] and
	#add [a] to the return value. Then fibonacci increment the return value.
.lowfib0:
	.fib1   .fib0   .lowret
	.lval0  .lval1  ?+1
	#If [nb]>[fib0], add [a] to [lval0].
	.nb     .fib0   ?+7
	.lval0  .na     ?+1
	.nfib0  .nfib1  .lowfib1
	.nb     .nfib0  ?+1
	.nfib0  .nfib1  .lowfib1
.lowfib1:
	.fib0   .fib1   .lowret
	.lval1  .lval0  ?+1
	#If [nb]>[fib1], subtract [a] from [lval1].
	.nb     .fib1   ?+7
	.lval1  .a      ?+1
	.nfib1  .nfib0  .lowfib0
	.nb     .nfib1  ?+1
	.nfib1  .nfib0  .lowfib0
	#-------------- Return values ---------------
.highret:
	#Calculate the low return value and subtract [a] from it.
	#Also check for final carries into the high value.
	.lval0  .lval1  ?+4
	.hval1  .z-1    ?+4
	.lval0  .z      ?-5
	.lval0  .na     ?+4
	.hval1  .z-1    ?+1
	.lval1  .lval1  ?+1
	#If [b]>=0, add [a] to [hval].
	.nb     .nb     ?+1
	.nb     .b      ?+1
	.nb     .b      ?+4
	.hval0  .na     ?+1
	#If [a]<0, subtract [b] from [hval].
	.na     .z+1    ?+1
	.a      .na     ?+4
	.hval0  .b      ?+1
.highzero:
	#Set [high]
	.h0     .h0     ?+1
	.h0     .hret   ?+1
	.h1     .h1     ?+1
	.h1     .hret   ?+1
	.hval0  .h0:0   ?+1
	.hval1  .hval0  ?+1
	.h1:0   .hval1  ?+1
	.hret   .hret   .lowret+3
.lowret:
	#Set [low]
	.lval0  .na     ?+1
	.lval1  .l0:0   ?+1
	.lval0  .lval1  ?+1
	.l1:0   .lval0  ?+1
	#Return
	0       0       .arg6:6
	#On the first run, calculate the largest fibonacci values that can fit in our
	#underlying integers.
	.fdif:.firstrun-int.mul-3
	.hdif:.highfib0-.highfib1
	.ldif:.lowfib0-.lowfib1
.firstrun:
	int.mul+2 .fdif ?+1
	.nfib1i .fib0i  .firstset1
	.fib0i  .nfib1i ?-5
.firstset0:
	#If [fib0]<[fib1], start on [fib1] loop.
	.fib1i  .nfib1i ?+1
	.fib0i  .fib1i  ?+1
	.nfib0i .fib0i  ?+1
	.hstart .hdif   ?+1
	.lstart .ldif   ?+1
	.fib1i  .z+1    ?+1
	.nfib1i .z-1    int.mul+3
.firstset1:
	.nfib0i .fib0i  ?+1
	.nfib1i .nfib0i ?+1
	.fib1i  .nfib1i ?+1
	.fib0i  .fib1i  ?+4
	.fib0i  .nfib1i .firstset1-6
	.nfib0i .nfib0i .firstset0+3
	#Variables
	0-2 0-1 .z:0 1
	.tmp:0
	.a:0
	.na:0
	.b:0
	.nb:0
	.hret:0
	.hval0:0
	.hval1:0
	.lval0:0
	.lval1:0
	.fib0i:1
	.nfib0i:0
	.fib1i:0
	.nfib1i:0-1
	.fib0:0
	.nfib0:0
	.fib1:1
	.nfib1:0-1


int.div:
	#Call  : 0 ? int.div quot rem num den
	#
	#Effect: [quot] = [num] / [den] rounded down
	#      : [rem]  = [num] % [den]
	#
	#Time  : 87 + 8.65*bits = 640
	#      : 72 + 7.21*bits = 533 if quot=0
	#
	#Use the fibonacci sequence to build up [den]. Then run the sequence in
	#reverse to calculate [num]%[den]. While calculating the remainder, calculate
	#the quotient [num]/[den] by using another, separate fibonacci sequence.
	#
	#The actual time complexity is
	#
	#     n(F) = ceil(log_phi(F*sqrt(5)-1/2))
	#     time = 71 + 6*n(F)
	#     time = 58 + 5*n(F) if quot=0
	#
	#Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	#Get rem
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.r2     .r2     ?+1
	.r2     .tmp    ?+1
	.r3     .r3     ?+1
	.r3     .tmp    ?+1
	#Get [den]
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.nden1  .nden1  ?+1
	.nden1  .p1:0   ?+1
	#Get abs([den]).
	.qsign  .qsign  ?+1
	.den1   .den1   ?+1
	.den1   .nden1  ?+1
	.nden1  .z+1    ?+1
	.den1   .nden1  .denabs
	.tmp    .tmp    ?+1
	.tmp    .den1   ?+1
	.nden1  .tmp    ?+1
	.qsign  .z-1    ?+7
.denabs:
	.nden1  .z-1    ?+1
	#If [den]=0, abort.
	.nden1  .z      .divz
	#Get [num]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1
	.num    .num    ?+1
	.num    .tmp    ?+1
	#Get abs([num]).
	.tmp    .z+1    ?+1
	.num    .tmp    .numabs
	.rsign  .num    ?+1
	.tmp    .rsign  ?+1
	.qsign  .z+1    ?+4
.numabs:
	.tmp    .z-1    ?+1
	.num    .num    ?+1
	.num    .tmp    ?+1
	#Get quot. If [qret]=0, skip calculating the quotient.
	.qret   .arg2:2 ?+1
	#If [den]*2>=MOD, we need to skip calculating the largest multiple of [den].
	.den0   .nden1  ?+1
	.nden1  .den0   ?+4
	.den1   .den1   ?+7
	.den1   .den1   .denhalf
	#Calculate the largest fibonacci multiple of [den].
	.nden1  .den0   .denstart0
	.den0   .nden1  ?-5
.denstart1:
	#[den1]>[den0]. Fill in the rest of the denominators.
	.den1   .nden1  ?+1
	.den0   .den1   ?+1
	.nden0  .den0   ?+1
	.qret   .z      .remden1+3
	.quot0  .quot0  .quotden1+6
.denstart0:
	#[den0]>=[den1]. Fill in the rest of the denominators.
	#If [den0]=[den1], we need to swap values.
	.nden0  .den0   ?+1
	.nden1  .nden0  ?+1
	.den1   .nden1  ?+1
	.den0   .den1   ?+4
	.den0   .nden1  .denhalf+9
	.nden0  .nden0  .denstart1+3
.denhalf:
	#[den]*2>=MOD. Manually set the denominators to +-[den].
	.nden0  .den0   ?+1
	.nden1  .nden0  ?+1
	.den1   .nden1  ?+1
	.qret   .z      .remden0+3
	.quot0  .quot0  .quotden0+6
	#-------- Calculate [rem] and [quot] --------
	#During each loop, fibonacci decrement the denominator and increment the
	#quotient. If [num]>[den], reduce [num] and increment the quotient by 1.
.quotden0:
	.den1   .den0   .quotret
	.quot0  .quot1  ?+1
	#Test if [num]>[den0].
	.num    .den0   ?+7
	.quot0  .z-1    ?+1
	.nden0  .nden1  .quotden1
	.num    .nden0  ?+1
	.nden0  .nden1  .quotden1
.quotden1:
	.den0   .den1   .quotret
	.quot1  .quot0  ?+1
	#Test if [num]>[den1].
	.num    .den1   ?+7
	.quot1  .z+1    ?+1
	.nden1  .nden0  .quotden0
	.num    .nden1  ?+1
	.nden1  .nden0  .quotden0
	#----------- Only calculate [rem] -----------
	#During each loop, fibonacci decrement the denominator. If [num]>[den],
	#reduce [num].
.remden0:
	.den1   .den0   .remret
	#Test if [num]>[den0].
	.num    .den0   ?+4
	.nden0  .nden1  .remden1
	.num    .nden0  ?+1
	.nden0  .nden1  .remden1
.remden1:
	.den0   .den1   .remret
	#Test if [num]>[den1].
	.num    .den1   ?+4
	.nden1  .nden0  .remden0
	.num    .nden1  ?+1
	.nden1  .nden0  .remden0
	#-------------- Return values ---------------
.quotret:
	#Set [quot]. Because of how additions are split, return [quot0]-[quot1]+1.
	.num    .den1   ?+4
	.quot0  .z-1    ?+7
	.num    .z      ?-5
	.num    .nden1  ?+1
	#If the signs of [num] and [den] mismatch, negate the quotient.
	.qsign  .z      .quotflip
	.quot1  .quot0  ?+1
	.tmp    .tmp    ?+1
	.tmp    .quot1  ?+1
	.quot0  .quot0  ?+1
	.quot0  .tmp    ?+1
	.quot1  .quot1  ?+1
.quotflip:
	.r0     .r0     ?+1
	.r0     .qret   ?+1
	.r1     .r1     ?+1
	.r1     .qret   ?+1
	.quot0  .r0:0   ?+1
	.quot1  .quot0  ?+1
	.r1:0   .quot1  ?+1
	.quot1  .quot1  ?+1
	.qret   .qret   .remret+9
.remret:
	#Set [rem].
	.num    .den1   ?+1
	.num    .z      ?+4
	.num    .nden1  ?+1
	#If [num]<0, negate [rem].
	.tmp    .tmp    ?+1
	.rsign  .z      .remflip
	.rsign  .rsign  ?+1
	.rsign  .num    ?+1
	.num    .num    ?+1
	.tmp    .rsign  ?+1
	.rsign  .rsign  ?+1
.remflip:
	.num    .r2:0   ?+1
	.tmp    .num    ?+1
	.r3:0   .tmp    ?+1
	#Return
	0       0       .arg6:6
.divz:
	#Division by 0. Abort.
	0       0       ?+1
	0-1     0       ?-2
	#Variables
	0-2 0-1 .z:0 1
	.tmp:0
	.num:0
	.den0:0
	.nden0:0
	.den1:0
	.nden1:0
	.qret:0
	.quot0:0
	.quot1:0
	.qsign:0
	.rsign:0


#--------------------------------------------------------------------------------
#Bitwise Arithmetic


int.shr:
	#Call  : 0 ? int.shr ret num shift
	#
	#Effect: [ret] = [num] >> [shift]. Sign extend if [num]<0.
	#
	#Time  : 43 + 8*bits = 555
	#
	#Use [0] to get the calling address.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#On first run, calculate how many bits we are using.
	.tmp    .tmp    .firsts:?+1
	.firsts .firstv ?+1
	.num    .z-1    ?+1
.firstloop:
	.num    .z      .firstdone
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.nbits  .z+1    ?+1
	.tmp    .tmp    .firstloop
.firstdone:
	#Get ret
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	.rval   .rval   ?+1
	#Get [shift]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.tmp    .tmp    ?+1
	#Get [num]
	.tmp    .arg3:3 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1
	.num    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .z+1    ?+1
	#If [num]<0, set [tmp]=~[num].
	.num    .tmp    .numpos
	.neg    .num    ?+1
	.tmp    .neg    ?+1
.numpos:
	#If [shift]>=[bits], abort.
	.shift  .nbits  ?+1
	.shift  .p1:0   .ret
	.num    .num    ?+1
	.num    .tmp    ?+1
	.num    .z+1    ?+1
.loop:
	#[num]<<=1. Carry into [rval].
	.num    .tmp    ?+4
	.rval   .z-1    ?+1
	.tmp    .tmp    ?+1
	.shift  .z+1    .ret+6
	#[rval]<<=1
	.tmp    .rval   ?+1
	.rval   .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .num    .loop
.ret:
	.tmp    .tmp    ?+1
	.shift  .shift  ?+1
	#If [num]<0, set [rval]=~[rval].
	.neg    .z      .notneg
	.neg    .neg    ?+1
	.num    .num    ?+1
	.num    .rval   ?+1
	.tmp    .num    ?+1
	.tmp    .z-1    ?+1
	.rval   .rval   ?+1
.notneg:
	#Set [ret].
	.rval   .ret0:0 ?+1
	.tmp    .rval   ?+1
	.ret1:0 .tmp    ?+1
	#Return
	0       0       .arg5:5
	#Variables
	0-1 .z:0 1 2
	.tmp:0
	.firstv:.firsts+1-.firstdone
	.nbits:0
	.num:0
	.rval:0
	.shift:0
	.neg:0


