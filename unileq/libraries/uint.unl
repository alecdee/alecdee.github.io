#|==============================================================================


Unsigned Integer Operations - v4.06

Author: Alec Dee - alecdee.github.io - akdee144@gmail.com


--------------------------------------------------------------------------------
Notes


This library provides functions for performing most of the common unsigned
integer operations. In particular, it handles: comparisons, arithmetic, and
bitwise operations.

All functions are bit length agnostic. They don't need to be modified even if
unileq uses a something other than 64 bit integers.

The 0 address will always be 0 upon function return, even if one of the return
value addresses is 0.

This library does not depend on any other libraries.

Worst case time complexity:


       Function  |  Time  |      O(n)
     ------------+--------+----------------
         print   |     -  |   -
          cmp    |    28  |  28
          min    |    34  |  34
          max    |    34  |  34
          set    |    24  |  24
          neg    |    25  |  25
          add    |    30  |  30
          sub    |    31  |  31
          mul    |   885  |  53 + 13*bits
          div    |   885  |  53 + 13*bits
          shl    |   168  |  40 +  2*bits
          shr    |   543  |  31 +  8*bits
          not    |    26  |  26
          and    |   485  |  44 +  7*bits
           or    |   486  |  45 +  7*bits
          xor    |   487  |  46 +  7*bits


--------------------------------------------------------------------------------
Index


Strings
uint.print num base padding padchar

Comparisons
uint.cmp a b lt eq gt
uint.min ret a b
uint.max ret a b

Integer Arithmetic
uint.set ret a
uint.neg ret a
uint.add ret a b
uint.sub ret a b
uint.mul high low a b
uint.div quot rem num den

Bitwise Arithmetic
uint.shl ret num shift
uint.shr ret num shift
uint.not ret a
uint.and ret a b
uint.or  ret a b
uint.xor ret a b


--------------------------------------------------------------------------------
Version History


1.00
     Initial version. Used uint.cmp, mem.get, and mem.set for proof of concept.
     Functions take tens of thousands of instructions.
2.00
     Unrolled functions so they don't use mem.get and mem.set.
     Functions take thousands of instructions.
3.00
     Optimized functions so they are all under or around 1K instructions.
3.01
     Optimized uint.and, or, and xor so the final value is stored in [a]. This
     removes the need for a temporary storage variable.
     Cleaned up uint.cmp so its branching is more straight forward.
3.02
     Optimized uint.set and uint.add to remove 1 instruction.
3.03
     Fixed an error in uint.mul when carrying from low to high. Removed need to
     offset [b] by 1 to check for carrying.
     Updated formatting for uint.cmp.
     Changed uint.div to abort with 0xd0 when dividing by 0.
     Optimized AND/OR/XOR by skipping first loop check.
3.04
     Optimized AND/OR/XOR by 18%. [a] and [b] only need to be offset by 1 on the
     first loop. This removes 2 decrement instructions per loop.
3.05
     Optimized AND/OR/XOR by 11%. Removed the iteration counter and instead
     check if [b]=0. We only set the bottom bit of [a] in 1/4 of cases, and only
     check if [b]=0 in 1/2 of cases. OR/XOR are based off of AND for their loop.
3.06
     Updated comments.
3.07
     Replaced average case time complexity with worst case time complexity.
     Standardized formatting to 8 spaces per column.
3.08
     Updated comments.
3.09
     Changed division-by-0 abort instruction.
     Made uint.shl bit length agnostic and lowered run time by 36%.
     Made uint.shr bit length agnostic and lowered run time by 11%.
3.10
     Added uint.min and uint.max.
     Updated timing measurements to not count calling instruction.
4.00
     Re-added calling instruction to timing measurements.
     Modified uint.shl to calculate bit length on first run.
     Updated descriptions for uint.mul, uint.div, and uint.and.
     Made uint.mul bit length agnostic and lowered run time by 5%.
     Made uint.div bit length agnostic and lowered run time by 6%.
     All functions are now bit length agnostic.
4.01
     Simplified loop termination in mul and div, and lowered run times by 5%.
     mul will skip calculating the high value if high=0. This is 44% faster.
     div will skip calculating the quotient if quot=0. This is 29% faster.
4.02
     Removed bit counting in uint.shl and lowered run time by 6%.
     Simplified uint.shr initialization.
4.03
     Removed a testing function for uint.shl that was included by accident.
     Cleaned up function descriptions.
4.04
     Added uint.print for string printing.
4.05
     Corrected timing for uint.cmp.
4.06
     Lowered run time of uint.min and uint.max from 38 to 34 instructions.
     Cleaned up variable names in uint.set, uint.neg, uint.add, and uint.sub.


--------------------------------------------------------------------------------
TODO


uint.shr
	Remove bit counting.
	Use the relation (n<<<k) - (n<<k) = n>>(64-k).
See if fibonacci multiplication is faster than uint.mul.
See if there's a way to perform functions for non 2^n mods.


|#


#--------------------------------------------------------------------------------
#Strings


uint.print:
	#Call  : 0 ? uint.print num base padding padchar
	#
	#Effect: Prints a number in an arbitrary base.
	#
	#This function works even if unileq's underlying integers are not a power of two.
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	#Get [num].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.nnum   .nnum   ?+1
	.nnum   .p0:0   ?+1
	.num    .num    ?+1
	.num    .nnum   ?+1
	#Get [pad].
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p2     .p2     ?+1
	.p2     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p2:0   ?+1
	.pad    .pad    ?+1
	.pad    .tmp    ?+1
	#Get [padchr].
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p3:0   ?+1
	.padchr .padchr ?+1
	.padchr .tmp    ?+1
	#Get [base].
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.nbase  .nbase  ?+1
	.nbase  .p1:0   ?+1
	.base   .base   ?+1
	.base   .nbase  ?+1
	.nbase  .base   ?+1
	#Make sure 1 <= [base] <= 16.
	.base   .z      ?+7
	.base   .z+1    .unary
	.base   .mxbase .notunary
	0-1     0       ?-2
.unary:
	#[base] = 1. Print 1's like hash marks.
	#Pad while [pad] > [num].
	.pad    .num    .unarypaddone
	0-2     .padchr ?+1
	.pad    .z+1    .unarypaddone
	0-2     .padchr ?-5
.unarypaddone:
	#Print 1's while [num] > 0.
	.num    .z      .ret
	0-2     .hex+2  ?+1
	.num    .z+1    .ret
	0-2     .hex+2  ?-5
.notunary:
	#Calculate the most significant digit and how many digits are in [num].
	.den    .den    ?+1
	.lden   .lden   ?+1
	.base   .base   ?+1
	.base   .nbase  ?+1
	.chr    .chr    ?+1
	.chr    .z-1    ?+1
.firstloop:
	.digits .z-1    ?+1
	#num-=den
	.chr    .base   ?+1
	.num    .den   .firstdone
	.num    .z+1    ?+1
	.chr    .z-2    ?-8
	#den=base*lden-1
	.lden   .lden   ?+1
	.lden   .den    ?+1
	.den    .den    ?+1
	.den    .nnum   ?+1
	.den    .num    ?+1
	.den    .z+1    ?+1
	.num    .num    ?+1
	.num    .nnum   .firstloop
.firstdone:
	#Print padding.
	.pad    .digits ?+10
	0-2     .padchr ?+1
	.pad    .z+1    ?+4
	0-2     .padchr ?-5
	#Correct [num], [base], and [den].
	.chr    .nbase  ?+1
	.base   .z+2    ?+1
	.tmp    .tmp    ?+1
	.tmp    .den    ?+1
	.num    .tmp    ?+1
	.den    .den    ?+1
	.den    .lden   .printdigit
.nextloop:
	#num=num*base
	.z+1    .base   ?+1
	.num    .lden   ?+1
	.nnum   .nnum   ?+1
	.nnum   .num    ?+1
	.num    .nnum   ?+1
	.z+1    .z-2    ?-5
.printdigit:
	#Print a digit.
	.chr    .nhex   ?+1
	0-2     .chr:0  ?+1
	.digits .z+1    .ret
	#digit=num/den
	.chr    .chr    ?+1
	.num    .den    .nextloop
	.num    .z+1    ?+1
	.chr    .z-2    ?-8
.ret:
	0       0       .arg6:6
	#Variables
	0-2 0-1 .z:0 1 2
	.nnum:0
	.num:0
	.mxbase:16-1
	.nbase:0
	.base:0
	.pad:0
	.padchr:32
	.digits:0
	.tmp:0
	.den:0
	.lden:0
	.hex:
		48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55
		56 56 57 57 65 65 66 66 67 67 68 68 69 69 70 70
	.nhex:0-.hex


#--------------------------------------------------------------------------------
#Comparisons


uint.cmp:
	#Call  : 0 ? uint.cmp a b lt eq gt
	#
	#Effect: if [a]<[b]: goto lt
	#      : if [a]=[b]: goto eq
	#      : if [a]>[b]: goto gt
	#
	#Time  : 29
	#
	#Setup stack pointer.
	.z      .arg2   ?+1
	0       .z      ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	0       0       ?+1
	#Get [a]
	.z      .z      ?+1
	.z      .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .z      ?+1
	.z      .z      ?+1
	.z      .p0:0   ?+1
	.a      .a      ?+1
	.a      .z      ?+1
	#Get [b]
	.z      .z      ?+1
	.z      .arg3:3 ?+1
	.b      .b      ?+1
	.b      .z      ?+1
	#Compute [a]-[b]
	.z      .z      ?+1
	.a      .b:0    .le
	#If [a]>[b]
	.z      .arg6:6 .ret
.le:
	.a      .z      .eq
	#If [a]<[b]
	.z      .arg4:4 .ret
.eq:
	#If [a]=[b]
	.z      .arg5:5 .ret
.ret:
	.r0     .r0     ?+1
	.r0     .z      ?+1
	.z      .z      .r0:0
	#Variables
	.a:0
	.z:0 1 2


uint.min:
	#Call  : 0 ? uint.min ret a b
	#
	#Effect: [ret] = min([a],[b])
	#
	#Time  : 34
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get ret
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.na     .na     ?+1
	.na     .p3:0   ?+1
	.a      .a      ?+1
	.a      .na     ?+1
	#Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p4     .p4     ?+1
	.p4     .tmp    ?+1
	#Set [ret]
	.tmp    .tmp    ?+1
	.a      .p4:0   ?+4
	.tmp    .a      ?+1
	.tmp    .ret0:0 ?+1
	.na     .tmp    ?+1
	.ret1:0 .na     ?+1
	#Return
	0       0       .arg5:5
	#Variables
	.off:2
	.tmp:0
	.a:0
	.na:0


uint.max:
	#Call  : 0 ? uint.max ret a b
	#
	#Effect: [ret] = max([a],[b])
	#
	#Time  : 34
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get ret
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.na     .na     ?+1
	.na     .p3:0   ?+1
	.a      .a      ?+1
	.a      .na     ?+1
	#Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p4     .p4     ?+1
	.p4     .tmp    ?+1
	#Set [ret]
	.a      .p4:0   ?+4
	.tmp    .tmp    ?+7
	.tmp    .tmp    ?+1
	.tmp    .a      ?+1
	.tmp    .ret0:0 ?+1
	.na     .tmp    ?+1
	.ret1:0 .na     ?+1
	#Return
	0       0       .arg5:5
	#Variables
	.off:2
	.tmp:0
	.a:0
	.na:0


#--------------------------------------------------------------------------------
#Integer Arithmetic


uint.set:
	#Call  : 0 ? uint.set ret a
	#
	#Effect: [ret] = [a]
	#
	#Time  : 24
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	#Get [ret]
	.ret0   .arg2:2 ?+1
	.ret1   .ret0   ?+1
	.ret2   .ret0   ?+1
	.tmp    .tmp    ?+1
	.tmp    .ret1   ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .tmp    ?+1
	#Set [ret]
	.tmp    .tmp    ?+1
	.tmp    .a0:0   ?+1
	.ret0:0 .ret1:0 ?+1
	.ret2:0 .tmp    ?+1
	0       0       .arg4:4
	#Variables
	.off:2
	.tmp:0


uint.neg:
	#Call  : 0 ? uint.neg ret a
	#
	#Effect: [ret] = -[a]
	#
	#Time  : 25
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	#Get [ret]
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .tmp    ?+1
	#Set [ret]
	.tmp    .tmp    ?+1
	.tmp    .a0:0   ?+1
	.tmp    .ret0:0 ?+1
	.val    .val    ?+1
	.val    .tmp    ?+1
	.ret1:0 .val    ?+1
	0       0       .arg4:4
	#Variables
	.off:2
	.val:0
	.tmp:0


uint.add:
	#Call  : 0 ? uint.add ret a b
	#
	#Effect: [ret] = [a] + [b]
	#
	#Time  : 30
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get [ret]
	.ret0   .arg2:2 ?+1
	.ret1   .ret0   ?+1
	.ret2   .ret0   ?+1
	.tmp    .tmp    ?+1
	.tmp    .ret1   ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .tmp    ?+1
	#Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.b0     .b0     ?+1
	.b0     .tmp    ?+1
	#Set [ret]
	.tmp    .tmp    ?+1
	.tmp    .a0:0   ?+1
	.tmp    .b0:0   ?+1
	.ret0:0 .ret1:0 ?+1
	.ret2:0 .tmp    ?+1
	#Return
	0       0       .arg5:5
	#Variables
	.off:2
	.tmp:0


uint.sub:
	#Call  : 0 ? uint.sub ret a b
	#
	#Effect: [ret]=[a]-[b]
	#
	#Time  : 31
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get [ret]
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .tmp    ?+1
	#Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.b0     .b0     ?+1
	.b0     .tmp    ?+1
	#Set [ret]
	.val    .val    ?+1
	.val    .ret1:0 ?+1
	.val    .b0:0   ?+1
	.tmp    .tmp    ?+1
	.tmp    .a0:0   ?+1
	.tmp    .val    ?+1
	.ret0:0 .tmp    ?+1
	#Return
	0       0       .arg5:5
	#Variables
	.off:2
	.val:0
	.tmp:0


uint.mul:
	#Call  : 0 ? uint.mul high low a b
	#
	#Effect: [high] = [a]*[b] / 2^64
	#      : [low]  = [a]*[b] % 2^64
	#
	#Time  : 53 + 13*bits = 885
	#Time  : 41 +  7*bits = 489 if high=0
	#
	#Use [hval] and [lval] to store the high and low values of [a]*[b]. During each
	#loop, shift [hval], [lval], and [b] to the left by 1. If the top bit of [b] is
	#set, add [a] to [lval] and carry into [hval].
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	#Get high. Only set if [hret]!=0.
	.hret   .hret   ?+1
	.hret   .arg2:2 ?+1
	#Get low
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.l0     .l0     ?+1
	.l0     .tmp    ?+1
	.l1     .l1     ?+1
	.l1     .tmp    ?+1
	#Get -[a]. Use -[a] for adding to [lval].
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.a0     .a0     ?+1
	.a0     .tmp    ?+1
	.a      .a      ?+1
	.a      .a0:0   ?+1
	#Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.b0     .b0     ?+1
	.b0     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .b0:0   ?+1
	.b      .b      ?+1
	.b      .tmp    ?+1
	#Offset [tmp] by 1 to force [b] to be odd.
	.tmp    .z+1    ?+1
	.lval   .lval   ?+1
	.hret   .z      .looplow
	#If -[a]=1, we have to manually set [low]=[b].
	.a      .z-1    ?+1
	.a      .z      .rethigh+3
	.hval   .hval   ?+1
	.lval   .z-1    .loophigh+3
	#-------- Calculate [lval] and [hval] --------
.loophigh:
	#If the highest bit of [b] is set, add [a] to [lval] and carry to [hval].
	.tmp    .b      ?+1
	.b      .tmp    ?+7
	.lval   .a      ?+10
	.hval   .z-1    ?+7
	#If [b]=0, we are done.
	.b      .z      .rethigh
	.lval   .z+1    ?+1
	#Left shift [hval].
	.htmp   .htmp   ?+1
	.htmp   .hval   ?+1
	.hval   .htmp   ?+1
	#Left shift [lval] and carry into [hval].
	.ltmp   .ltmp   ?+1
	.ltmp   .lval   ?+1
	.ltmp   .z+1    ?+1
	.lval   .ltmp   ?+4
	.hval   .z-1    ?+1
	.tmp    .tmp    .loophigh
	#----------- Only calculate [lval] -----------
.looplow:
	#If the highest bit of [b] is set, add [a] to [lval].
	.b      .tmp    ?+7
	.lval   .a      ?+1
	.tmp    .tmp    ?+7
	#If [b]=0, we are done.
	.b      .z      .retlow
	.tmp    .tmp    ?+1
	#Left shift [lval].
	.ltmp   .ltmp   ?+1
	.ltmp   .lval   ?+1
	.lval   .ltmp   ?+1
	.tmp    .b      .looplow
.rethigh:
	#Because we terminate 1 iteration late, return [htmp] and [ltmp] instead of
	#[hval] and [lval].
	.ltmp   .z-1    ?+7
	.ltmp   .ltmp   ?+1
	.htmp   .htmp   ?+1
	#Set [high]
	.h0     .h0     ?+1
	.h0     .hret   ?+1
	.h1     .h1     ?+1
	.h1     .hret   ?+1
	.tmp    .tmp    ?+1
	.tmp    .h0:0   ?+1
	.htmp   .tmp    ?+1
	.h1:0   .htmp   ?+1
.retlow:
	#Set [low]
	.b      .l0:0   ?+1
	.ltmp   .b      ?+1
	.l1:0   .ltmp   ?+1
	0       0       .arg6:6
	#Variables
	0-2 0-1 .z:0 1
	.tmp:0
	.a:0
	.b:0
	.hret:0
	.hval:0
	.htmp:0
	.lval:0
	.ltmp:0


uint.div:
	#Call  : 0 ? uint.div quot rem num den
	#
	#Effect: [quot] = [num] / [den] , rounded down
	#      : [rem]  = [num] % [den]
	#
	#Time  : 53 + 13*bits = 885
	#      : 45 +  9*bits = 621 if quot=0
	#
	#Every loop, shift [quot], [rem], and [num] left by 1. If the top bit of [num] is
	#set, add 1 to [rem]. Then, if [rem]>=[den], add 1 to [quot] and subtract [den]
	#from [rem].
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	#Get quot. Only set if qret!=0.
	.qret   .qret   ?+1
	.qret   .arg2:2 ?+1
	#Get rem
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.r2     .r2     ?+1
	.r2     .tmp    ?+1
	.r3     .r3     ?+1
	.r3     .tmp    ?+1
	#Get [den]
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.nden   .nden   ?+1
	.nden   .p1:0   ?+1
	#If [den]=0, abort.
	.nden   .z      .divz
	.nden   .z-1    ?+1
	.den    .den    ?+1
	.den    .nden   ?+1
	#Get [num]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1
	.num    .num    ?+1
	.num    .tmp    ?+1
	#Offset [tmp] by 1 to force [num] to be odd.
	.tmp    .z+1    ?+1
	.rem    .rem    ?+1
	.qret   .z      .looprem
	#-------- Calculate [rem] and [quot] --------
.loopquot:
	#[rem]+=[num]>>63, [num]<<=1. If [num]=0, abort.
	.num    .tmp    ?+4
	.rem    .z-1    ?+4
	.num    .z      .retquot
	#If [rem]>=[den], [quot]+=1
	.rem    .den    ?+7
	.rem    .z+1    ?+1
	.quot   .z-1    ?+4
	.rem    .nden   ?+1
	#[quot]<<=1.
	.qtmp   .qtmp   ?+1
	.qtmp   .quot   ?+1
	.quot   .qtmp   ?+1
	#[rem]<<=1
	.rtmp   .rtmp   ?+1
	.rtmp   .rem    ?+1
	.rem    .rtmp   ?+1
	.tmp    .tmp    ?+1
	.tmp    .num    .loopquot
	#----------- Only calculate [rem] -----------
.looprem:
	#[rem]+=[num]>>63, [num]<<=1. If [num]=0, abort.
	.num    .tmp    ?+4
	.rem    .z-1    ?+4
	.num    .z      .retrem
	#If [rem]>=[den], [quot]+=1
	.rem    .den    ?+7
	.rem    .z+1    ?+1
	.rtmp   .rtmp   ?+7
	.rem    .nden   ?+1
	.rtmp   .rtmp   ?+1
	#[rem]<<=1
	.rtmp   .rem    ?+1
	.rem    .rtmp   ?+1
	.tmp    .tmp    ?+1
	.tmp    .num    .looprem
.retquot:
	#Because we terminate 1 iteration late, return [qtmp] and [rtmp] instead of
	#[quot] and [rem].
	#Set [quot]
	.r0     .r0     ?+1
	.r0     .qret   ?+1
	.r1     .r1     ?+1
	.r1     .qret   ?+1
	.tmp    .tmp    ?+1
	.tmp    .r0:0   ?+1
	.qtmp   .tmp    ?+1
	.r1:0   .qtmp   ?+1
.retrem:
	#Set [rem]
	.num    .r2:0   ?+1
	.rtmp   .num    ?+1
	.r3:0   .rtmp   ?+1
	0       0       .arg6:6
.divz:
	#Abort
	0-1     0       ?-2
	#Variables
	0-2 0-1 .z:0 1
	.tmp:0
	.num:0
	.den:0
	.nden:0
	.qret:0
	.quot:0
	.qtmp:0
	.rem:0
	.rtmp:0


#--------------------------------------------------------------------------------
#Bitwise Arithmetic


uint.shl:
	#Call  : 0 ? uint.shl ret num shift
	#
	#Effect: [ret] = [num] << [shift]
	#
	#Time  : 56 + 16*((bits-1)/8) = 168
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get ret.
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	#Get [shift]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p1:0   ?+1
	.shift  .tmp    ?+1
	#Get -[num]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.num    .num    ?+1
	.num    .p0:0   .done8-3
	#[num]=[num]<<8. Abort if [num]=0.
.loop8:
	.num    .z      .ret
	.shift  .p8     .done8
	.tmp    .num    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.num    .tmp    ?+1
	.tmp    .num    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.num    .tmp    ?+1
	.tmp    .num    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .tmp    .loop8
.done8:
	.shift  .z      .loop8+6
	.shift  .n8     .done1
	#[num]=[num]<<3
	.shift  .z+2    .done3
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.num    .tmp    ?+1
	.tmp    .tmp    ?+1
	#[num]=[num]<<3
	.shift  .z+3    .done3
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.num    .tmp    ?+1
	.tmp    .tmp    ?+4
.done3:
	.shift  .z-3    ?+1
	#[num]=[num]<<1
	.shift  .z+1    .done1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .tmp    ?+1
	#[num]=[num]<<1
	.shift  .z+1    .done1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .tmp    ?+1
.ret:
	.shift  .shift  ?+1
.done1:
	#Set [ret].
	.tmp    .ret0:0 ?+1
	.num    .tmp    ?+1
	.ret1:0 .num    ?+1
	0       0       .arg5:5
	#Variables
	.num:0
	.shift:0
	.tmp:0
	0-3 0-2 0-1 .z:0 1 2 3
	.p8:8
	.n8:0-8


uint.shr:
	#Call  : 0 ? uint.shr ret num shift
	#
	#Effect: [ret] = [num] >> [shift]
	#
	#Time  : 31 + 8*bits = 543
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#On first run, calculate how many bits we are using.
	.tmp    .tmp    .firsts:?+1
	.firsts .firstv ?+1
	.num    .z-1    ?+1
.firstloop:
	.num    .z      .firstdone
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.nbits  .z+1    ?+1
	.tmp    .tmp    .firstloop
.firstdone:
	#Get ret
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	.rval   .rval   ?+1
	#Get [shift]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.tmp    .tmp    ?+1
	#If [shift]>=[bits], abort.
	.shift  .nbits  ?+1
	.shift  .p1:0   .ret
	#Get [num]
	.tmp    .arg3:3 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1
	.num    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .z+1    ?+1
.loop:
	#[num]<<=1. Carry into [rval].
	.num    .tmp    ?+4
	.rval   .z-1    ?+1
	.tmp    .tmp    ?+1
	.shift  .z+1    .ret+3
	#[rval]<<=1
	.tmp    .rval   ?+1
	.rval   .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .num    .loop
.ret:
	.shift  .shift  ?+1
	#Set [ret].
	.rval   .ret0:0 ?+1
	.tmp    .rval   ?+1
	.ret1:0 .tmp    ?+1
	0       0       .arg5:5
	#Variables
	.firstv:.firsts+1-.firstdone
	.nbits:0
	.num:0
	.rval:0
	.shift:0
	.tmp:0
	0-1 .z:0 1 2


uint.not:
	#Call  : 0 ? uint.not ret a
	#
	#Effect: [ret] = ~[a]
	#
	#Time  : 26
	#
	#Use the relation -1-[a]=~[a].
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	#Get [ret]
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p2     .p2     ?+1
	.p2     .tmp    ?+1
	#Set [ret]
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1
	.tmp    .p2:0   ?+1
	.tmp    .z+1    ?+1
	.ret    .ret    ?+1
	.ret    .tmp    ?+1
	.p1:0   .ret    ?+1
	0       0       .arg4:4
	#Variables
	.z:0 1 2
	.ret:0
	.tmp:0


uint.and:
	#Call  : 0 ? uint.and ret a b
	#
	#Effect: [ret] = [a] & [b]
	#
	#Time  : 44 + 7*bits = 485
	#
	#Make sure [a] and [b] are odd. Every loop, rotate [a] to the left and shift [b]
	#to the left. Depending on how the top bits of [a] and [b] are set, add 1 to [a].
	#Stop when [b]=0, and return [a]. Branches are organized in the loop to minimize
	#instructions.
	#
	#Setup stack pointer.
	.atmp   .arg2   ?+1
	0       .atmp   ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get [ret]
	.atmp   .atmp   ?+1
	.atmp   .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .atmp   ?+1
	.ret1   .ret1   ?+1
	.ret1   .atmp   ?+1
	#Get [a]
	.atmp   .atmp   ?+1
	.atmp   .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .atmp   ?+1
	.atmp   .atmp   ?+1
	.atmp   .a0:0   ?+1
	.a      .a      ?+1
	.a      .atmp   ?+1
	#Get [b]
	.btmp   .btmp   ?+1
	.btmp   .arg4:4 ?+1
	.b0     .b0     ?+1
	.b0     .btmp   ?+1
	.btmp   .btmp   ?+1
	.btmp   .b0:0   ?+1
	.b      .btmp   ?+1
	#Perform the first iteration outside of the loop. We need [a] and [b] to be odd
	#so that we can efficiently check for carrying in the loop. Flag if the top bit
	#needs to be set at the end.
	        .atmp   .z+1    ?+1
	        .btmp   .z+1    ?+1
	        .a      .atmp   .l0x
	.l1x:   .b      .btmp   .l00
	.l11:   .atmp   .atmp   .loop
	.l0x:   .b      .btmp   .l00
	.l00:   .top    .z+1    ?+1
	        .atmp   .atmp   .loop
	#Loop until [b]=0.
.loop:
	#Prepare [b] for shift and carry.
	        .btmp   .btmp   ?+1
	        .btmp   .b      ?+1
	#Left shift [a] and [b] and check for carry. Set low bit of [a] if needed.
	#If [b]<=[btmp] and [b]=0, then we are done.
	        .b      .btmp   .f0x
	.f1x:   .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f11:   .a      .z-1    .f00
	.f0x:   .b      .z      .done
	        .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f00:   .atmp   .atmp   .loop
.done:
	#Check if the top bit needs to be zero'd.
	.top    .top:.z ?+4
	.a      .btmp   ?+1
	#We have [a]=[a]&[b]+-[btmp] and [btmp]=2^(n-1).
	.a      .ret0:0 ?+1
	.btmp   .a      ?+1
	.ret1:0 .btmp   ?+1
	0       0       .arg5:5
	#Variables
	0-1 .z:0 1 2
	.a:0 .atmp:0
	.b:0 .btmp:0


uint.or:
	#Call  : 0 ? uint.or ret a b
	#
	#Effect: [ret] = [a] | [b]
	#
	#Time  : 45 + 7*bits = 486
	#
	#Use bitwise AND and the relation A|B=-1-(~A)&(~B).
	#
	#Setup stack pointer.
	.atmp   .arg2   ?+1
	0       .atmp   ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get [ret]
	.atmp   .atmp   ?+1
	.atmp   .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .atmp   ?+1
	.ret1   .ret1   ?+1
	.ret1   .atmp   ?+1
	#Get -[a]
	.atmp   .atmp   ?+1
	.atmp   .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .atmp   ?+1
	.a      .a      ?+1
	.a      .a0:0   ?+1
	.atmp   .atmp   ?+1
	.atmp   .a      ?+1
	#Get -[b]
	.btmp   .btmp   ?+1
	.btmp   .arg4:4 ?+1
	.b0     .b0     ?+1
	.b0     .btmp   ?+1
	.b      .b0:0   ?+1
	.btmp   .btmp   ?+1
	.btmp   .b      ?+1
	#Perform the first iteration outside of the loop. We need [a] and [b] to be odd
	#so that we can efficiently check for carrying in the loop. Flag if the top bit
	#needs to be set.
	        .a      .z+1    ?+1
	        .b      .z+1    ?+1
	        .a      .atmp   .l0x
	.l1x:   .b      .btmp   .l00
	.l11:   .atmp   .atmp   .loop
	.l0x:   .b      .btmp   .l00
	.l00:   .top    .z+1    ?+1
	        .atmp   .atmp   .loop
	#Loop until [b]=0.
.loop:
	#Prepare [b] for shift and carry.
	        .btmp   .btmp   ?+1
	        .btmp   .b      ?+1
	#Left shift [a] and [b] and check for carry. Set low bit of [a] if needed.
	#If [b]<=[btmp] and [b]=0, then we are done.
	        .b      .btmp   .f0x
	.f1x:   .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f11:   .a      .z-1    .f00
	.f0x:   .b      .z      .done
	        .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f00:   .atmp   .atmp   .loop
.done:
	#Check if the top bit needs to be zero'd.
	.top    .top:.z ?+4
	.a      .btmp   ?+1
	#We have [a]=[a]&[b]+-[btmp] and [btmp]=2^(n-1).
	#A|B=-1-(~A)&(~B)
	.a      .z-1    ?+1
	.btmp   .ret0:0 ?+1
	.a      .btmp   ?+1
	.ret1:0 .a      ?+1
	0       0       .arg5:5
	#Variables
	0-1 .z:0 1 2
	.a:0 .atmp:0
	.b:0 .btmp:0


uint.xor:
	#Call  : 0 ? uint.xor ret a b
	#
	#Effect: [ret] = [a] ^ [b]
	#
	#Time  : 46 + 7*bits = 487
	#
	#Use bitwise AND and the relation A^B=A+B-2(A&B).
	#
	#Setup stack pointer.
	.atmp   .arg2   ?+1
	0       .atmp   ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get [ret]
	.atmp   .atmp   ?+1
	.atmp   .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .atmp   ?+1
	.ret1   .ret1   ?+1
	.ret1   .atmp   ?+1
	#Get [a]
	.atmp   .atmp   ?+1
	.atmp   .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .atmp   ?+1
	.atmp   .atmp   ?+1
	.atmp   .a0:0   ?+1
	.a      .a      ?+1
	.a      .atmp   ?+1
	#Get [b]
	.btmp   .btmp   ?+1
	.btmp   .arg4:4 ?+1
	.b0     .b0     ?+1
	.b0     .btmp   ?+1
	.btmp   .btmp   ?+1
	.btmp   .b0:0   ?+1
	.b      .btmp   ?+1
	#Perform the first iteration outside of the loop. We need [a] and [b] to be odd
	#so that we can efficiently check for carrying in the loop.
	.off    .off    ?+1
	.off    .atmp   ?+1
	.off    .btmp   ?+1
	.atmp   .z+1    ?+1
	.btmp   .z+1    ?+1
	.a      .atmp   ?+1
	.b      .btmp   ?+1
	.atmp   .atmp   .loop
	#Loop until [b]=0.
.loop:
	#Prepare [b] for shift and carry.
	        .btmp   .btmp   ?+1
	        .btmp   .b      ?+1
	#Left shift [a] and [b] and check for carry. Set low bit of [a] if needed.
	#If [b]<=[btmp] and [b]=0, then we are done.
	        .b      .btmp   .f0x
	.f1x:   .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f11:   .a      .z-1    .f00
	.f0x:   .b      .z      .done
	        .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f00:   .atmp   .atmp   .loop
.done:
	#We have [a]=[a]&[b]+-[btmp] and [btmp]=2^(n-1).
	#Use A^B=A+B-2(A&B).
	.off    .a      ?+1
	.off    .ret0:0 ?+1
	.a      .off    ?+1
	.ret1:0 .a      ?+1
	0       0       .arg5:5
	#Variables
	0-1 .z:0 1 2
	.a:0 .atmp:0
	.b:0 .btmp:0
	.off:0


