#|==============================================================================


Unsigned Integer Operations - v5.02

Author: Alec Dee - alecdee.github.io - akdee144@gmail.com


--------------------------------------------------------------------------------
Notes


uint.unl provides functions for performing most of the common unsigned integer
operations. In particular, it handles: comparisons, arithmetic, and bitwise
operations.

Unileq typically uses integers modulo 2^64. However, string printing, integer
arithmetic, and comparisons will work with any modulo. Bitwise functions, on
the other hand, require integers modulo 2^n.

The 0 address will always be 0 upon function return, even if one of the return
value addresses is 0.

This library does not depend on any other libraries.

Worst case time complexity:


       Function  |    Complexity     |  Instructions
                 |                   |   (64 bits)
     ------------+-------------------+----------------
         print   |  --               |       --
          cmp    |  29               |       29
          min    |  34               |       34
          max    |  34               |       34
          set    |  24               |       24
          neg    |  25               |       25
          add    |  30               |       30
          sub    |  31               |       31
          mul    |  55 + 12.97*bits  |      885
          div    |  61 +  8.65*bits  |      614
          gcd    |  41 + 20.17*bits  |     1332
          shl    |  40 +  2.00*bits  |      168
          shr    |  31 +  8.00*bits  |      543
          not    |  26               |       26
          and    |  37 +  7.00*bits  |      485
           or    |  38 +  7.00*bits  |      486
          xor    |  39 +  7.00*bits  |      487


--------------------------------------------------------------------------------
Index


Strings
uint.print [num] [base] [padding] [padchar]

Comparisons
uint.cmp [a] [b] lt eq gt
uint.min [ret] [a] [b]
uint.max [ret] [a] [b]

Integer Arithmetic
uint.set [ret]  [a]
uint.neg [ret]  [a]
uint.add [ret]  [a] [b]
uint.sub [ret]  [a] [b]
uint.mul [high] [low] [a] [b]
uint.div [quot] [rem] [num] [den]

Number Theory
uint.gcd [ret] [a] [b]

Bitwise Arithmetic
uint.shl [ret] [num] [shift]
uint.shr [ret] [num] [shift]
uint.not [ret] [a]
uint.and [ret] [a] [b]
uint.or  [ret] [a] [b]
uint.xor [ret] [a] [b]


--------------------------------------------------------------------------------
Version History


1.00
     Initial version. Used uint.cmp, mem.get, and mem.set for proof of concept.
     Functions take tens of thousands of instructions.
2.00
     Unrolled functions so they don't use mem.get and mem.set.
     Functions take thousands of instructions.
3.00
     Optimized functions so they are all under or around 1K instructions.
3.01
     Optimized uint.and, uint.or, and uint.xor so the final value is stored in
     [a]. This removes the need for a temporary storage variable.
     Cleaned up uint.cmp so its branching is more straight forward.
3.02
     Optimized uint.set and uint.add to remove 1 instruction.
3.03
     Fixed an error in uint.mul when carrying from low to high. Removed need to
     offset [b] by 1 to check for carrying.
     Updated formatting for uint.cmp.
     Changed uint.div to abort with 0xd0 when dividing by 0.
     Optimized uint.and, uint.or, and uint.xor by skipping first loop check.
3.04
     Optimized uint.and, uint.or, and uint.xor by 18%. [a] and [b] only need to
     be offset by 1 on the first loop. This removes 2 decrement instructions per
     loop.
3.05
     Optimized uint.and, uint.or, and uint.xor by 11%. Removed the iteration
     counter and instead check if [b]=0. We only set the bottom bit of [a] in
     1/4 of cases, and only check if [b]=0 in 1/2 of cases. uint.or and uint.xor
     are based off of uint.and for their loop.
3.06
     Updated comments.
3.07
     Replaced average case time complexity with worst case time complexity.
     Standardized formatting to 8 spaces per column.
3.08
     Updated comments.
3.09
     Changed division-by-0 abort instruction.
     Made uint.shl bit length agnostic and lowered run time by 36%.
     Made uint.shr bit length agnostic and lowered run time by 11%.
3.10
     Added uint.min and uint.max.
     Updated timing measurements to not count calling instruction.
4.00
     Re-added calling instruction to timing measurements.
     Modified uint.shl to calculate bit length on first run.
     Updated descriptions for uint.mul, uint.div, and uint.and.
     Made uint.mul bit length agnostic and lowered run time by 5%.
     Made uint.div bit length agnostic and lowered run time by 6%.
     All functions are now bit length agnostic.
4.01
     Simplified loop termination in uint.mul and uint.div. This is 5% faster.
     uint.mul will skip calculating [high] if high=0. This is 44% faster.
     uint.div will skip calculating [quot] if quot=0. This is 29% faster.
4.02
     Removed bit counting in uint.shl and lowered run time by 6%.
     Simplified uint.shr initialization.
4.03
     Removed a testing function for uint.shl that was included by accident.
     Cleaned up function descriptions.
4.04
     Added uint.print for string printing.
4.05
     Corrected timing for uint.cmp.
4.06
     Lowered run time of uint.min and uint.max from 38 to 34 instructions.
     Cleaned up variable names in uint.set, uint.neg, uint.add, and uint.sub.
     Removed unnecessary instructions from uint.mul when high=0.
5.00
     All integer arithmetic functions work with any modulo on the underlying
     integers.
     Remade uint.div and uint.mul to work with any modulo, even non
     power-of-two, by using the fibonacci sequence.
     uint.div is 30% faster and uint.mul is 1% faster.
     Cleaned up version history comments.
5.01
     Added uint.gcd.
5.02
     Improved the time complexity of uint.gcd from log^2(n) to log(n).

--------------------------------------------------------------------------------
TODO


Simplify uint.div den0/nden1 calculation. Get rid of exception for den*2>=MOD.

Optimize uint.mul to have same time complexity as uint.div. Unroll first loop
iteration and simplify loop?


|#


#--------------------------------------------------------------------------------
#Strings


uint.print:
	#Call  : 0 ? uint.print num base padding padchar
	#
	#Effect: Prints a number in an arbitrary base.
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	#Get [num].
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.nnum   .nnum   ?+1
	.nnum   .p0:0   ?+1
	.num    .num    ?+1
	.num    .nnum   ?+1
	#Get [pad].
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p2     .p2     ?+1
	.p2     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p2:0   ?+1
	.pad    .pad    ?+1
	.pad    .tmp    ?+1
	#Get [padchr].
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p3:0   ?+1
	.padchr .padchr ?+1
	.padchr .tmp    ?+1
	#Get [base].
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.nbase  .nbase  ?+1
	.nbase  .p1:0   ?+1
	.base   .base   ?+1
	.base   .nbase  ?+1
	.nbase  .base   ?+1
	#Make sure 1 <= [base] <= 16.
	.base   .z      ?+7
	.base   .z+1    .unary
	.base   .mxbase .notunary
	0-1     0       ?-2
.unary:
	#[base] = 1. Print 1's like hash marks.
	#Pad while [pad] > [num].
	.pad    .num    .unarypaddone
	0-2     .padchr ?+1
	.pad    .z+1    .unarypaddone
	0-2     .padchr ?-5
.unarypaddone:
	#Print 1's while [num] > 0.
	.num    .z      .ret
	0-2     .hex+2  ?+1
	.num    .z+1    .ret
	0-2     .hex+2  ?-5
.notunary:
	#Calculate the most significant digit and how many digits are in [num].
	.den    .den    ?+1
	.lden   .lden   ?+1
	.base   .base   ?+1
	.base   .nbase  ?+1
	.chr    .chr    ?+1
	.chr    .z-1    ?+1
.firstloop:
	.digits .z-1    ?+1
	#num-=den
	.chr    .base   ?+1
	.num    .den   .firstdone
	.num    .z+1    ?+1
	.chr    .z-2    ?-8
	#den=base*lden-1
	.lden   .lden   ?+1
	.lden   .den    ?+1
	.den    .den    ?+1
	.den    .nnum   ?+1
	.den    .num    ?+1
	.den    .z+1    ?+1
	.num    .num    ?+1
	.num    .nnum   .firstloop
.firstdone:
	#Print padding.
	.pad    .digits ?+10
	0-2     .padchr ?+1
	.pad    .z+1    ?+4
	0-2     .padchr ?-5
	#Correct [num], [base], and [den].
	.chr    .nbase  ?+1
	.base   .z+2    ?+1
	.tmp    .tmp    ?+1
	.tmp    .den    ?+1
	.num    .tmp    ?+1
	.den    .den    ?+1
	.den    .lden   .printdigit
.nextloop:
	#num=num*base
	.z+1    .base   ?+1
	.num    .lden   ?+1
	.nnum   .nnum   ?+1
	.nnum   .num    ?+1
	.num    .nnum   ?+1
	.z+1    .z-2    ?-5
.printdigit:
	#Print a digit.
	.chr    .nhex   ?+1
	0-2     .chr:0  ?+1
	.digits .z+1    .ret
	#digit=num/den
	.chr    .chr    ?+1
	.num    .den    .nextloop
	.num    .z+1    ?+1
	.chr    .z-2    ?-8
.ret:
	0       0       .arg6:6
	#Variables
	0-2 0-1 .z:0 1 2
	.tmp:0
	.nnum:0
	.num:0
	.mxbase:16-1
	.nbase:0
	.base:0
	.pad:0
	.padchr:32
	.digits:0
	.den:0
	.lden:0
	.hex:
		48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55
		56 56 57 57 65 65 66 66 67 67 68 68 69 69 70 70
	.nhex:0-.hex


#--------------------------------------------------------------------------------
#Comparisons


uint.cmp:
	#Call  : 0 ? uint.cmp a b lt eq gt
	#
	#Effect: if [a]<[b]: goto lt
	#      : if [a]=[b]: goto eq
	#      : if [a]>[b]: goto gt
	#
	#Time  : 29
	#
	#Setup stack pointer.
	.z      .arg2   ?+1
	0       .z      ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	0       0       ?+1
	#Get [a]
	.z      .z      ?+1
	.z      .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .z      ?+1
	.z      .z      ?+1
	.z      .p0:0   ?+1
	.a      .a      ?+1
	.a      .z      ?+1
	#Get [b]
	.z      .z      ?+1
	.z      .arg3:3 ?+1
	.b      .b      ?+1
	.b      .z      ?+1
	#Compute [a]-[b]
	.z      .z      ?+1
	.a      .b:0    .le
	#If [a]>[b]
	.z      .arg6:6 .ret
.le:
	.a      .z      .eq
	#If [a]<[b]
	.z      .arg4:4 .ret
.eq:
	#If [a]=[b]
	.z      .arg5:5 .ret
.ret:
	.r0     .r0     ?+1
	.r0     .z      ?+1
	.z      .z      .r0:0
	#Variables
	.z:0 1 2
	.a:0


uint.min:
	#Call  : 0 ? uint.min ret a b
	#
	#Effect: [ret] = min([a],[b])
	#
	#Time  : 34
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get ret
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.na     .na     ?+1
	.na     .p3:0   ?+1
	.a      .a      ?+1
	.a      .na     ?+1
	#Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p4     .p4     ?+1
	.p4     .tmp    ?+1
	#Set [ret]
	.tmp    .tmp    ?+1
	.a      .p4:0   ?+4
	.tmp    .a      ?+1
	.tmp    .ret0:0 ?+1
	.na     .tmp    ?+1
	.ret1:0 .na     ?+1
	#Return
	0       0       .arg5:5
	#Variables
	.off:2
	.tmp:0
	.a:0
	.na:0


uint.max:
	#Call  : 0 ? uint.max ret a b
	#
	#Effect: [ret] = max([a],[b])
	#
	#Time  : 34
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get ret
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.na     .na     ?+1
	.na     .p3:0   ?+1
	.a      .a      ?+1
	.a      .na     ?+1
	#Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p4     .p4     ?+1
	.p4     .tmp    ?+1
	#Set [ret]
	.a      .p4:0   ?+4
	.tmp    .tmp    ?+7
	.tmp    .tmp    ?+1
	.tmp    .a      ?+1
	.tmp    .ret0:0 ?+1
	.na     .tmp    ?+1
	.ret1:0 .na     ?+1
	#Return
	0       0       .arg5:5
	#Variables
	.off:2
	.tmp:0
	.a:0
	.na:0


#--------------------------------------------------------------------------------
#Integer Arithmetic


uint.set:
	#Call  : 0 ? uint.set ret a
	#
	#Effect: [ret] = [a]
	#
	#Time  : 24
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	#Get [ret]
	.ret0   .arg2:2 ?+1
	.ret1   .ret0   ?+1
	.ret2   .ret0   ?+1
	.tmp    .tmp    ?+1
	.tmp    .ret1   ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .tmp    ?+1
	#Set [ret]
	.tmp    .tmp    ?+1
	.tmp    .a0:0   ?+1
	.ret0:0 .ret1:0 ?+1
	.ret2:0 .tmp    ?+1
	#Return
	0       0       .arg4:4
	#Variables
	.off:2
	.tmp:0


uint.neg:
	#Call  : 0 ? uint.neg ret a
	#
	#Effect: [ret] = -[a]
	#
	#Time  : 25
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	#Get [ret]
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .tmp    ?+1
	#Set [ret]
	.tmp    .tmp    ?+1
	.tmp    .a0:0   ?+1
	.tmp    .ret0:0 ?+1
	.val    .val    ?+1
	.val    .tmp    ?+1
	.ret1:0 .val    ?+1
	#Return
	0       0       .arg4:4
	#Variables
	.off:2
	.tmp:0
	.val:0


uint.add:
	#Call  : 0 ? uint.add ret a b
	#
	#Effect: [ret] = [a] + [b]
	#
	#Time  : 30
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get [ret]
	.ret0   .arg2:2 ?+1
	.ret1   .ret0   ?+1
	.ret2   .ret0   ?+1
	.tmp    .tmp    ?+1
	.tmp    .ret1   ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .tmp    ?+1
	#Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.b0     .b0     ?+1
	.b0     .tmp    ?+1
	#Set [ret]
	.tmp    .tmp    ?+1
	.tmp    .a0:0   ?+1
	.tmp    .b0:0   ?+1
	.ret0:0 .ret1:0 ?+1
	.ret2:0 .tmp    ?+1
	#Return
	0       0       .arg5:5
	#Variables
	.off:2
	.tmp:0


uint.sub:
	#Call  : 0 ? uint.sub ret a b
	#
	#Effect: [ret]=[a]-[b]
	#
	#Time  : 31
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .off    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get [ret]
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .tmp    ?+1
	#Get [b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.b0     .b0     ?+1
	.b0     .tmp    ?+1
	#Set [ret]
	.val    .val    ?+1
	.val    .ret1:0 ?+1
	.val    .b0:0   ?+1
	.tmp    .tmp    ?+1
	.tmp    .a0:0   ?+1
	.tmp    .val    ?+1
	.ret0:0 .tmp    ?+1
	#Return
	0       0       .arg5:5
	#Variables
	.off:2
	.tmp:0
	.val:0


uint.mul:
	#Call  : 0 ? uint.mul high low a b
	#
	#Effect: [high] = [a]*[b] / MOD
	#      : [low]  = [a]*[b] % MOD
	#
	#Time  : 55 + 12.97*bits = 885
	#Time  : 47 +  7.21*bits = 508 if high=0
	#
	#Deconstruct [b] into a sum of fibonacci numbers (ex: 15=11+3+1). At the same
	#time, calculate [a]*[b] by building up a separate fibonacci sequence and adding
	#[a] to it every time a fibonacci number is a part of [b]'s sum.
	#
	#The actual time complexity is
	#
	#     n(F) = ceil(log_phi(F*sqrt(5)-1/2))
	#     time = 32 + 9*n(F)
	#     time = 34 + 5*n(F) if high=0
	#
	#Setup stack pointer.
	.tmp    .tmp    .firstrun
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	#Get low
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.l0     .l0     ?+1
	.l0     .tmp    ?+1
	.l1     .l1     ?+1
	.l1     .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.a0     .a0     ?+1
	.a0     .tmp    ?+1
	.na     .na     ?+1
	.na     .a0:0   ?+1
	.a      .a      ?+1
	.a      .na     ?+1
	#Get -[b]. We will flip the sign of the result later.
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.b0     .b0     ?+1
	.b0     .tmp    ?+1
	.nb     .nb     ?+1
	.nb     .b0:0   ?+1
	.lval0  .lval0  ?+1
	.lval1  .lval1  ?+1
	#Get high. If [hret]=0, skip calculating the high value.
	.hret   .arg2:2 ?+1
	.hret   .z      .lowonly
	#------- Calculate [lval] and [hval] --------
	.hval0  .hval0  ?+1
	.hval1  .hval1  ?+1
	.nb     .z      .highzero
	.na     .z      .highzero
	.nfib0  .fib0i  ?+1
	.fib0   .nfib0i ?+1
	.nfib1  .fib1i  ?+1
	.fib1   .nfib1i .hstart:.highfib0+9
	#During each loop, fibonacci decrement the [nb]. If [nb]>[fib], reduce [nb] and
	#add [a] to the return value. Then fibonacci increment the return value.
.highfib0:
	.fib1   .fib0   .highret
	.hval0  .hval1  ?+1
	#If [lval0]<=[lval1], check for a carry into [hval0].
	.lval0  .lval1  .highfib1-6
	#If [nb]>[fib0], add [a] to [lval0] and check for a carry into [hval0].
	.nb     .fib0   ?+16
	.lval0  .na     ?+7
	.hval0  .z+1    ?+1
	.nfib0  .nfib1  .highfib1
	.lval0  .z      ?-8
	.nfib0  .nfib1  .highfib1
	#[nb]<=[fib0], so restore [nb].
	.nb     .nfib0  ?+1
	.nfib0  .nfib1  .highfib1
	#Checking for a carry from [lval0]-[lval1].
	.lval0  .z      .highfib0+9
	.hval0  .z-1    .highfib0+9
.highfib1:
	.fib0   .fib1   .highret
	.hval1  .hval0  ?+1
	#If [lval1]<=[lval0], check for a carry into [hval1].
	.lval1  .lval0  .lowonly-6
	#If [nb]>[fib1], subtract [a] from [lval1] and check for a carry into [hval1].
	.nb     .fib1   ?+13
	.lval1  .a      ?+4
	.nfib1  .nfib0  .highfib0
	.lval1  .z      ?-5
	.hval1  .z-1    ?-8
	#[nb]<=[fib1], so restore [nb].
	.nb     .nfib1  ?+1
	.nfib1  .nfib0  .highfib0
	#Checking for a carry from [lval1]-[lval0].
	.lval1  .z      .highfib1+9
	.hval1  .z-1    .highfib1+9
	#---------- Only calculate [lval] -----------
.lowonly:
	.nb     .z      .lowret+3
	.nfib0  .fib0i  ?+1
	.fib0   .nfib0i ?+1
	.nfib1  .fib1i  ?+1
	.fib1   .nfib1i .lstart:.lowfib0+6
	#During each loop, fibonacci decrement the [nb]. If [nb]>[fib], reduce [nb] and
	#add [a] to the return value. Then fibonacci increment the return value.
.lowfib0:
	.fib1   .fib0   .lowret
	.lval0  .lval1  ?+1
	#If [nb]>[fib0], add [a] to [lval0].
	.nb     .fib0   ?+7
	.lval0  .na     ?+1
	.nfib0  .nfib1  .lowfib1
	.nb     .nfib0  ?+1
	.nfib0  .nfib1  .lowfib1
.lowfib1:
	.fib0   .fib1   .lowret
	.lval1  .lval0  ?+1
	#If [nb]>[fib1], subtract [a] from [lval1].
	.nb     .fib1   ?+7
	.lval1  .a      ?+1
	.nfib1  .nfib0  .lowfib0
	.nb     .nfib1  ?+1
	.nfib1  .nfib0  .lowfib0
	#-------------- Return values ---------------
.highret:
	#Calculate the low return value and subtract [a] from it.
	#Also check for final carries into the high value.
	.lval0  .lval1  ?+4
	.hval1  .z-1    ?+4
	.lval0  .z      ?-5
	.lval0  .na     ?+4
	.hval1  .z-1    ?+1
	.lval1  .lval1  ?+1
	.hval0  .na     ?+1
.highzero:
	#Set [high]
	.h0     .h0     ?+1
	.h0     .hret   ?+1
	.h1     .h1     ?+1
	.h1     .hret   ?+1
	.hval0  .h0:0   ?+1
	.hval1  .hval0  ?+1
	.h1:0   .hval1  ?+1
	.hret   .hret   .lowret+3
.lowret:
	#Set [low]
	.lval0  .na     ?+1
	.lval1  .l0:0   ?+1
	.lval0  .lval1  ?+1
	.l1:0   .lval0  ?+1
	#Return
	0       0       .arg6:6
	#On the first run, calculate the largest fibonacci values that can fit in our
	#underlying integers.
	.fdif:.firstrun-uint.mul-3
	.hdif:.highfib0-.highfib1
	.ldif:.lowfib0-.lowfib1
.firstrun:
	uint.mul+2 .fdif ?+1
	.nfib1i .fib0i  .firstset1
	.fib0i  .nfib1i ?-5
.firstset0:
	#If [fib0]<[fib1], start on [fib1] loop.
	.fib1i  .nfib1i ?+1
	.fib0i  .fib1i  ?+1
	.nfib0i .fib0i  ?+1
	.hstart .hdif   ?+1
	.lstart .ldif   ?+1
	.fib1i  .z+1    ?+1
	.nfib1i .z-1    uint.mul+3
.firstset1:
	.nfib0i .fib0i  ?+1
	.nfib1i .nfib0i ?+1
	.fib1i  .nfib1i ?+1
	.fib0i  .fib1i  ?+4
	.fib0i  .nfib1i .firstset1-6
	.nfib0i .nfib0i .firstset0+3
	#Variables
	0-2 0-1 .z:0 1
	.tmp:0
	.a:0
	.na:0
	.nb:0
	.hret:0
	.hval0:0
	.hval1:0
	.lval0:0
	.lval1:0
	.fib0i:1
	.nfib0i:0
	.fib1i:0
	.nfib1i:0-1
	.fib0:0
	.nfib0:0
	.fib1:1
	.nfib1:0-1


uint.div:
	#Call  : 0 ? uint.div quot rem num den
	#
	#Effect: [quot] = [num] / [den] rounded down
	#      : [rem]  = [num] % [den]
	#
	#Time  : 61 + 8.65*bits = 614
	#      : 52 + 7.21*bits = 513 if quot=0
	#
	#Use the fibonacci sequence to build up [den]. Then run the sequence in
	#reverse to calculate [num]%[den]. While calculating the remainder, calculate
	#the quotient [num]/[den] by using another, separate fibonacci sequence.
	#
	#The actual time complexity is
	#
	#     n(F) = ceil(log_phi(F*sqrt(5)-1/2))
	#     time = 45 + 6*n(F)
	#     time = 38 + 5*n(F) if quot=0
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	.tmp    .z-2    ?+1
	0       .tmp    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	.arg6   0       ?+1
	#Get rem
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.r2     .r2     ?+1
	.r2     .tmp    ?+1
	.r3     .r3     ?+1
	.r3     .tmp    ?+1
	#Get [num]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1
	.num    .num    ?+1
	.num    .tmp    ?+1
	#Get [den]
	.tmp    .tmp    ?+1
	.tmp    .arg5:5 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.nden1  .nden1  ?+1
	.nden1  .p1:0   ?+1
	#If [den]=0, abort.
	.nden1  .z      .divz
	#Get quot. If [qret]=0, skip calculating the quotient.
	.qret   .arg2:2 ?+1
	#If [den]*2>=MOD, we need to skip calculating the largest multiple of [den].
	.den0   .nden1  ?+1
	.nden1  .den0   ?+4
	.den1   .den1   ?+7
	.den1   .den1   .denhalf
	#Calc largest fibonacci multiple of [den].
	.nden1  .den0   .denstart0
	.den0   .nden1  ?-5
.denstart1:
	#[den1]>[den0]. Fill in the rest of the denominators.
	.den1   .nden1  ?+1
	.den0   .den1   ?+1
	.nden0  .den0   ?+1
	.qret   .z      .remden1+3
	.quot0  .quot0  .quotden1+6
.denstart0:
	#[den0]>=[den1]. Fill in the rest of the denominators.
	#If [den0]=[den1], we need to swap values.
	.nden0  .den0   ?+1
	.nden1  .nden0  ?+1
	.den1   .nden1  ?+1
	.den0   .den1   ?+4
	.den0   .nden1  .denhalf+9
	.nden0  .nden0  .denstart1+3
.denhalf:
	#[den]*2>=MOD. Manually set the denominators to +-[den].
	.nden0  .den0   ?+1
	.nden1  .nden0  ?+1
	.den1   .nden1  ?+1
	.qret   .z      .remden0+3
	.quot0  .quot0  .quotden0+6
	#-------- Calculate [rem] and [quot] --------
	#During each loop, fibonacci decrement the denominator and increment the
	#quotient. If [num]>[den], reduce [num] and increment the quotient by 1.
.quotden0:
	.den1   .den0   .quotret
	.quot0  .quot1  ?+1
	#Test if [num]>[den0].
	.num    .den0   ?+7
	.quot0  .z-1    ?+1
	.nden0  .nden1  .quotden1
	.num    .nden0  ?+1
	.nden0  .nden1  .quotden1
.quotden1:
	.den0   .den1   .quotret
	.quot1  .quot0  ?+1
	#Test if [num]>[den1].
	.num    .den1   ?+7
	.quot1  .z+1    ?+1
	.nden1  .nden0  .quotden0
	.num    .nden1  ?+1
	.nden1  .nden0  .quotden0
	#----------- Only calculate [rem] -----------
	#During each loop, fibonacci decrement the denominator. If [num]>[den],
	#reduce [num].
.remden0:
	.den1   .den0   .remret
	#Test if [num]>[den0].
	.num    .den0   ?+4
	.nden0  .nden1  .remden1
	.num    .nden0  ?+1
	.nden0  .nden1  .remden1
.remden1:
	.den0   .den1   .remret
	#Test if [num]>[den1].
	.num    .den1   ?+4
	.nden1  .nden0  .remden0
	.num    .nden1  ?+1
	.nden1  .nden0  .remden0
	#-------------- Return values ---------------
.quotret:
	#Set [quot]. Because of how additions are split, return [quot0]-[quot1]+1.
	.num    .den1   ?+4
	.quot0  .z-1    ?+7
	.num    .z      ?-5
	.num    .nden1  ?+1
	.r0     .r0     ?+1
	.r0     .qret   ?+1
	.r1     .r1     ?+1
	.r1     .qret   ?+1
	.quot0  .r0:0   ?+1
	.quot1  .quot0  ?+1
	.r1:0   .quot1  ?+1
	.quot1  .quot1  ?+1
	.qret   .qret   .remret+9
.remret:
	#Set [rem].
	.num    .den1   ?+1
	.num    .z      ?+4
	.num    .nden1  ?+1
	.num    .r2:0   ?+1
	.tmp    .tmp    ?+1
	.tmp    .num    ?+1
	.r3:0   .tmp    ?+1
	#Return
	0       0       .arg6:6
.divz:
	#Division by 0. Abort.
	0       0       ?+1
	0-1     0       ?-2
	#Variables
	0-2 0-1 .z:0 1
	.tmp:0
	.num:0
	.den0:0
	.nden0:0
	.den1:0
	.nden1:0
	.qret:0
	.quot0:0
	.quot1:0


#--------------------------------------------------------------------------------
#Number Theory


uint.gcd:
	#Call  : 0 ? uint.gcd ret a b
	#
	#Effect: [ret] = gcd([a],[b])
	#
	#Time  : 41 + 20.17*bits = 1332
	#
	#Calculate the greatest common denominator using the Euclidean algorithm. By
	#dynamically calculating the modulus, this algorithm has log time complexity.
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get ret
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p3     .p3     ?+1
	.p3     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p3:0   ?+1
	.a      .a      ?+1
	.a      .tmp    ?+1
	#Get -[b]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p4     .p4     ?+1
	.p4     .tmp    ?+1
	.nmul0  .nmul0  ?+1
	.nmul0  .p4:0   ?+1
	#Make sure [a]!=0 and [b]!=0, or we'll loop forever.
	.nmul0  .z      .ret
	.a      .z      .ret
.loop:
	#[mul1]=[b].
	.mul1   .mul1   ?+1
	.mul1   .nmul0  ?+1
	.nmul0  .nmul0  ?+1
	#Find the largest multiple of [b]<=[a], and reduce [a] as well.
.mulloop:
	.a      .mul1   .muldone
	.a      .mul1   .muldone
	.a      .mul1   .muldone
	.nmul0  .mul1   ?+1
	.mul1   .nmul0  .mulloop
.muldone:
	.mul0   .nmul0  ?+1
	.nmul1  .nmul1  ?+1
	.nmul1  .mul1   .mod1+9
	#Calculate [a]%[b].
.mod0:
	.mul1   .mul0   .moddone
	#Test if [a]>[mul0].
	.a      .mul0   ?+4
	.nmul0  .nmul1  .mod1
	.a      .nmul0  ?+1
	.nmul0  .nmul1  .mod1
.mod1:
	.mul0   .mul1   .moddone
	#Test if [a]>[mul1].
	.a      .mul1   ?+4
	.nmul1  .nmul0  .mod0
	.a      .nmul1  ?+1
	.nmul1  .nmul0  .mod0
.moddone:
	#If [mul1]=[b]<=[a], then [a]%[b]=0, so return [b].
	.mul1   .a      .ret
	#Otherwise, swap [a] and [b], and continue the algorithm.
	.nmul0  .a      ?+1
	.a      .a      ?+1
	.a      .nmul1  .loop
.ret:
	#Return the gcd. Either [a]=0 or [nmul0]=-[b]=0, so [a]-(-[b])=gcd.
	.a      .ret0:0 ?+1
	.nmul0  .a      ?+1
	.ret1:0 .nmul0  ?+1
	0       0       .arg5:5
	#Variables
	.z:0 1 2
	.a:0
	.tmp:0
	.nmul0:0
	.nmul1:0
	.mul0:0
	.mul1:0


#--------------------------------------------------------------------------------
#Bitwise Arithmetic


uint.shl:
	#Call  : 0 ? uint.shl ret num shift
	#
	#Effect: [ret] = [num] << [shift]
	#
	#Time  : 56 + 16*((bits-1)/8) = 168
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get ret.
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	#Get [shift]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p1:0   ?+1
	.shift  .tmp    ?+1
	#Get -[num]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.num    .num    ?+1
	.num    .p0:0   .done8-3
	#[num]=[num]<<8. Abort if [num]=0.
.loop8:
	.num    .z      .ret
	.shift  .p8     .done8
	.tmp    .num    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.num    .tmp    ?+1
	.tmp    .num    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.num    .tmp    ?+1
	.tmp    .num    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .tmp    .loop8
.done8:
	.shift  .z      .loop8+6
	.shift  .n8     .done1
	#[num]=[num]<<3
	.shift  .z+2    .done3
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.num    .tmp    ?+1
	.tmp    .tmp    ?+1
	#[num]=[num]<<3
	.shift  .z+3    .done3
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.num    .tmp    ?+1
	.tmp    .tmp    ?+4
.done3:
	.shift  .z-3    ?+1
	#[num]=[num]<<1
	.shift  .z+1    .done1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .tmp    ?+1
	#[num]=[num]<<1
	.shift  .z+1    .done1
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .tmp    ?+1
.ret:
	.shift  .shift  ?+1
.done1:
	#Set [ret].
	.tmp    .ret0:0 ?+1
	.num    .tmp    ?+1
	.ret1:0 .num    ?+1
	#Return
	0       0       .arg5:5
	#Variables
	0-3 0-2 0-1 .z:0 1 2 3
	.p8:8
	.n8:0-8
	.num:0
	.shift:0
	.tmp:0


uint.shr:
	#Call  : 0 ? uint.shr ret num shift
	#
	#Effect: [ret] = [num] >> [shift]
	#
	#Time  : 31 + 8*bits = 543
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#On first run, calculate how many bits we are using.
	.tmp    .tmp    .firsts:?+1
	.firsts .firstv ?+1
	.num    .z-1    ?+1
.firstloop:
	.num    .z      .firstdone
	.tmp    .num    ?+1
	.num    .tmp    ?+1
	.nbits  .z+1    ?+1
	.tmp    .tmp    .firstloop
.firstdone:
	#Get ret
	.tmp    .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .tmp    ?+1
	.ret1   .ret1   ?+1
	.ret1   .tmp    ?+1
	.rval   .rval   ?+1
	#Get [shift]
	.tmp    .tmp    ?+1
	.tmp    .arg4:4 ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	.tmp    .tmp    ?+1
	#If [shift]>=[bits], abort.
	.shift  .nbits  ?+1
	.shift  .p1:0   .ret
	#Get [num]
	.tmp    .arg3:3 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1
	.num    .num    ?+1
	.num    .tmp    ?+1
	.tmp    .z+1    ?+1
.loop:
	#[num]<<=1. Carry into [rval].
	.num    .tmp    ?+4
	.rval   .z-1    ?+1
	.tmp    .tmp    ?+1
	.shift  .z+1    .ret+3
	#[rval]<<=1
	.tmp    .rval   ?+1
	.rval   .tmp    ?+1
	.tmp    .tmp    ?+1
	.tmp    .num    .loop
.ret:
	.shift  .shift  ?+1
	#Set [ret].
	.rval   .ret0:0 ?+1
	.tmp    .rval   ?+1
	.ret1:0 .tmp    ?+1
	#Return
	0       0       .arg5:5
	#Variables
	0-1 .z:0 1 2
	.tmp:0
	.firstv:.firsts+1-.firstdone
	.nbits:0
	.num:0
	.rval:0
	.shift:0


uint.not:
	#Call  : 0 ? uint.not ret a
	#
	#Effect: [ret] = ~[a]
	#
	#Time  : 26
	#
	#Use the relation -1-[a]=~[a].
	#
	#Setup stack pointer.
	.tmp    .tmp    ?+1
	.tmp    .arg2   ?+1
	0       .tmp    ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	#Get [ret]
	.tmp    .tmp    ?+1
	.tmp    .arg2:2 ?+1
	.p0     .p0     ?+1
	.p0     .tmp    ?+1
	.p1     .p1     ?+1
	.p1     .tmp    ?+1
	#Get [a]
	.tmp    .tmp    ?+1
	.tmp    .arg3:3 ?+1
	.p2     .p2     ?+1
	.p2     .tmp    ?+1
	#Set [ret]
	.tmp    .tmp    ?+1
	.tmp    .p0:0   ?+1
	.tmp    .p2:0   ?+1
	.tmp    .z+1    ?+1
	.ret    .ret    ?+1
	.ret    .tmp    ?+1
	.p1:0   .ret    ?+1
	#Return
	0       0       .arg4:4
	#Variables
	.z:0 1 2
	.tmp:0
	.ret:0


uint.and:
	#Call  : 0 ? uint.and ret a b
	#
	#Effect: [ret] = [a] & [b]
	#
	#Time  : 37 + 7*bits = 485
	#
	#Make sure [a] and [b] are odd. Every loop, rotate [a] to the left and shift [b]
	#to the left. Depending on how the top bits of [a] and [b] are set, add 1 to [a].
	#Stop when [b]=0, and return [a]. Branches are organized in the loop to minimize
	#instructions.
	#
	#Setup stack pointer.
	.atmp   .arg2   ?+1
	0       .atmp   ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get [ret]
	.atmp   .atmp   ?+1
	.atmp   .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .atmp   ?+1
	.ret1   .ret1   ?+1
	.ret1   .atmp   ?+1
	#Get [a]
	.atmp   .atmp   ?+1
	.atmp   .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .atmp   ?+1
	.atmp   .atmp   ?+1
	.atmp   .a0:0   ?+1
	.a      .a      ?+1
	.a      .atmp   ?+1
	#Get [b]
	.btmp   .btmp   ?+1
	.btmp   .arg4:4 ?+1
	.b0     .b0     ?+1
	.b0     .btmp   ?+1
	.btmp   .btmp   ?+1
	.btmp   .b0:0   ?+1
	.b      .btmp   ?+1
	#Perform the first iteration outside of the loop. We need [a] and [b] to be odd
	#so that we can efficiently check for carrying in the loop. Flag if the top bit
	#needs to be set at the end.
	        .atmp   .z+1    ?+1
	        .btmp   .z+1    ?+1
	        .a      .atmp   .l0x
	.l1x:   .b      .btmp   .l00
	.l11:   .atmp   .atmp   .loop
	.l0x:   .b      .btmp   .l00
	.l00:   .top    .z+1    ?+1
	        .atmp   .atmp   .loop
	#Loop until [b]=0.
.loop:
	#Prepare [b] for shift and carry.
	        .btmp   .btmp   ?+1
	        .btmp   .b      ?+1
	#Left shift [a] and [b] and check for carry. Set low bit of [a] if needed.
	#If [b]<=[btmp] and [b]=0, then we are done.
	        .b      .btmp   .f0x
	.f1x:   .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f11:   .a      .z-1    .f00
	.f0x:   .b      .z      .done
	        .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f00:   .atmp   .atmp   .loop
.done:
	#Check if the top bit needs to be zero'd.
	.top    .top:.z ?+4
	.a      .btmp   ?+1
	#We have [a]=[a]&[b]+-[btmp] and [btmp]=2^(n-1).
	.a      .ret0:0 ?+1
	.btmp   .a      ?+1
	.ret1:0 .btmp   ?+1
	#Return
	0       0       .arg5:5
	#Variables
	0-1 .z:0 1 2
	.a:0
	.atmp:0
	.b:0
	.btmp:0


uint.or:
	#Call  : 0 ? uint.or ret a b
	#
	#Effect: [ret] = [a] | [b]
	#
	#Time  : 38 + 7*bits = 486
	#
	#Use bitwise AND and the relation A|B=-1-(~A)&(~B).
	#
	#Setup stack pointer.
	.atmp   .arg2   ?+1
	0       .atmp   ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get [ret]
	.atmp   .atmp   ?+1
	.atmp   .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .atmp   ?+1
	.ret1   .ret1   ?+1
	.ret1   .atmp   ?+1
	#Get -[a]
	.atmp   .atmp   ?+1
	.atmp   .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .atmp   ?+1
	.a      .a      ?+1
	.a      .a0:0   ?+1
	.atmp   .atmp   ?+1
	.atmp   .a      ?+1
	#Get -[b]
	.btmp   .btmp   ?+1
	.btmp   .arg4:4 ?+1
	.b0     .b0     ?+1
	.b0     .btmp   ?+1
	.b      .b0:0   ?+1
	.btmp   .btmp   ?+1
	.btmp   .b      ?+1
	#Perform the first iteration outside of the loop. We need [a] and [b] to be odd
	#so that we can efficiently check for carrying in the loop. Flag if the top bit
	#needs to be set.
	        .a      .z+1    ?+1
	        .b      .z+1    ?+1
	        .a      .atmp   .l0x
	.l1x:   .b      .btmp   .l00
	.l11:   .atmp   .atmp   .loop
	.l0x:   .b      .btmp   .l00
	.l00:   .top    .z+1    ?+1
	        .atmp   .atmp   .loop
	#Loop until [b]=0.
.loop:
	#Prepare [b] for shift and carry.
	        .btmp   .btmp   ?+1
	        .btmp   .b      ?+1
	#Left shift [a] and [b] and check for carry. Set low bit of [a] if needed.
	#If [b]<=[btmp] and [b]=0, then we are done.
	        .b      .btmp   .f0x
	.f1x:   .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f11:   .a      .z-1    .f00
	.f0x:   .b      .z      .done
	        .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f00:   .atmp   .atmp   .loop
.done:
	#Check if the top bit needs to be zero'd.
	.top    .top:.z ?+4
	.a      .btmp   ?+1
	#We have [a]=[a]&[b]+-[btmp] and [btmp]=2^(n-1).
	#A|B=-1-(~A)&(~B)
	.a      .z-1    ?+1
	.btmp   .ret0:0 ?+1
	.a      .btmp   ?+1
	.ret1:0 .a      ?+1
	#Return
	0       0       .arg5:5
	#Variables
	0-1 .z:0 1 2
	.a:0
	.atmp:0
	.b:0
	.btmp:0


uint.xor:
	#Call  : 0 ? uint.xor ret a b
	#
	#Effect: [ret] = [a] ^ [b]
	#
	#Time  : 39 + 7*bits = 487
	#
	#Use bitwise AND and the relation A^B=A+B-2(A&B).
	#
	#Setup stack pointer.
	.atmp   .arg2   ?+1
	0       .atmp   ?+1
	0       .z+2    ?+1
	.arg2   0       ?+1
	.arg3   0       ?+1
	.arg4   0       ?+1
	.arg5   0       ?+1
	#Get [ret]
	.atmp   .atmp   ?+1
	.atmp   .arg2:2 ?+1
	.ret0   .ret0   ?+1
	.ret0   .atmp   ?+1
	.ret1   .ret1   ?+1
	.ret1   .atmp   ?+1
	#Get [a]
	.atmp   .atmp   ?+1
	.atmp   .arg3:3 ?+1
	.a0     .a0     ?+1
	.a0     .atmp   ?+1
	.atmp   .atmp   ?+1
	.atmp   .a0:0   ?+1
	.a      .a      ?+1
	.a      .atmp   ?+1
	#Get [b]
	.btmp   .btmp   ?+1
	.btmp   .arg4:4 ?+1
	.b0     .b0     ?+1
	.b0     .btmp   ?+1
	.btmp   .btmp   ?+1
	.btmp   .b0:0   ?+1
	.b      .btmp   ?+1
	#Perform the first iteration outside of the loop. We need [a] and [b] to be odd
	#so that we can efficiently check for carrying in the loop.
	.off    .off    ?+1
	.off    .atmp   ?+1
	.off    .btmp   ?+1
	.atmp   .z+1    ?+1
	.btmp   .z+1    ?+1
	.a      .atmp   ?+1
	.b      .btmp   ?+1
	.atmp   .atmp   .loop
	#Loop until [b]=0.
.loop:
	#Prepare [b] for shift and carry.
	        .btmp   .btmp   ?+1
	        .btmp   .b      ?+1
	#Left shift [a] and [b] and check for carry. Set low bit of [a] if needed.
	#If [b]<=[btmp] and [b]=0, then we are done.
	        .b      .btmp   .f0x
	.f1x:   .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f11:   .a      .z-1    .f00
	.f0x:   .b      .z      .done
	        .atmp   .a      ?+1
	        .a      .atmp   .f00
	.f00:   .atmp   .atmp   .loop
.done:
	#We have [a]=[a]&[b]+-[btmp] and [btmp]=2^(n-1).
	#Use A^B=A+B-2(A&B).
	.off    .a      ?+1
	.off    .ret0:0 ?+1
	.a      .off    ?+1
	.ret1:0 .a      ?+1
	#Return
	0       0       .arg5:5
	#Variables
	0-1 .z:0 1 2
	.a:0
	.atmp:0
	.b:0
	.btmp:0
	.off:0


