<!DOCTYPE HTML>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Weight Balanced Trees in Python</title>
	<link rel="stylesheet" href="../style/style.css" type="text/css">
	<script type="text/javascript" src="../style/style.js"></script>
</head>
<body>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Header ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div id="header"><a href="../index.html">Alec Dee's Homepage</a></div>

<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Introduction ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div class="content"><h1>Introduction</h1>
<p>Searching for self balancing trees on the internet will yield plenty of results for red-black
and AVL trees, but almost no results for
<a href="https://en.wikipedia.org/wiki/Weight-balanced_tree">weight balanced trees</a>. This is
unfortunate, as weight balanced tree's provide the same logarithmic performance as red-black and AVL
trees, with one important benefit: they can also lexicographically index elements in logarithmic
time.</p>
<br>
<p>For instance, finding the i'th element of an AVL tree will take <i>O(n)</i> time. But with a
weight balanced tree, it will only take <i>O(log(n))</i> time.</p>
<br>
<p>In this article, we will provide a feature complete implementation of a weight balanced tree in
python. We'll also show how it works and how it stacks up against other trees.</p>
<br>
</div>

<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Implementation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div class="content"><h1>Implementation</h1>
<p>The full implementation can be downloaded here: <a href="./WBTree.py">WBTree.py</a></p>
<br>
<p>And this is an example of using the tree:</p>
<br>
<div class="codeblock langpython">tree=WBTree()
tree.add((5,"Friday"))
tree.add((3,"Wednesday"))
tree.add((1,"Monday"))
tree.add((6,"Saturday"))
tree.add((2,"Tuesday"))
tree.add((4,"Thursday"))
tree.remove((6,"Saturday"))

print("Iterate:")
for node in tree:
	print("{0}: {1}".format(*node.value))

print("Index:")
for i in range(len(tree)):
	node=tree[i]
	print("{0}: {1}".format(*node.value))</div>
<br>
<p>Console output:</p>
<br>
<div class="consoleblock">Iterate:
1: Monday
2: Tuesday
3: Wednesday
4: Thursday
5: Friday

Index:
1: Monday
2: Tuesday
3: Wednesday
4: Thursday
5: Friday</div>
<br>
<p>The tree also accepts custom sorting functions and can be toggled to accept (or reject) duplicate
elements</p>
<br>
</div>

<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Performance ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div class="content"><h1>Performance</h1>
<p>Our performance data is generated from speedtest.py in <a href="./testing.zip">testing.zip</a>
using the python3 runtime. Our own timing is denoted by "Dee", with timings from various other
authors denoted by their screen names.</p>
<br>
<p>Timing was conducted by</p>
<br>
<table class="listtable">
<tr><td>&bull;</td><td>Adding 100,000 nodes to a tree</td></tr>
<tr><td>&bull;</td><td>Searching for each node</td></tr>
<tr><td>&bull;</td><td>Removing all nodes from the tree</td></tr>
</table>
<br>
<p>If an implementation didn't support searching or removing, those timings were omitted.</p>
<br>
<table class="datatable headerrow">
<tr><td>Algorithm</td><td>Rank</td><td>Add (s)</td><td>Remove (s)</td><td>Search (s)</td></tr>
<tr><td><a href="https://www.geeksforgeeks.org/avl-tree-set-1-insertion">Pathak AVL</a></td><td>11</td><td>2.25</td><td>-</td><td>-</td></tr>
<tr><td><a href="https://www.hashcollision.org/hkn/python/red_black/red_black.py">Yoo RB</a></td><td>10</td><td>0.82</td><td>-</td><td>-</td></tr>
<tr><td><a href="https://gist.github.com/girish3/a8e3931154af4da89995">Girish AVL</a></td><td>9</td><td>5.27</td><td>3.55</td><td>-</td></tr>
<tr><td><a href="http://code.activestate.com/recipes/576817-red-black-tree">Reid RB</a></td><td>8</td><td>1.46</td><td>-</td><td>0.77</td></tr>
<tr><td><a href="https://raw.githubusercontent.com/stanislavkozlovski/Red-Black-Tree/master/rb_tree.py">Stanisl RB</a></td><td>7</td><td>1.28</td><td>1.78</td><td>1.19</td></tr>
<tr><td>Dee WBT</td><td>6</td><td>1.82</td><td>1.63</td><td>0.49</td></tr>
<tr><td><a href="https://github.com/pgrafov/python-avl-tree/blob/master/pyavltree.py">Pgrafov AVL</a></td><td>5</td><td>1.95</td><td>1.39</td><td>0.46</td></tr>
<tr><td><a href="https://github.com/mozman/bintrees">Mozman RB</a></td><td>4</td><td>1.21</td><td>1.98</td><td>0.25</td></tr>
<tr><td><a href="https://github.com/mozman/bintrees">Mozman AVL</a></td><td>3</td><td>1.47</td><td>1.02</td><td>0.26</td></tr>
<tr><td><a href="https://github.com/MSingh3012/Red-Black-tree-in-python/blob/master/RBTree.py">Msingh RB</a></td><td>2</td><td>1.02</td><td>0.84</td><td>0.61</td></tr>
<tr><td>Dee AVL</td><td>1</td><td>1.03</td><td>0.77</td><td>0.47</td></tr>
</table>
<br>
<p>Unfortunately, Dee WBT is the algorithm this article focuses on, and it's obvious it doesn't do
as well as the other trees. There are a few reasons for this:</p>
<br>
<table class="listtable">
<tr><td>&bull;</td><td>It allows for a custom search function, which slows searching down.</td></tr>
<tr><td>&bull;</td><td>Rebalancing is slightly slower due updating weights and how it compares
sibling nodes.</td></tr>
</table>
<br>
<p>It's important to remember that the weight balanced tree is still bounded by <i>O(log(n))</i> for
all of the normal <i>add()</i>, <i>remove()</i>, and <i>search()</i> operations. So even though its
relative performance isn't good, it will never become pathologically bad.</p>
<br>
</div>

<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Explanation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div class="content"><h1>Explanation</h1>
<p>Imagine keeping track of the residents in a city. As people decide to move to the city, or move
elsewhere, we'd like to update our ledger of residents and also query basic information about them
as fast as possible. An array would work, but its <i>O(n)</i> time would make it extremely slow as
more people decide to move to the city. This is where self balancing tree's come in. Most of the
common operations we'll perform will take <i>O(log(n))</i> time, so even a city of 1 million people
will only need about 20 operations to update its ledger.</p>
<br>
<p>All of the common self balancing trees have a similar structure: nodes with 2 children per node,
a root node, and some balancing mechanism.</p>
<br>
<br>
<svg version="1.1" viewBox="0 0 1000 244" class="diagram">
<g transform="translate(201,20)">
	<line x1="139" y1="79" x2="299" y2="19"/>
	<line x1="459" y1="79" x2="299" y2="19"/>
	<line x1="59" y1="139" x2="139" y2="79"/>
	<line x1="219" y1="139" x2="139" y2="79"/>
	<line x1="379" y1="139" x2="459" y2="79"/>
	<line x1="539" y1="139" x2="459" y2="79"/>
	<line x1="19" y1="199" x2="59" y2="139"/>
	<line x1="99" y1="199" x2="59" y2="139"/>
	<line x1="179" y1="199" x2="219" y2="139"/>
	<line x1="259" y1="199" x2="219" y2="139"/>
	<line x1="339" y1="199" x2="379" y2="139"/>
	<line x1="419" y1="199" x2="379" y2="139"/>
	<line x1="499" y1="199" x2="539" y2="139"/>
	<line x1="579" y1="199" x2="539" y2="139"/>
	<g class="bgfill highstroke">
		<circle cx="299" cy="19" r="17"/>
		<circle cx="139" cy="79" r="17"/>
		<circle cx="459" cy="79" r="17"/>
		<circle cx="59" cy="139" r="17"/>
		<circle cx="219" cy="139" r="17"/>
		<circle cx="379" cy="139" r="17"/>
		<circle cx="539" cy="139" r="17"/>
		<circle cx="19" cy="199" r="17"/>
		<circle cx="99" cy="199" r="17"/>
		<circle cx="179" cy="199" r="17"/>
		<circle cx="259" cy="199" r="17"/>
		<circle cx="339" cy="199" r="17"/>
		<circle cx="419" cy="199" r="17"/>
		<circle cx="499" cy="199" r="17"/>
		<circle cx="579" cy="199" r="17"/>
	</g>
	<g text-anchor="middle">
		<text x="299" y="-10" dy="0.3em" class="highfill">Root</text>
		<text x="299" y="20" dy="0.3em">7</text>
		<text x="139" y="80" dy="0.3em">3</text>
		<text x="459" y="80" dy="0.3em">11</text>
		<text x="59" y="140" dy="0.3em">1</text>
		<text x="219" y="140" dy="0.3em">5</text>
		<text x="379" y="140" dy="0.3em">9</text>
		<text x="539" y="140" dy="0.3em">13</text>
		<text x="19" y="200" dy="0.3em">0</text>
		<text x="99" y="200" dy="0.3em">2</text>
		<text x="179" y="200" dy="0.3em">4</text>
		<text x="259" y="200" dy="0.3em">6</text>
		<text x="339" y="200" dy="0.3em">8</text>
		<text x="419" y="200" dy="0.3em">10</text>
		<text x="499" y="200" dy="0.3em">12</text>
		<text x="579" y="200" dy="0.3em">14</text>
	</g>
</g>
</svg>
<br>
<br>
<p>Where the types of trees differ is in their balancing mechanism:</p>
<br>
<br>
<table class="datatable headercol">
<tr><td>Red-Black:</td><td>Traveling to any descendant node will cross the same number of black
nodes.</td></tr>
<tr><td>AVL:</td><td>The heights of child nodes will be kept within Â±1 of eachother.</td></tr>
<tr><td>Weight:</td><td>The weights of child nodes will be kept within a ratio of 2.5.</td></tr>
</table>
<br>
<br>
<p>In our weight balanced tree we define the weight as the number of descendants of a node, plus the
node itself. Mathematically, we can define the weight recursively as
<i>left.weight + right.weight + 1</i>. We also define null nodes to have a weight of <i>0</i>.</p>
<br>
<br>
<svg version="1.1" viewBox="0 0 1000 234" class="diagram">
<g transform="translate(167,27)">
	<line x1="160" y1="0" x2="80" y2="60"/>
	<line x1="160" y1="0" x2="240" y2="60"/>
	<line x1="80" y1="60" x2="40" y2="120"/>
	<line x1="80" y1="60" x2="120" y2="120"/>
	<line x1="240" y1="60" x2="200" y2="120"/>
	<line x1="240" y1="60" x2="280" y2="120"/>
	<line x1="40" y1="120" x2="0" y2="180"/>
	<line x1="40" y1="120" x2="80" y2="180"/>
	<g class="bgfill highstroke">
		<circle cx="160" cy="0" r="17"/>
		<circle cx="80" cy="60" r="17"/>
		<circle cx="240" cy="60" r="17"/>
		<circle cx="40" cy="120" r="17"/>
		<circle cx="120" cy="120" r="17"/>
		<circle cx="200" cy="120" r="17"/>
		<circle cx="280" cy="120" r="17"/>
		<circle cx="0" cy="180" r="17"/>
		<circle cx="80" cy="180" r="17"/>
	</g>
	<g text-anchor="middle">
		<text x="160" y="0" dy="0.3em">A</text>
		<text x="190" y="0" dy="0.3em" class="highfill">4</text>
		<text x="80" y="60" dy="0.3em">B</text>
		<text x="110" y="60" dy="0.3em" class="highfill">2</text>
		<text x="240" y="60" dy="0.3em">C</text>
		<text x="270" y="60" dy="0.3em" class="highfill">1</text>
		<text x="40" y="120" dy="0.3em">D</text>
		<text x="70" y="120" dy="0.3em" class="highfill">1</text>
	</g>
	<g text-anchor="middle" style="font-size:80%">
		<text x="120" y="120" dy="0.3em">NUL</text>
		<text x="200" y="120" dy="0.3em">NUL</text>
		<text x="280" y="120" dy="0.3em">NUL</text>
		<text x="0" y="180" dy="0.3em">NUL</text>
		<text x="80" y="180" dy="0.3em">NUL</text>
	</g>
</g>
<g transform="translate(570,44)">
	<rect x="0" y="0" width="280" height="140" stroke-width="1" fill="none"/>
	<line x1="0" y1="28" x2="280" y2="28" style="stroke-width:1;"/>
	<line x1="60" y1="0" x2="60" y2="140" style="stroke-width:1;"/>
	<line x1="140" y1="0" x2="140" y2="140" style="stroke-width:1;"/>
	<g text-anchor="middle">
		<text x="30" y="19">Node</text>
		<text x="30" y="49">A</text>
		<text x="30" y="69">B</text>
		<text x="30" y="89">C</text>
		<text x="30" y="109">D</text>
		<text x="30" y="129">NUL</text>
		<text x="100" y="19">Weight</text>
		<text x="100" y="49">4</text>
		<text x="100" y="69">2</text>
		<text x="100" y="89">1</text>
		<text x="100" y="109">1</text>
		<text x="100" y="129">0</text>
		<text x="210" y="19">Calculation</text>
		<text x="210" y="49">2 + 1 + 1</text>
		<text x="210" y="69">1 + 0 + 1</text>
		<text x="210" y="89">0 + 0 + 1</text>
		<text x="210" y="109">0 + 0 + 1</text>
	</g>
</g>
</svg>
<br>
<br>
<p>We will omit drawing null nodes from now on in order to avoid clutter. If a node is drawn without
a child, then it can be assumed that the child is null.</p>
<br>
<p>The tree will focus on maintaining two properties: the relative weights of 2 children should have
a ratio of 2.5 or less, and nodes will be in ascending order from left to right. For instance, in
the tree below, all children to the left of the root node are less than <i>7</i>, and all children
to the right are greater than <i>7</i>.</p>
<br>
<br>
<svg version="1.1" viewBox="0 0 1000 234" class="diagram">
<g transform="translate(201,10)">
	<line x1="139" y1="79" x2="299" y2="19"/>
	<line x1="459" y1="79" x2="299" y2="19"/>
	<line x1="59" y1="139" x2="139" y2="79"/>
	<line x1="219" y1="139" x2="139" y2="79"/>
	<line x1="379" y1="139" x2="459" y2="79"/>
	<line x1="539" y1="139" x2="459" y2="79"/>
	<line x1="19" y1="199" x2="59" y2="139"/>
	<line x1="99" y1="199" x2="59" y2="139"/>
	<line x1="179" y1="199" x2="219" y2="139"/>
	<line x1="259" y1="199" x2="219" y2="139"/>
	<line x1="339" y1="199" x2="379" y2="139"/>
	<line x1="419" y1="199" x2="379" y2="139"/>
	<line x1="499" y1="199" x2="539" y2="139"/>
	<line x1="579" y1="199" x2="539" y2="139"/>
	<g class="bgfill highstroke">
		<circle cx="299" cy="19" r="17"/>
		<circle cx="139" cy="79" r="17"/>
		<circle cx="459" cy="79" r="17"/>
		<circle cx="59" cy="139" r="17"/>
		<circle cx="219" cy="139" r="17"/>
		<circle cx="379" cy="139" r="17"/>
		<circle cx="539" cy="139" r="17"/>
		<circle cx="19" cy="199" r="17"/>
		<circle cx="99" cy="199" r="17"/>
		<circle cx="179" cy="199" r="17"/>
		<circle cx="259" cy="199" r="17"/>
		<circle cx="339" cy="199" r="17"/>
		<circle cx="419" cy="199" r="17"/>
		<circle cx="499" cy="199" r="17"/>
		<circle cx="579" cy="199" r="17"/>
	</g>
	<g text-anchor="middle">
		<text x="299" y="20" dy="0.3em">7</text>
		<text x="139" y="80" dy="0.3em">3</text>
		<text x="459" y="80" dy="0.3em">11</text>
		<text x="59" y="140" dy="0.3em">1</text>
		<text x="219" y="140" dy="0.3em">5</text>
		<text x="379" y="140" dy="0.3em">9</text>
		<text x="539" y="140" dy="0.3em">13</text>
		<text x="19" y="200" dy="0.3em">0</text>
		<text x="99" y="200" dy="0.3em">2</text>
		<text x="179" y="200" dy="0.3em">4</text>
		<text x="259" y="200" dy="0.3em">6</text>
		<text x="339" y="200" dy="0.3em">8</text>
		<text x="419" y="200" dy="0.3em">10</text>
		<text x="499" y="200" dy="0.3em">12</text>
		<text x="579" y="200" dy="0.3em">14</text>
	</g>
	<g transform="translate(341,13) rotate(20.55) scale(0.8)">
		<text x="0" y="0" class="highfill">greater than</text>
		<text x="0" y="1.2em" class="highfill">or equal to 7</text>
	</g>
	<g transform="translate(168,46) rotate(-20.55) scale(0.8)">
		<text x="0" y="0" class="highfill">lesser than</text>
		<text x="0" y="1.2em" class="highfill">or equal to 7</text>
	</g>
</g>
</svg>
<br>
<br>
<p>The importance of a self balancing tree is that we may add and remove nodes from the tree while
maintaining a logarithmic bound on the tree's height and a sorted ordering on the nodes. This allows
us to dynamically track and query data relatively quickly even on large data sets.</p>
<br>
<p>We are now prepared to implement the various operations that will maintain the tree's logarithmic
height, and also the operations that can make use of the tree once it's populated.</p>
<br>
<h2>Rotations</h2>
<br>
<p>Rotations are the fundamental operation that trees use to rebalance nodes. They work by swapping a
node's position with one of it's children and, in the process, raise one of its children and lower
another. There are two type of rotations that can be performed: left rotations and right rotations.</p>
<br>
<p>Let us consider a right rotation on the node <i>A</i> below.</p>
<br>
<br>
<svg version="1.1" viewBox="0 0 1000 171" class="diagram">
<g transform="translate(272,10)">
	<line x1="58" y1="78" x2="98" y2="18"/>
	<line x1="138" y1="78" x2="98" y2="18"/>
	<line x1="18" y1="138" x2="58" y2="78"/>
	<line x1="98" y1="138" x2="58" y2="78"/>
	<g class="bgfill highstroke">
		<circle cx="98" cy="18" r="17"/>
		<circle cx="58" cy="78" r="17"/>
		<circle cx="138" cy="78" r="17"/>
		<circle cx="18" cy="138" r="17"/>
		<circle cx="98" cy="138" r="17"/>
	</g>
	<g text-anchor="middle">
		<text x="98" y="18" dy="0.3em">A</text>
		<text x="58" y="78" dy="0.3em">B</text>
		<text x="138" y="78" dy="0.3em">z</text>
		<text x="18" y="138" dy="0.3em">x</text>
		<text x="98" y="138" dy="0.3em">y</text>
	</g>
</g>
<g transform="translate(467,55)">
	<line x1="0" y1="30" x2="70" y2="30" style="stroke-width:4"/>
	<line x1="50" y1="10" x2="70" y2="30" style="stroke-width:4"/>
	<line x1="50" y1="50" x2="70" y2="30" style="stroke-width:4"/>
</g>
<g transform="translate(572,10)">
	<line x1="18" y1="78" x2="58" y2="18"/>
	<line x1="98" y1="78" x2="58" y2="18"/>
	<line x1="58" y1="138" x2="98" y2="78"/>
	<line x1="138" y1="138" x2="98" y2="78"/>
	<g class="bgfill highstroke">
		<circle cx="58" cy="18" r="17"/>
		<circle cx="18" cy="78" r="17"/>
		<circle cx="98" cy="78" r="17"/>
		<circle cx="58" cy="138" r="17"/>
		<circle cx="138" cy="138" r="17"/>
	</g>
	<g text-anchor="middle">
		<text x="58" y="18" dy="0.3em">B</text>
		<text x="18" y="78" dy="0.3em">x</text>
		<text x="98" y="78" dy="0.3em">A</text>
		<text x="58" y="138" dy="0.3em">y</text>
		<text x="138" y="138" dy="0.3em">z</text>
	</g>
</g>
</svg>
<br>
<br>
<p>Note that node <i>B</i> will take the place of node <i>A</i>, wherever <i>A</i> was in the tree.
It can be seen that this right rotation has the effect of shifting the majority of nodes from the
left side of the tree to the right. By doing this, the relative weights of 2 children can be kept
close, and it is the crux of the tree's logarithmic performance. The rotation above is what we'll
use to rebalance a right-leaning node. The rotation also preserves the sorted order of the nodes by
maintaining the following order:</p>
<br>
<table class="listtable">
<tr><td><i>x</i> is to the left of <i>B</i></td></tr>
<tr><td><i>B</i> is to the left of <i>y</i></td></tr>
<tr><td><i>y</i> is to the left of <i>A</i></td></tr>
<tr><td><i>A</i> is to the left of <i>z</i></td></tr>
</table>
<br>
<p>Likewise, a left rotation on node A looks like so:</p>
<br>
<br>
<svg version="1.1" viewBox="0 0 1000 171" class="diagram">
<g transform="translate(272,10)">
	<line x1="18" y1="78" x2="58" y2="18"/>
	<line x1="98" y1="78" x2="58" y2="18"/>
	<line x1="58" y1="138" x2="98" y2="78"/>
	<line x1="138" y1="138" x2="98" y2="78"/>
	<g class="bgfill highstroke">
		<circle cx="58" cy="18" r="17"/>
		<circle cx="18" cy="78" r="17"/>
		<circle cx="98" cy="78" r="17"/>
		<circle cx="58" cy="138" r="17"/>
		<circle cx="138" cy="138" r="17"/>
	</g>
	<g text-anchor="middle">
		<text x="58" y="18" dy="0.3em">A</text>
		<text x="18" y="78" dy="0.3em">x</text>
		<text x="98" y="78" dy="0.3em">B</text>
		<text x="58" y="138" dy="0.3em">y</text>
		<text x="138" y="138" dy="0.3em">z</text>
	</g>
</g>
<g transform="translate(467,55)">
	<line x1="0" y1="30" x2="70" y2="30" style="stroke-width:4"/>
	<line x1="50" y1="10" x2="70" y2="30" style="stroke-width:4"/>
	<line x1="50" y1="50" x2="70" y2="30" style="stroke-width:4"/>
</g>
<g transform="translate(572,10)">
	<line x1="58" y1="78" x2="98" y2="18"/>
	<line x1="138" y1="78" x2="98" y2="18"/>
	<line x1="18" y1="138" x2="58" y2="78"/>
	<line x1="98" y1="138" x2="58" y2="78"/>
	<g class="bgfill highstroke">
		<circle cx="98" cy="18" r="17"/>
		<circle cx="58" cy="78" r="17"/>
		<circle cx="138" cy="78" r="17"/>
		<circle cx="18" cy="138" r="17"/>
		<circle cx="98" cy="138" r="17"/>
	</g>
	<g text-anchor="middle">
		<text x="98" y="18" dy="0.3em">B</text>
		<text x="58" y="78" dy="0.3em">A</text>
		<text x="138" y="78" dy="0.3em">z</text>
		<text x="18" y="138" dy="0.3em">x</text>
		<text x="98" y="138" dy="0.3em">y</text>
	</g>
</g>
</svg>
<br>
<br>
<p>Left rotations can conversely be used to rebalance a node which is leaning to the right.</p>
<br>
<p>The python code to perform these rotations is given below. Note that the weights of nodes
<i>A</i> and <i>B</i> need to be recalculated after each rotation, since their childs' weights
may have changed.</p>
<br>
<div class="codeblock langpython">def rotleft(a):
	b=a.right
	r=b.left
	b.parent=a.parent
	b.left=a
	a.parent=b
	a.right=r
	if r: r.parent=a
	a.calcweight()
	b.calcweight()
	return b


def rotright(a):
	b=a.left
	l=b.right
	b.parent=a.parent
	b.right=a
	a.parent=b
	a.left=l
	if l: l.parent=a
	a.calcweight()
	b.calcweight()
	return b


def calcweight(self):
	l,r,weight=self.left,self.right,1
	if l: weight+=l.weight
	if r: weight+=r.weight
	self.weight=weight
</div>
<br>
<p>We will show a concrete of example of how rotations are used to rebalance a tree in the next
section.</p>
<br>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Balancing ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h2>Balancing</h2>
<br>
<p>As we add and remove nodes from the tree, the tree will become lopsided; with some branches
becoming extremely heavy and some extremely light. In order to maintain an <i>O(log(n))</i>
worst-case performance bound on tree operations, the tree will need to be rebalanced
periodically.</p>
<br>
<p>Ideally, in a perfectly balanced tree, all children will have the same weight. However, since
we're working with a tree that can be updated dynamically, we will have to allow some slack in
balancing the tree in order to balance in a timely manner. That is, if we're too strict with
rebalancing, the act of rebalancing will take longer than any time we might save by using a self
balancing tree.</p>
<br>
<p>For our tree, we will define a node to be balanced if its left and right child weights are within
a ratio of 2.5. That is <i>1 / 2.5 â¤ left.weight / right.weight â¤ 2.5</i>. However, defining the
actual inequality in python is fairly tricky, and even slight errors can lead to trees that become
imbalanced. The actual inequality we will use to detect an imbalance only involves integer math:</p>
<br>
<div class="codeblock langpython">if right.weight * 5 + 2 &lt;  left.weight * 2:
	#Node is leaning to the left.

if  left.weight * 5 + 2 &lt; right.weight * 2:
	#Node is leaning to the right.

#Otherwise, the node is balanced.
</div>
<br>
<p>Choosing other values could lead to the balancing invariant being broken over time, or lead to
trees with worse balancing ratios. <a href="https://yoichihirai.com/bst.pdf">Hirai et al</a> cover
research into other invariants that can be used.</p>
<br>
<svg version="1.1" viewBox="0 0 1000 352" class="diagram">
<g transform="translate(310,10)">
	<line x1="99" y1="79" x2="179" y2="19"/>
	<line x1="259" y1="79" x2="179" y2="19"/>
	<line x1="59" y1="139" x2="99" y2="79"/>
	<line x1="139" y1="139" x2="99" y2="79"/>
	<line x1="19" y1="199" x2="59" y2="139"/>
	<g class="bgfill highstroke">
		<circle cx="179" cy="19" r="17"/>
		<circle cx="99" cy="79" r="17"/>
		<circle cx="259" cy="79" r="17"/>
		<circle cx="59" cy="139" r="17"/>
		<circle cx="139" cy="139" r="17"/>
		<circle cx="19" cy="199" r="17"/>
	</g>
	<g text-anchor="middle">
		<text x="179" y="20" dy="0.3em">5</text>
		<text x="99" y="80" dy="0.3em">3</text>
		<text x="259" y="80" dy="0.3em">6</text>
		<text x="59" y="140" dy="0.3em">2</text>
		<text x="139" y="140" dy="0.3em">4</text>
		<text x="19" y="200" dy="0.3em">1</text>
	</g>
</g>
<g transform="translate(360,290)">
	<text x="0" y="0">weight(3) = 4</text>
	<text x="0" y="0" dy="1.2em">weight(6) = 1</text>
	<text x="0" y="0" dy="2.4em">weight(6)*5+2 &lt; weight(3)*2</text>
	<text x="0" y="0" dy="3.6em">Leaning to the left</text>
</g>
</svg>
<br>
<br>
<p>To actually rebalance a node, we will make use of rotations. Note from the previous section that
left and right rotations shift weights differently. In particular, rotating to the left tilts the
node's children to the left, and rotating to the right tilts them to the right. In some situations,
where the middle node (denoted by <i>y</i> above) is too heavy, simply performing one rotation
won't balance the tree. In those situations, we'll need to perform a double rotation. Thus, for a
node leaning to the left, we have the following cases:</p>
<br>
<div class="codeblock langpython">if right.weight * 5 + 2 &lt; left.weight * 2:
	if left.left.weight * 5 &lt; left.weight * 2:
		#Double rotation.
		#Rotate node.left to the left.
	#Rotate node to the right.
</div>
<br>
<p>Single and double rotations will handle every type of imbalance we'll encounter, so there's need
to introduce any more. We'll first show what a single rotation looks like:</p>
<br>
<br>
<svg version="1.1" viewBox="0 0 1000 380" class="diagram">
<g transform="translate(170,30)">
	<text x="330" y="-10" text-anchor="middle" style="font-size:170%" dy="0.3em">Single Rotation</text>
	<line x1="0" y1="280" x2="660" y2="280" style="stroke-width:1"/>
	<line x1="330" y1="20" x2="330" y2="280" style="stroke-width:1"/>
	<g transform="translate(320,293)">
		<line x1="0" y1="7" x2="20" y2="7" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="0" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="14" style="stroke-width:1"/>
	</g>
	<g transform="translate(320,317)">
		<line x1="0" y1="7" x2="20" y2="7" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="0" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="14" style="stroke-width:1"/>
	</g>
	<g transform="translate(50,60) scale(0.8)">
		<line x1="99" y1="79" x2="179" y2="19"/>
		<line x1="259" y1="79" x2="179" y2="19"/>
		<line x1="59" y1="139" x2="99" y2="79"/>
		<line x1="139" y1="139" x2="99" y2="79"/>
		<line x1="19" y1="199" x2="59" y2="139"/>
		<g class="bgfill highstroke">
			<circle cx="179" cy="19" r="17"/>
			<circle cx="99" cy="79" r="17"/>
			<circle cx="259" cy="79" r="17"/>
			<circle cx="59" cy="139" r="17"/>
			<circle cx="139" cy="139" r="17"/>
			<circle cx="19" cy="199" r="17"/>
		</g>
		<g text-anchor="middle">
			<text x="179" y="20" dy="0.3em">5</text>
			<text x="99" y="80" dy="0.3em">3</text>
			<text x="259" y="80" dy="0.3em">6</text>
			<text x="59" y="140" dy="0.3em">2</text>
			<text x="139" y="140" dy="0.3em">4</text>
			<text x="19" y="200" dy="0.3em">1</text>
		</g>
	</g>
	<g transform="translate(65,307)">
		<text x="0" y="0">weight(6)*5+2&lt;weight(3)*2</text>
		<text x="0" y="0" dy="1.2em">Right rotate 5</text>
	</g>
	<g transform="translate(380,60) scale(0.8)">
		<line x1="59" y1="79" x2="139" y2="19"/>
		<line x1="219" y1="79" x2="139" y2="19"/>
		<line x1="19" y1="139" x2="59" y2="79"/>
		<line x1="179" y1="139" x2="219" y2="79"/>
		<line x1="259" y1="139" x2="219" y2="79"/>
		<g class="bgfill highstroke">
			<circle cx="139" cy="19" r="17"/>
			<circle cx="59" cy="79" r="17"/>
			<circle cx="219" cy="79" r="17"/>
			<circle cx="19" cy="139" r="17"/>
			<circle cx="179" cy="139" r="17"/>
			<circle cx="259" cy="139" r="17"/>
		</g>
		<g text-anchor="middle">
			<text x="139" y="20" dy="0.3em">3</text>
			<text x="59" y="80" dy="0.3em">2</text>
			<text x="219" y="80" dy="0.3em">5</text>
			<text x="19" y="140" dy="0.3em">1</text>
			<text x="179" y="140" dy="0.3em">4</text>
			<text x="259" y="140" dy="0.3em">6</text>
		</g>
	</g>
	<g transform="translate(405,307)">
		<text x="0" y="0">Balanced!</text>
	</g>
</g>
</svg>
<br>
<br>
<p>Single rotations can fail to balance the node if the middle node is too heavy. If this is the
case, then we must left rotate the node's left child before actually rotating the node. The example
below shows what would happen if we didn't make this correction.</p>
<br>
<br>
<svg version="1.1" viewBox="0 0 1000 380" class="diagram">
<g transform="translate(105,30)">
	<text x="395" y="-10" text-anchor="middle" style="font-size:170%" dy="0.3em">Single Rotation - Incorrect</text>
	<line x1="0" y1="280" x2="790" y2="280" style="stroke-width:1"/>
	<line x1="395" y1="20" x2="395" y2="280" style="stroke-width:1"/>
	<g transform="translate(385,293)">
		<line x1="0" y1="7" x2="20" y2="7" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="0" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="14" style="stroke-width:1"/>
	</g>
	<g transform="translate(385,317)">
		<line x1="0" y1="7" x2="20" y2="7" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="0" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="14" style="stroke-width:1"/>
	</g>
	<g transform="translate(50,60) scale(0.8)">
		<line x1="99" y1="79" x2="219" y2="19"/>
		<line x1="339" y1="79" x2="219" y2="19"/>
		<line x1="19" y1="139" x2="99" y2="79"/>
		<line x1="179" y1="139" x2="99" y2="79"/>
		<line x1="219" y1="199" x2="179" y2="139"/>
		<g class="bgfill highstroke">
			<circle cx="219" cy="19" r="17"/>
			<circle cx="99" cy="79" r="17"/>
			<circle cx="339" cy="79" r="17"/>
			<circle cx="19" cy="139" r="17"/>
			<circle cx="179" cy="139" r="17"/>
			<circle cx="219" cy="199" r="17"/>
		</g>
		<g text-anchor="middle">
			<text x="219" y="20" dy="0.3em">5</text>
			<text x="99" y="80" dy="0.3em">2</text>
			<text x="339" y="80" dy="0.3em">6</text>
			<text x="19" y="140" dy="0.3em">1</text>
			<text x="179" y="140" dy="0.3em">3</text>
			<text x="219" y="200" dy="0.3em">4</text>
		</g>
	</g>
	<g transform="translate(90,307)">
		<text x="0" y="0">weight(6)*5+2&lt;weight(2)*2</text>
		<text x="0" y="0" dy="1.2em">Right rotate 5</text>
	</g>
	<g transform="translate(450,60) scale(0.8)">
		<line x1="19" y1="79" x2="139" y2="19"/>
		<line x1="259" y1="79" x2="139" y2="19"/>
		<line x1="179" y1="139" x2="259" y2="79"/>
		<line x1="339" y1="139" x2="259" y2="79"/>
		<line x1="219" y1="199" x2="179" y2="139"/>
		<g class="bgfill highstroke">
			<circle cx="139" cy="19" r="17"/>
			<circle cx="19" cy="79" r="17"/>
			<circle cx="259" cy="79" r="17"/>
			<circle cx="179" cy="139" r="17"/>
			<circle cx="339" cy="139" r="17"/>
			<circle cx="219" cy="199" r="17"/>
		</g>
		<g text-anchor="middle">
			<text x="139" y="20" dy="0.3em">2</text>
			<text x="19" y="80" dy="0.3em">1</text>
			<text x="259" y="80" dy="0.3em">5</text>
			<text x="179" y="140" dy="0.3em">3</text>
			<text x="339" y="140" dy="0.3em">6</text>
			<text x="219" y="200" dy="0.3em">4</text>
		</g>
	</g>
	<g transform="translate(500,307)">
		<text x="0" y="0">weight(1)*5+2&lt;weight(5)*2</text>
		<text x="0" y="0" dy="1.2em">Not balanced!</text>
	</g>
</g>
</svg>
<br>
<br>
<p>Rotating the left child beforehand results in a correctly balanced tree.</p>
<br>
<br>
<svg version="1.1" viewBox="0 0 1000 320" class="diagram">
<g transform="translate(20,30)">
	<text x="480" y="-10" text-anchor="middle" style="font-size:170%" dy="0.3em">Double Rotation - Correct</text>
	<line x1="0" y1="220" x2="960" y2="220" style="stroke-width:1"/>
	<line x1="303" y1="20" x2="303" y2="220" style="stroke-width:1"/>
	<line x1="630" y1="20" x2="630" y2="220" style="stroke-width:1"/>
	<g transform="translate(293,233)">
		<line x1="0" y1="7" x2="20" y2="7" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="0" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="14" style="stroke-width:1"/>
	</g>
	<g transform="translate(293,257)">
		<line x1="0" y1="7" x2="20" y2="7" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="0" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="14" style="stroke-width:1"/>
	</g>
	<g transform="translate(620,233)">
		<line x1="0" y1="7" x2="20" y2="7" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="0" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="14" style="stroke-width:1"/>
	</g>
	<g transform="translate(620,257)">
		<line x1="0" y1="7" x2="20" y2="7" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="0" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="14" style="stroke-width:1"/>
	</g>
	<g transform="translate(45,50) scale(0.6)">
		<line x1="99" y1="79" x2="219" y2="19"/>
		<line x1="339" y1="79" x2="219" y2="19"/>
		<line x1="19" y1="139" x2="99" y2="79"/>
		<line x1="179" y1="139" x2="99" y2="79"/>
		<line x1="219" y1="199" x2="179" y2="139"/>
		<g class="bgfill highstroke">
			<circle cx="219" cy="19" r="17"/>
			<circle cx="99" cy="79" r="17"/>
			<circle cx="339" cy="79" r="17"/>
			<circle cx="19" cy="139" r="17"/>
			<circle cx="179" cy="139" r="17"/>
			<circle cx="219" cy="199" r="17"/>
		</g>
		<g text-anchor="middle">
			<text x="219" y="20" dy="0.3em">5</text>
			<text x="99" y="80" dy="0.3em">2</text>
			<text x="339" y="80" dy="0.3em">6</text>
			<text x="19" y="140" dy="0.3em">1</text>
			<text x="179" y="140" dy="0.3em">3</text>
			<text x="219" y="200" dy="0.3em">4</text>
		</g>
	</g>
	<g transform="translate(65,247)">
		<text x="0" y="0">weight(1)*5&lt;weight(2)*2</text>
		<text x="0" y="0" dy="1.2em">Left rotate 2</text>
	</g>
	<g transform="translate(348,50) scale(0.6)">
		<line x1="139" y1="79" x2="259" y2="19"/>
		<line x1="379" y1="79" x2="259" y2="19"/>
		<line x1="59" y1="139" x2="139" y2="79"/>
		<line x1="219" y1="139" x2="139" y2="79"/>
		<line x1="19" y1="199" x2="59" y2="139"/>
		<g class="bgfill highstroke">
			<circle cx="259" cy="19" r="17"/>
			<circle cx="139" cy="79" r="17"/>
			<circle cx="379" cy="79" r="17"/>
			<circle cx="59" cy="139" r="17"/>
			<circle cx="219" cy="139" r="17"/>
			<circle cx="19" cy="199" r="17"/>
		</g>
		<g text-anchor="middle">
			<text x="259" y="20" dy="0.3em">5</text>
			<text x="139" y="80" dy="0.3em">3</text>
			<text x="379" y="80" dy="0.3em">6</text>
			<text x="59" y="140" dy="0.3em">2</text>
			<text x="219" y="140" dy="0.3em">4</text>
			<text x="19" y="200" dy="0.3em">1</text>
		</g>
	</g>
	<g transform="translate(410,247)">
		<text x="0" y="0">Right rotate 3</text>
	</g>
	<g transform="translate(675,50) scale(0.6)">
		<line x1="59" y1="79" x2="179" y2="19"/>
		<line x1="299" y1="79" x2="179" y2="19"/>
		<line x1="19" y1="139" x2="59" y2="79"/>
		<line x1="219" y1="139" x2="299" y2="79"/>
		<line x1="379" y1="139" x2="299" y2="79"/>
		<g class="bgfill highstroke">
			<circle cx="179" cy="19" r="17"/>
			<circle cx="59" cy="79" r="17"/>
			<circle cx="299" cy="79" r="17"/>
			<circle cx="19" cy="139" r="17"/>
			<circle cx="219" cy="139" r="17"/>
			<circle cx="379" cy="139" r="17"/>
		</g>
		<g text-anchor="middle">
			<text x="179" y="20" dy="0.3em">3</text>
			<text x="59" y="80" dy="0.3em">2</text>
			<text x="299" y="80" dy="0.3em">5</text>
			<text x="19" y="140" dy="0.3em">1</text>
			<text x="219" y="140" dy="0.3em">4</text>
			<text x="379" y="140" dy="0.3em">6</text>
		</g>
	</g>
	<g transform="translate(700,247)">
		<text x="0" y="0">Balanced!</text>
	</g>
</g>
</svg>
<br>
<br>
<p>The cases where a node is leaning to the right are handled exactly the same, only all "left" and
"right" references are swapped, including rotations.</p>
<br>
<p>The code below is our full rebalancing function. In order to make sure all node weights are
correct, we need to rebalance from the node we've added (or removed) all the way up to the root.</p>
<br>
<div class="codeblock langpython">def rebalance(self,next):
	#Rebalance from next upward. If 2 children differ in weight by a ratio of 2.5 or
	#more, we can rotate to rebalance.
	def Weight(n): return n.weight if n else 0
	while next:
		node,orig=next,next
		next=node.parent
		l,r=node.left,node.right
		lw,rw=Weight(l),Weight(r)
		if rw*5+2&lt;lw*2:
			#Leaning to the left.
			if Weight(l.left)*5&lt;lw*2: node.left=l.rotleft()
			node=node.rotright()
		elif lw*5+2&lt;rw*2:
			#Leaning to the right.
			if Weight(r.right)*5&lt;rw*2: node.right=r.rotright()
			node=node.rotleft()
		else:
			#Balanced.
			node.weight=lw+rw+1
			continue
		if next is None: self.root=node
		elif next.left is orig: next.left=node
		else: next.right=node
</div>
<br>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Searching ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h2>Searching</h2>
<br>
<p>When defining self balancing trees, we stated that any child to the left of a node will satisfy
<i>node.value &gt;= child.value</i>, and any child to the right will satisfy
<i>node.value &lt;= child.value</i>. While this property allows us to search for nodes, it also
presents a problem since the tree can have multiple nodes with the same key. In such a case, which
node should we return when searching for a key?</p>
<br>
<p>For the purposes of this article, we will have the search function return the last node going by
sorted order. Thus, the rules it will follow are:</p>
<br>
<table class="listtable">
<tr><td>1:</td><td>Start at the root node.</td></tr>
<tr><td>2:</td><td>If <i>node.value &lt;= value</i>, then move to the node's right child.</td></tr>
<tr><td>3:</td><td>Otherwise, move to the node's left child.</td></tr>
<tr><td>4:</td><td>Continue until we reach a null node.</td></tr>
<tr><td>5:</td><td>Return the last node with <i>node.value = value</i>.</td></tr>
</table>
<br>
<p>For example, assume we want to search for <i>value = 5</i> in the following tree.</p>
<br>
<br>
<svg version="1.1" viewBox="0 0 1000 288" class="diagram">
<g transform="translate(176,10)">
	<line x1="139" y1="79" x2="299" y2="19" stroke-width="4" class="highstroke"/>
	<line x1="459" y1="79" x2="299" y2="19"/>
	<line x1="59" y1="139" x2="139" y2="79"/>
	<line x1="219" y1="139" x2="139" y2="79" stroke-width="4" class="highstroke"/>
	<line x1="379" y1="139" x2="459" y2="79"/>
	<line x1="539" y1="139" x2="459" y2="79"/>
	<line x1="19" y1="199" x2="59" y2="139"/>
	<line x1="99" y1="199" x2="59" y2="139"/>
	<line x1="179" y1="199" x2="219" y2="139"/>
	<line x1="259" y1="199" x2="219" y2="139" stroke-width="4" class="highstroke"/>
	<line x1="339" y1="199" x2="379" y2="139"/>
	<line x1="419" y1="199" x2="379" y2="139"/>
	<line x1="499" y1="199" x2="539" y2="139"/>
	<line x1="579" y1="199" x2="539" y2="139"/>
	<line x1="259" y1="199" x2="219" y2="259" stroke-width="4" class="highstroke"/>
	<g class="bgfill highstroke">
		<circle cx="299" cy="19" r="17"/>
		<circle cx="139" cy="79" r="17"/>
		<circle cx="459" cy="79" r="17"/>
		<circle cx="59" cy="139" r="17"/>
		<circle cx="219" cy="139" r="17"/>
		<circle cx="379" cy="139" r="17"/>
		<circle cx="539" cy="139" r="17"/>
		<circle cx="19" cy="199" r="17"/>
		<circle cx="99" cy="199" r="17"/>
		<circle cx="179" cy="199" r="17"/>
		<circle cx="259" cy="199" r="17"/>
		<circle cx="339" cy="199" r="17"/>
		<circle cx="419" cy="199" r="17"/>
		<circle cx="499" cy="199" r="17"/>
		<circle cx="579" cy="199" r="17"/>
		<circle cx="219" cy="259" r="17"/>
	</g>
	<g text-anchor="middle">
		<text x="299" y="20" dy="0.3em">7</text>
		<text x="139" y="80" dy="0.3em">3</text>
		<text x="459" y="80" dy="0.3em">11</text>
		<text x="59" y="140" dy="0.3em">1</text>
		<text x="219" y="140" dy="0.3em">5</text>
		<text x="379" y="140" dy="0.3em">9</text>
		<text x="539" y="140" dy="0.3em">13</text>
		<text x="19" y="200" dy="0.3em">0</text>
		<text x="99" y="200" dy="0.3em">2</text>
		<text x="179" y="200" dy="0.3em">4</text>
		<text x="259" y="200" dy="0.3em">6</text>
		<text x="339" y="200" dy="0.3em">8</text>
		<text x="419" y="200" dy="0.3em">10</text>
		<text x="499" y="200" dy="0.3em">12</text>
		<text x="579" y="200" dy="0.3em">14</text>
		<text x="219" y="260" dy="0.3em" style="font-size:80%">NUL</text>
	</g>
	<g style="font-size:80%">
		<text x="326" y="10" class="highfill">start at the root</text>
		<text x="326" y="10" dy="1.2em" class="highfill">7&gt;5: go left</text>
		<text x="165" y="80" dy="0.3em" class="highfill">3&lt;=5: go right</text>
		<text x="245" y="135" class="highfill">5&lt;=5: go right</text>
		<text x="245" y="135" dy="1.2em" class="highfill">record node</text>
		<text x="270" y="230" class="highfill">6&gt;5: go left</text>
		<text x="245" y="260" dy="0.3em" class="highfill">null node: abort</text>
	</g>
</g>
</svg>
<br>
<br>
<p>The python code below shows how our basic search function works.</p>
<br>
<div class="codeblock langpython">def search(tree,value):
	node,ret=tree.root,None
	while node:
		if node.value&lt;=value:
			if value==node.value: ret=node
			node=node.right
		else:
			node=node.left
	return ret
</div>
<br>
<p>In <a href="./WBTree.py">WBTree.py</a>, the search function has been expanded to allow us to
query different ranges in the tree. They include:</p>
<br>
<table class="listtable">
<tr><td>&bull;</td><td>Return the least <i>node = value</i>.</td></tr>
<tr><td>&bull;</td><td>Return the least <i>node &gt; value</i>.</td></tr>
<tr><td>&bull;</td><td>Return the least <i>node &gt;= value</i>.</td></tr>
<tr><td>&bull;</td><td>Return the greatest <i>node = value</i>.</td></tr>
<tr><td>&bull;</td><td>Return the greatest <i>node &lt; value</i>.</td></tr>
<tr><td>&bull;</td><td>Return the greatest <i>node &lt;= value</i>.</td></tr>
</table>
<br>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Adding ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h2>Adding</h2>
<br>
<p>Adding nodes is as simple as finding where the node would be if we searched for it, adding it as
a child, and then balancing up. Because we defined our search function to go right whenever
<i>node.value &lt;= value</i>, this will stably (in the sorting sense) add the node to the tree.</p>
<br>
<p>For instance, assume we want to add <i>value = 4</i> to the following tree:</p>
<br>
<br>
<svg version="1.1" viewBox="0 0 1000 259" class="diagram">
<g transform="translate(0,10)">
	<line x1="59" y1="79" x2="139" y2="19"/>
	<line x1="219" y1="79" x2="139" y2="19" stroke-width="4" class="highstroke"/>
	<line x1="259" y1="139" x2="219" y2="79" stroke-width="4" class="highstroke"/>
	<line x1="299" y1="199" x2="259" y2="139" stroke-width="4" class="highstroke"/>
	<g class="bgfill highstroke">
		<circle cx="139" cy="19" r="17"/>
		<circle cx="59" cy="79" r="17"/>
		<circle cx="219" cy="79" r="17"/>
		<circle cx="259" cy="139" r="17"/>
		<circle cx="299" cy="199" r="17"/>
	</g>
	<g text-anchor="middle">
		<text x="139" y="20" dy="0.3em">1</text>
		<text x="59" y="80" dy="0.3em">0</text>
		<text x="219" y="80" dy="0.3em">2</text>
		<text x="259" y="140" dy="0.3em">3</text>
	</g>
	<g text-anchor="middle" style="font-size:80%">
		<text x="299" y="200" dy="0.3em">NUL</text>
	</g>
	<g>
		<text x="165" y="11" class="highfill">start at the root</text>
		<text x="165" y="11" dy="1.2em" class="highfill">1&lt;=4: go right</text>
		<text x="245" y="80" dy="0.3em" class="highfill">2&lt;=4: go right</text>
		<text x="285" y="140" dy="0.3em" class="highfill">3&lt;=4: go right</text>
		<text x="325" y="192" class="highfill">null node:</text>
		<text x="325" y="192" dy="1.2em" class="highfill">place 4 here</text>
	</g>
</g>
<g transform="translate(475,80)">
	<line x1="0" y1="30" x2="70" y2="30" style="stroke-width:4"/>
	<line x1="50" y1="10" x2="70" y2="30" style="stroke-width:4"/>
	<line x1="50" y1="50" x2="70" y2="30" style="stroke-width:4"/>
</g>
<g transform="translate(650,10)">
	<line x1="19" y1="79" x2="99" y2="19"/>
	<line x1="179" y1="79" x2="99" y2="19"/>
	<line x1="219" y1="139" x2="179" y2="79"/>
	<line x1="259" y1="199" x2="219" y2="139"/>
	<g class="bgfill highstroke">
		<circle cx="99" cy="19" r="17"/>
		<circle cx="19" cy="79" r="17"/>
		<circle cx="179" cy="79" r="17"/>
		<circle cx="219" cy="139" r="17"/>
		<circle cx="259" cy="199" r="17"/>
	</g>
	<g text-anchor="middle">
		<text x="99" y="20" dy="0.3em">1</text>
		<text x="19" y="80" dy="0.3em">0</text>
		<text x="179" y="80" dy="0.3em">2</text>
		<text x="219" y="140" dy="0.3em">3</text>
		<text x="259" y="200" dy="0.3em">4</text>
	</g>
</g>
</svg>
<br>
<br>
<p>We would then balance from node <i>3</i> upwards until we reach the root node.</p>
<br>
<br>
<svg version="1.1" viewBox="0 0 1000 259" class="diagram">
<g transform="translate(5,10) scale(0.93)">
	<line x1="59" y1="79" x2="139" y2="19"/>
	<line x1="219" y1="79" x2="139" y2="19"/>
	<line x1="259" y1="139" x2="219" y2="79"  stroke-width="4" class="highstroke"/>
	<line x1="299" y1="199" x2="259" y2="139"  stroke-width="4" class="highstroke"/>
	<g class="bgfill highstroke">
		<circle cx="139" cy="19" r="17"/>
		<circle cx="59" cy="79" r="17"/>
		<circle cx="219" cy="79" r="17"/>
		<circle cx="259" cy="139" r="17"/>
		<circle cx="299" cy="199" r="17"/>
	</g>
	<g text-anchor="middle">
		<text x="139" y="20" dy="0.3em">1</text>
		<text x="59" y="80" dy="0.3em">0</text>
		<text x="219" y="80" dy="0.3em">2</text>
		<text x="259" y="140" dy="0.3em">3</text>
		<text x="299" y="200" dy="0.3em">4</text>
	</g>
	<g>
		<text x="245" y="75" class="highfill">leaning right:</text>
		<text x="245" y="75" dy="1.2em" class="highfill">rotate left</text>
		<text x="285" y="135" class="highfill">balanced:</text>
		<text x="285" y="135" dy="1.2em" class="highfill">continue</text>
	</g>
</g>
<g transform="translate(475,85)">
	<line x1="0" y1="30" x2="70" y2="30" style="stroke-width:4"/>
	<line x1="50" y1="10" x2="70" y2="30" style="stroke-width:4"/>
	<line x1="50" y1="50" x2="70" y2="30" style="stroke-width:4"/>
</g>
<g transform="translate(585,10) scale(0.93)">
	<line x1="59" y1="79" x2="179" y2="19"/>
	<line x1="299" y1="79" x2="179" y2="19" stroke-width="4" class="highstroke"/>
	<line x1="219" y1="139" x2="299" y2="79"/>
	<line x1="379" y1="139" x2="299" y2="79"/>
	<g class="bgfill highstroke">
		<circle cx="179" cy="19" r="17"/>
		<circle cx="59" cy="79" r="17"/>
		<circle cx="299" cy="79" r="17"/>
		<circle cx="219" cy="139" r="17"/>
		<circle cx="379" cy="139" r="17"/>
	</g>
	<g text-anchor="middle">
		<text x="179" y="20" dy="0.3em">1</text>
		<text x="59" y="80" dy="0.3em">0</text>
		<text x="299" y="80" dy="0.3em">3</text>
		<text x="219" y="140" dy="0.3em">2</text>
		<text x="379" y="140" dy="0.3em">4</text>
	</g>
	<g>
		<text x="215" y="10" class="highfill">reached root:</text>
		<text x="215" y="10" dy="1.2em" class="highfill">abort</text>
	</g>
</g>
</svg>
<br>
<br>
<p>The code for adding values is given below. Note that this function will always add a new value.
Implementations that require duplicate additions to replace old values will need to modify the
<i>add()</i> function.</p>
<br>
<div class="codeblock langpython">def add(tree,value):
	prev,node=None,self.root
	while node:
		right=node.value&lt;=value
		if right: node=node.right
		else    : node=node.left
	node=self.Node(value)
	node.parent=prev
	if prev is None:
		self.root=node
	else:
		if right: prev.right=node
		else    : prev.left=node
		self.rebalance(prev)
	return node
</div>
<br>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Traversal ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h2>Traversal</h2>
<br>
<p>Given a particular node in the tree, we may be interested in finding the next or previous node
going by sorted order. That is, if this tree was a sorted array, what would the next and previous
elements be? Answering this question will help us not only with navigating a tree, but also with
removing nodes in the next section.</p>
<br>
<p>Finding <i>next(node)</i> for some node can be split into 2 cases:</p>
<br>
<table class="listtable">
<tr><td>1.</td><td>If <i>node.right</i> is not null, take <i>node.right</i>'s left children until
we reach a node with no left child.</td></tr>
<tr><td>2.</td><td>If <i>node.right</i> is null, follow the node up the tree until we move up a
left branch.</td></tr>
</table>
<br>
<p>We can illustrate these movements in the following diagram:</p>
<br>
<br>
<svg version="1.1" viewBox="0 0 1000 350" class="diagram">
<g transform="translate(150,10)">
	<line x1="350" y1="0" x2="350" y2="330" style="stroke-width:1"/>
	<line x1="0" y1="285" x2="700" y2="285" style="stroke-width:1"/>
	<g transform="translate(25,75)">
		<text x="139" y="-50" dy="0.3em" text-anchor="middle" style="font-size:150%">Case 1 - Down</text>
		<line x1="59" y1="79" x2="139" y2="19"/>
		<line x1="219" y1="79" x2="139" y2="19" stroke-width="4" class="highstroke"/>
		<line x1="19" y1="139" x2="59" y2="79"/>
		<line x1="99" y1="139" x2="59" y2="79"/>
		<line x1="179" y1="139" x2="219" y2="79" stroke-width="4" class="highstroke"/>
		<line x1="259" y1="139" x2="219" y2="79"/>
		<g class="bgfill highstroke">
			<circle cx="139" cy="19" r="17"/>
			<circle cx="59" cy="79" r="17"/>
			<circle cx="219" cy="79" r="17"/>
			<circle cx="19" cy="139" r="17"/>
			<circle cx="99" cy="139" r="17"/>
			<circle cx="179" cy="139" r="17"/>
			<circle cx="259" cy="139" r="17"/>
		</g>
		<g text-anchor="middle">
			<text x="139" y="20" dy="0.3em">4</text>
			<text x="59" y="80" dy="0.3em">2</text>
			<text x="219" y="80" dy="0.3em">6</text>
			<text x="19" y="140" dy="0.3em">1</text>
			<text x="99" y="140" dy="0.3em">3</text>
			<text x="179" y="140" dy="0.3em">5</text>
			<text x="259" y="140" dy="0.3em">7</text>
			<text x="139" y="237">next(4) = 5</text>
		</g>
		<g style="font-size:80%">
			<text x="165" y="10" class="highfill">right is not null:</text>
			<text x="165" y="10" dy="1.2em" class="highfill">go right</text>
			<text x="245" y="80" dy="0.3em" class="highfill">go left</text>
			<text x="170" y="175" class="highfill">left is null:</text>
			<text x="170" y="175" dy="1.2em" class="highfill">return node 5</text>
		</g>
	</g>
	<g transform="translate(375,75)">
		<text x="139" y="-50" dy="0.3em" text-anchor="middle" style="font-size:150%">Case 2 - Up</text>
		<line x1="59" y1="79" x2="139" y2="19" stroke-width="4" class="highstroke"/>
		<line x1="219" y1="79" x2="139" y2="19"/>
		<line x1="19" y1="139" x2="59" y2="79"/>
		<line x1="99" y1="139" x2="59" y2="79" stroke-width="4" class="highstroke"/>
		<line x1="179" y1="139" x2="219" y2="79"/>
		<line x1="259" y1="139" x2="219" y2="79"/>
		<g class="bgfill highstroke">
			<circle cx="139" cy="19" r="17"/>
			<circle cx="59" cy="79" r="17"/>
			<circle cx="219" cy="79" r="17"/>
			<circle cx="19" cy="139" r="17"/>
			<circle cx="99" cy="139" r="17"/>
			<circle cx="179" cy="139" r="17"/>
			<circle cx="259" cy="139" r="17"/>
		</g>
		<g text-anchor="middle">
			<text x="139" y="20" dy="0.3em">4</text>
			<text x="59" y="80" dy="0.3em">2</text>
			<text x="219" y="80" dy="0.3em">6</text>
			<text x="19" y="140" dy="0.3em">1</text>
			<text x="99" y="140" dy="0.3em">3</text>
			<text x="179" y="140" dy="0.3em">5</text>
			<text x="259" y="140" dy="0.3em">7</text>
			<text x="139" y="237">next(3) = 4</text>
		</g>
		<g style="font-size:80%">
			<text x="165" y="10" class="highfill">2 is left child:</text>
			<text x="165" y="10" dy="1.2em" class="highfill">return node 4</text>
			<text x="85" y="80" class="highfill">3 is not left</text>
			<text x="85" y="80" dy="1.2em" class="highfill">child: go up</text>
			<text x="100" y="175" class="highfill">right is null:</text>
			<text x="100" y="175" dy="1.2em" class="highfill">go up</text>
		</g>
	</g>
</g>
</svg>
<br>
<br>
<p>This procedure yields the following python function for <i>next()</i>:</p>
<br>
<div class="codeblock langpython">def next(node):
	child=node.right
	if child:
		while child: node,child=child,child.left
	else:
		while node and node.right is child:
			child,node=node,node.parent
	return node
</div>
<br>
<p>The <i>prev()</i> function is exactly the same as <i>next()</i>, except we swap all instances of
<i>node.left</i> with <i>node.right</i>:</p>
<br>
<div class="codeblock langpython">def prev(node):
	child=node.left
	if child:
		while child: node,child=child,child.right
	else:
		while node and node.left is child:
			child,node=node,node.parent
	return node
</div>
<br>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Removing ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h2>Removing</h2>
<br>
<p>Removing a node involves replacing all links to the node with that of its successor,
<i>next(node)</i>, and then rebalancing. It would be simpler to swap the node's value with that of
its successor, and then remove the successor, but this would invalidate any external pointers a user
might have to the successor node. Indeed, a user might find it odd that the node that was supposed
to be removed still exists, and another node has been deallocated without warning.</p>
<br>
<p>There are 3 cases to consider when removing a node.</p>
<br>
<table class="listtable">
<tr><td>1.</td><td>The node has no right child.</td></tr>
<tr><td>2.</td><td>The successor is the right child of the node.</td></tr>
<tr><td>3.</td><td>The successor is a distant descendant of the node.</td></tr>
</table>
<br>
<p>If the node has a null child, then we simply replace the node with its other child and rebalance
from the node's parent upwards. For instance, if we want to remove node <i>5</i> in the diagram
below.</p>
<br>
<br>
<svg version="1.1" viewBox="0 0 1000 380" class="diagram">
<g transform="translate(200,30)">
	<text x="300" y="-10" text-anchor="middle" style="font-size:170%" dy="0.3em">Case 1</text>
	<line x1="0" y1="280" x2="600" y2="280" style="stroke-width:1"/>
	<line x1="300" y1="20" x2="300" y2="280" style="stroke-width:1"/>
	<g transform="translate(290,293)">
		<line x1="0" y1="7" x2="20" y2="7" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="0" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="14" style="stroke-width:1"/>
	</g>
	<g transform="translate(290,317)">
		<line x1="0" y1="7" x2="20" y2="7" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="0" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="14" style="stroke-width:1"/>
	</g>
	<g transform="translate(75,40)">
		<line x1="19" y1="79" x2="59" y2="19"/>
		<line x1="99" y1="79" x2="59" y2="19"/>
		<line x1="59" y1="139" x2="99" y2="79"/>
		<line x1="139" y1="139" x2="99" y2="79"/>
		<line x1="19" y1="199" x2="59" y2="139"/>
		<line x1="99" y1="199" x2="59" y2="139"/>
		<g class="bgfill highstroke">
			<circle cx="59" cy="19" r="17"/>
			<circle cx="19" cy="79" r="17"/>
			<circle cx="99" cy="79" r="17" class="dimfill"/>
			<circle cx="59" cy="139" r="17"/>
			<circle cx="139" cy="139" r="17"/>
			<circle cx="19" cy="199" r="17"/>
			<circle cx="99" cy="199" r="17"/>
		</g>
		<g text-anchor="middle">
			<text x="59" y="20" dy="0.3em">1</text>
			<text x="19" y="80" dy="0.3em">0</text>
			<text x="99" y="80" dy="0.3em">5</text>
			<text x="59" y="140" dy="0.3em">4</text>
			<text x="19" y="200" dy="0.3em">2</text>
			<text x="99" y="200" dy="0.3em">3</text>
			<text x="70" y="270" dy="0.3em">remove node 5</text>
		</g>
		<g text-anchor="middle" style="font-size:80%">
			<text x="139" y="140" dy="0.3em">NUL</text>
		</g>
	</g>
	<g transform="translate(375,40)">
		<line x1="19" y1="79" x2="59" y2="19"/>
		<line x1="99" y1="79" x2="59" y2="19"/>
		<line x1="59" y1="139" x2="99" y2="79"/>
		<line x1="139" y1="139" x2="99" y2="79"/>
		<g class="bgfill highstroke">
			<circle cx="59" cy="19" r="17"/>
			<circle cx="19" cy="79" r="17"/>
			<circle cx="99" cy="79" r="17"/>
			<circle cx="59" cy="139" r="17"/>
			<circle cx="139" cy="139" r="17"/>
		</g>
		<g text-anchor="middle">
			<text x="59" y="20" dy="0.3em">1</text>
			<text x="19" y="80" dy="0.3em">0</text>
			<text x="99" y="80" dy="0.3em">4</text>
			<text x="59" y="140" dy="0.3em">2</text>
			<text x="139" y="140" dy="0.3em">3</text>
			<text x="79" y="270" dy="0.3em">replace with node 4</text>
		</g>
	</g>
</g>
</svg>
<br>
<br>
<p>If a right child exists, then we know that the next node will be a child on the right-hand side
of the node. We also know that, by definition, the next node will have no left child. Thus, for case
2, if the next node is the node's right child, then we can replace the node with the next node
without having to worry about shuffling around either nodes' children.</p>
<br>
<br>
<svg version="1.1" viewBox="0 0 1000 380" class="diagram">
<g transform="translate(200,30)">
	<text x="300" y="-10" text-anchor="middle" style="font-size:170%" dy="0.3em">Case 2</text>
	<line x1="0" y1="280" x2="600" y2="280" style="stroke-width:1"/>
	<line x1="300" y1="20" x2="300" y2="280" style="stroke-width:1"/>
	<g transform="translate(290,293)">
		<line x1="0" y1="7" x2="20" y2="7" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="0" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="14" style="stroke-width:1"/>
	</g>
	<g transform="translate(290,317)">
		<line x1="0" y1="7" x2="20" y2="7" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="0" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="14" style="stroke-width:1"/>
	</g>
	<g transform="translate(50,40)">
		<line x1="19" y1="79" x2="59" y2="19"/>
		<line x1="99" y1="79" x2="59" y2="19"/>
		<line x1="59" y1="139" x2="99" y2="79"/>
		<line x1="139" y1="139" x2="99" y2="79"/>
		<line x1="99" y1="199" x2="139" y2="139"/>
		<line x1="179" y1="199" x2="139" y2="139"/>
		<g class="bgfill highstroke">
			<circle cx="59" cy="19" r="17"/>
			<circle cx="19" cy="79" r="17"/>
			<circle cx="99" cy="79" r="17" class="dimfill"/>
			<circle cx="59" cy="139" r="17"/>
			<circle cx="139" cy="139" r="17"/>
			<circle cx="99" cy="199" r="17"/>
			<circle cx="179" cy="199" r="17"/>
		</g>
		<g text-anchor="middle">
			<text x="59" y="20" dy="0.3em">1</text>
			<text x="19" y="80" dy="0.3em">0</text>
			<text x="99" y="80" dy="0.3em">3</text>
			<text x="59" y="140" dy="0.3em">2</text>
			<text x="139" y="140" dy="0.3em">4</text>
			<text x="179" y="200" dy="0.3em">5</text>
		</g>
		<g text-anchor="middle" style="font-size:80%">
			<text x="99" y="200" dy="0.3em">NUL</text>
		</g>
		<g transform="translate(40,265)">
			<text x="0" y="0">remove node 3</text>
			<text x="0" y="0" dy="1.2em">next(3) = 4</text>
		</g>
	</g>
	<g transform="translate(375,40)">
		<line x1="19" y1="79" x2="59" y2="19"/>
		<line x1="99" y1="79" x2="59" y2="19"/>
		<line x1="59" y1="139" x2="99" y2="79"/>
		<line x1="139" y1="139" x2="99" y2="79"/>
		<g class="bgfill highstroke">
			<circle cx="59" cy="19" r="17"/>
			<circle cx="19" cy="79" r="17"/>
			<circle cx="99" cy="79" r="17"/>
			<circle cx="59" cy="139" r="17"/>
			<circle cx="139" cy="139" r="17"/>
		</g>
		<g text-anchor="middle">
			<text x="59" y="20" dy="0.3em">1</text>
			<text x="19" y="80" dy="0.3em">0</text>
			<text x="99" y="80" dy="0.3em">4</text>
			<text x="59" y="140" dy="0.3em">2</text>
			<text x="139" y="140" dy="0.3em">5</text>
		</g>
		<g transform="translate(-20,265)">
			<text x="0" y="0">node 4 is right child of</text>
			<text x="0" y="0" dy="1.2em">node 3; replace node 3</text>
		</g>
	</g>
</g>
</svg>
<br>
<br>
<p>For case 3, the next node will be a distant child of the node. So, we must first remove the next
node (as in case 1), and then replace the node with the next node.</p>
<br>
<br>
<svg version="1.1" viewBox="0 0 1000 380" class="diagram">
<g transform="translate(50,30)">
	<text x="450" y="-10" text-anchor="middle" style="font-size:170%" dy="0.3em">Case 3</text>
	<line x1="0" y1="280" x2="900" y2="280" style="stroke-width:1"/>
	<line x1="300" y1="20" x2="300" y2="280" style="stroke-width:1"/>
	<line x1="600" y1="20" x2="600" y2="280" style="stroke-width:1"/>
	<g transform="translate(290,293)">
		<line x1="0" y1="7" x2="20" y2="7" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="0" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="14" style="stroke-width:1"/>
	</g>
	<g transform="translate(290,317)">
		<line x1="0" y1="7" x2="20" y2="7" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="0" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="14" style="stroke-width:1"/>
	</g>
	<g transform="translate(590,293)">
		<line x1="0" y1="7" x2="20" y2="7" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="0" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="14" style="stroke-width:1"/>
	</g>
	<g transform="translate(590,317)">
		<line x1="0" y1="7" x2="20" y2="7" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="0" style="stroke-width:1"/>
		<line x1="20" y1="7" x2="13" y2="14" style="stroke-width:1"/>
	</g>
	<g transform="translate(75,40)">
		<line x1="19" y1="79" x2="59" y2="19"/>
		<line x1="99" y1="79" x2="59" y2="19"/>
		<line x1="59" y1="139" x2="99" y2="79"/>
		<line x1="139" y1="139" x2="99" y2="79"/>
		<line x1="19" y1="199" x2="59" y2="139"/>
		<line x1="99" y1="199" x2="59" y2="139"/>
		<g class="bgfill highstroke">
			<circle cx="59" cy="19" r="17" class="dimfill"/>
			<circle cx="19" cy="79" r="17"/>
			<circle cx="99" cy="79" r="17"/>
			<circle cx="59" cy="139" r="17"/>
			<circle cx="139" cy="139" r="17"/>
			<circle cx="19" cy="199" r="17"/>
			<circle cx="99" cy="199" r="17"/>
		</g>
		<g text-anchor="middle">
			<text x="59" y="20" dy="0.3em">1</text>
			<text x="19" y="80" dy="0.3em">0</text>
			<text x="99" y="80" dy="0.3em">4</text>
			<text x="59" y="140" dy="0.3em">2</text>
			<text x="139" y="140" dy="0.3em">5</text>
			<text x="99" y="200" dy="0.3em">3</text>
		</g>
		<g text-anchor="middle" style="font-size:80%">
			<text x="19" y="200" dy="0.3em">NUL</text>
		</g>
		<g transform="translate(15,265)">
			<text x="0" y="0">remove node 1</text>
			<text x="0" y="0" dy="1.2em">next(1) = 2</text>
		</g>
	</g>
	<g transform="translate(375,40)">
		<line x1="19" y1="79" x2="59" y2="19"/>
		<line x1="99" y1="79" x2="59" y2="19"/>
		<line x1="59" y1="139" x2="99" y2="79"/>
		<line x1="139" y1="139" x2="99" y2="79"/>
		<g class="bgfill highstroke">
			<circle cx="59" cy="19" r="17" class="dimfill"/>
			<circle cx="19" cy="79" r="17"/>
			<circle cx="99" cy="79" r="17"/>
			<circle cx="59" cy="139" r="17"/>
			<circle cx="139" cy="139" r="17"/>
		</g>
		<g text-anchor="middle">
			<text x="59" y="20" dy="0.3em">1</text>
			<text x="19" y="80" dy="0.3em">0</text>
			<text x="99" y="80" dy="0.3em">4</text>
			<text x="59" y="140" dy="0.3em">3</text>
			<text x="139" y="140" dy="0.3em">5</text>
		</g>
		<g transform="translate(-35,265)">
			<text x="0" y="0">node 2 not right child</text>
			<text x="0" y="0" dy="1.2em">of node 1; remove node 2</text>
		</g>
	</g>
	<g transform="translate(675,40)">
		<line x1="19" y1="79" x2="59" y2="19"/>
		<line x1="99" y1="79" x2="59" y2="19"/>
		<line x1="59" y1="139" x2="99" y2="79"/>
		<line x1="139" y1="139" x2="99" y2="79"/>
		<g class="bgfill highstroke">
			<circle cx="59" cy="19" r="17"/>
			<circle cx="19" cy="79" r="17"/>
			<circle cx="99" cy="79" r="17"/>
			<circle cx="59" cy="139" r="17"/>
			<circle cx="139" cy="139" r="17"/>
		</g>
		<g text-anchor="middle">
			<text x="59" y="20" dy="0.3em">2</text>
			<text x="19" y="80" dy="0.3em">0</text>
			<text x="99" y="80" dy="0.3em">4</text>
			<text x="59" y="140" dy="0.3em">3</text>
			<text x="139" y="140" dy="0.3em">5</text>
		</g>
		<g transform="translate(10,265)">
			<text x="0" y="0">replace node 1</text>
			<text x="0" y="0" dy="1.2em">with node 2</text>
		</g>
	</g>
</g>
</svg>
<br>
<br>
<p>The complete python code for removing a given node is shown below.</p>
<br>
<div class="codeblock langpython">def removenode(self,node):
	#Remove a specific node.
	p=node.parent
	l,r=node.left,node.right
	if r is None:
		#Case 1
		bal,next,l=p,l,None
	elif r.left:
		#Case 3
		next=r
		while next.left: bal,next=next,next.left
		c=next.right
		bal.left=c
		if c: c.parent=bal
	else:
		#Case 2
		bal,next,r=r,r,None
	#Replace node with next.
	if p is None: self.root=next
	elif p.left is node: p.left=next
	else: p.right=next
	if next:
		next.parent=p
		if l: next.left,l.parent=l,next
		if r: next.right,r.parent=r,next
	self.rebalance(bal)
</div>
<br>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Indexing ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h2>Indexing</h2>
<br>
<p>The biggest benefit to balancing by weights (instead of red-black or AVL) is that weights grants
us the ability to index nodes in <i>O(log(n))</i> time, even as we are modifying the tree.</p>
<br>
<p>We'll index nodes in the same way that we would index values if they were sorted from least to
greatest. So index <i>0</i> would be the smallest value in the tree, and index <i>n-1</i> would be
the greatest. We also need to remember that children to the left of the node have values equal to
or less than the node. Putting all that together, we'll follow these simple rules:</p>
<br>
<table class="listtable">
<tr><td>1.</td><td>If <i>index &gt; left.weight</i>, go to the right and subtract
<i>index -= left.weight + 1</i>.</td></tr>
<tr><td>2.</td><td>If <i>index = left.weight</i>, return the current node.</td></tr>
<tr><td>3.</td><td>Otherwise go to the left.</td></tr>
</table>
<br>
<p>Using the tree below, we can show how to find the 10'th element in the tree. Note that all of
the numbers we'll be using will refer to weights.</p>
<br>
<br>
<svg version="1.1" viewBox="0 0 1000 288" class="diagram">
<g transform="translate(176,10)">
	<line x1="139" y1="79" x2="299" y2="19"/>
	<line x1="459" y1="79" x2="299" y2="19" stroke-width="4" class="highstroke"/>
	<line x1="59" y1="139" x2="139" y2="79"/>
	<line x1="219" y1="139" x2="139" y2="79"/>
	<line x1="379" y1="139" x2="459" y2="79" stroke-width="4" class="highstroke"/>
	<line x1="539" y1="139" x2="459" y2="79"/>
	<line x1="19" y1="199" x2="59" y2="139"/>
	<line x1="99" y1="199" x2="59" y2="139"/>
	<line x1="179" y1="199" x2="219" y2="139"/>
	<line x1="259" y1="199" x2="219" y2="139"/>
	<line x1="339" y1="199" x2="379" y2="139"/>
	<line x1="419" y1="199" x2="379" y2="139" stroke-width="4" class="highstroke"/>
	<line x1="499" y1="199" x2="539" y2="139"/>
	<line x1="579" y1="199" x2="539" y2="139"/>
	<g class="bgfill highstroke">
		<circle cx="299" cy="19" r="17"/>
		<circle cx="139" cy="79" r="17"/>
		<circle cx="459" cy="79" r="17"/>
		<circle cx="59" cy="139" r="17"/>
		<circle cx="219" cy="139" r="17"/>
		<circle cx="379" cy="139" r="17"/>
		<circle cx="539" cy="139" r="17"/>
		<circle cx="19" cy="199" r="17"/>
		<circle cx="99" cy="199" r="17"/>
		<circle cx="179" cy="199" r="17"/>
		<circle cx="259" cy="199" r="17"/>
		<circle cx="339" cy="199" r="17"/>
		<circle cx="419" cy="199" r="17"/>
		<circle cx="499" cy="199" r="17"/>
		<circle cx="579" cy="199" r="17"/>
	</g>
	<g text-anchor="middle">
		<text x="299" y="20" dy="0.3em">7</text>
		<text x="139" y="80" dy="0.3em">3</text>
		<text x="459" y="80" dy="0.3em">11</text>
		<text x="59" y="140" dy="0.3em">1</text>
		<text x="219" y="140" dy="0.3em">5</text>
		<text x="379" y="140" dy="0.3em">9</text>
		<text x="539" y="140" dy="0.3em">13</text>
		<text x="19" y="200" dy="0.3em">0</text>
		<text x="99" y="200" dy="0.3em">2</text>
		<text x="179" y="200" dy="0.3em">4</text>
		<text x="259" y="200" dy="0.3em">6</text>
		<text x="339" y="200" dy="0.3em">8</text>
		<text x="419" y="200" dy="0.3em">10</text>
		<text x="499" y="200" dy="0.3em">12</text>
		<text x="579" y="200" dy="0.3em">14</text>
	</g>
	<g style="font-size:80%">
		<text x="326" y="10" class="highfill">10&gt;7</text>
		<text x="326" y="10" dy="1.2em" class="highfill">index=10-7-1=2, go right</text>
		<text x="485" y="70" class="highfill">2&lt;3</text>
		<text x="485" y="70" dy="1.2em" class="highfill">go left</text>
		<text x="405" y="135" class="highfill">2&gt;1</text>
		<text x="405" y="135" dy="1.2em" class="highfill">index=2-1-1=0</text>
		<text x="405" y="135" dy="2.4em" class="highfill">go right</text>
		<text x="430" y="230" class="highfill">0=0</text>
		<text x="430" y="230" dy="1.2em" class="highfill">return node</text>
	</g>
</g>
</svg>
<br>
<br>
<p>The code for this ends up being fairly simple.</p>
<br>
<div class="codeblock langpython">def __len__(self):
	#Return the number of nodes in the tree.
	return self.root.weight if self.root else 0


def __getitem__(self,i):
	#Index nodes like an array.
	node=self.root
	weight=node.weight if node else 0
	if i&lt;0: i+=weight
	if i&lt;0 or i&gt;=weight: return None
	while True:
		left=node.left
		lw=left.weight if left else 0
		if i&gt;lw:
			i-=lw+1
			node=node.right
		elif i==lw:
			break
		else:
			node=left
	return node
</div>
<br>
<p>To find the index of a specific node, we simply do the opposite. We trace the path from a node
to the root. Every time our node is a right descendant, we add the weight of the left child plus 1
to our index.</p>
<br>
<div class="codeblock langpython">def index(node):
	#Returns the node's index within the tree. Ex: tree[node.index()]=node.
	i=-1
	prev=node.right
	while node:
		if node.right is prev:
			i+=node.left.weight+1 if node.left else 1
		prev=node
		node=node.parent
	return i
</div>
</div>

<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Time Complexity ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div class="content"><h1>Time Complexity</h1>
<p>Proving that the weights of two children will always stay within a ratio 2.5 is fairly difficult.
We will instead be taking this balance as fact, and simply proving that the height of the tree is
bound by <i>h &lt;= 2.07 * log2(n)</i>.</p>
<br>
<p>Let <i>N</i> be the weight of the node, and let <i>L</i> and <i>R</i> be the weights of its two
children. For simplicity, we'll assume <i>N = L + R</i>. Our first step is to bound the weight
of either of the two children by <i>N</i>.</p>
<br>
<div class="codeblock">    L / R &lt;= 2.5
L / (N-L) &lt;= 2.5
        L &lt;= 2.5 * (N-L)
  1.4 * L &lt;= N
        L &lt;= N / 1.4
</div>
<br>
<p>Thus, the maximum weight of a child is <i>1 / 1.4</i> the weight of the parent. We now need to
see at what height the weight of a child becomes <i>1</i>.</p>
<br>
<div class="codeblock">n * (1/1.4) ^ h &gt;= 1
    (1/1.4) ^ h &gt;= 1 / n
        1.4 ^ h &lt;= n
  log2(1.4) * h &lt;= log2(n)
              h &lt;= 2.07 * log2(n)
</div>
<br>
<p>Thus the height is logarithmically bound, as desired.</p>
<br>
<h2>Operational Time Complexity</h2>
<br>
<p>Now, we can show that the worst-case time complexity for our operations is also
<i>O(log(n))</i>.</p>
<br>
<p>Rebalancing only moves up the tree, which is <i>O(log(n))</i>, and performs 1 or 2 rotations per
node, which are <i>O(1)</i>. Thus rebalancing is <i>O(log(n))</i>.</p>
<br>
<p>Searching only moves down the tree, which is <i>O(log(n))</i>, and performs one comparison per
node, which is <i>O(1)</i>. Thus searching is <i>O(log(n))</i>.</p>
<br>
<p>Next/prev must either travel all the way up the tree or down the tree, which is <i>O(log(n))</i>.
The average number of operations per next/prev is 2.</p>
<br>
<p>Adding a node involves searching for a node's destined position, which is <i>O(log(n))</i>, and
rebalancing, which is <i>O(log(n))</i>. Thus adding nodes is <i>O(log(n))</i>.</p>
<br>
<p>Removing a node involves at most finding the node, which is <i>O(log(n))</i>, finding the next
node, which is <i>O(log(n))</i>, swapping, which is <i>O(1)</i>, and balancing, which is
<i>O(log(n))</i>. Thus, removing a node is <i>O(log(n))</i>.</p>
<br>
<p>Finding a node given an index a node involves comparing weights and moving down the tree, which
is <i>O(log(n))</i>. Finding an index given a node only moves up the tree, which is also
<i>O(log(n))</i>. Thus indexing is <i>O(log(n))</i>.</p>
</div>

<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Notes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div class="content"><h1>Notes</h1>
<p>Better balancing is possible by avoiding ratios entirely. Instead, we can attempt a double or
single rotation and see if that results in a better balance. Research is needed to simplify when
balancing is performed and what its worst case balance is.</p>
<br>
<p>Our implementation of an AVL tree performs above average compared to other implementations found
online, but is far from the best. Performance of the rebalancing and removal functions will need to
be improved to be competitive.</p>
<br>
<p><a href="https://en.wikipedia.org/wiki/B-tree">B-trees</a> are the predecessors to most self balancing trees. They are rarely used in practice,
however.</p>
<br>
<p>The article presents AVL trees as only using the absolute height of nodes. Although this is a more
sturdy method of maintaining node balance, it is actually faster to record the relative balance of
children nodes for each node. That is, instead of each node having a height attribute, they would
instead have a balance attribute that must be kept between -1 and +1.</p>
<br>
<p><a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Red-black trees</a> are the most popular alternative for self balancing trees. They require less
information per node, but have a more complicated rebalancing step. Also, even though their maximum
height is <i>h&lt;2*log2(n)</i>, their real-time performance is still competitive with AVL trees.</p>
<br>
<p>Concurrency has been a difficult problem for AVL trees. Most papers present AVL trees with a reduced
set of operations in order to make them concurrent. Researchers seem to have had better luck with
making Red-black trees concurrent.</p>
</div>

<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Footer ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div id="footer">Created on 27 Apr 2018 - Modified on 3 May 2022<br>
Questions and comments: akdee<b>OBFUS</b>144@g<b>CATE</b>mail.com<br>
<a href="../index.html">Alec Dee's Homepage</a></div>
</body>
</html>
