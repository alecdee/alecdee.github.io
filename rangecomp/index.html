<!DOCTYPE HTML>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Range Encoding for Data Compression</title>
	<link rel="stylesheet" href="../style/style.css" type="text/css">
	<script type="text/javascript" src="../style/style.js"></script>
</head>
<body>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Header ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div id="header"><a href="../index.html">Alec Dee's Homepage</a></div>

<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Introduction ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div class="content"><h1>Introduction</h1>
<p>Range encoders are a type of entropy encoder used in modern day data compressors. They're an
evolution of earlier entropy encoders (most notably Huffman encoding) which were restricted to
encoding data as a whole number of bits. Range encoding, by contrast, allows us to encode in
fractions of a bit and thus achieve compression ratios very close to optimal.</p>
<br>
<p>Note that in order to compress data, an entropy encoder needs to be paired with a model to predict
what data will appear next. The better the model, the better the compression. Since this article is
meant to explain range encoding, the model we use will be kept simple.</p>
</div>

<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Implementation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div class="content"><h1>Implementation</h1>
<p>We provide two implementations of our range encoder: <a href="./RangeEncoder.py">RangeEncoder.py</a>
in python, and <a href="./range_c99.zip">range_c99.zip</a> in C. Both implementations are similar in
layout and produce identical outputs. When called from the command line, they will use an adaptive
order-0 model to compress or decompress a file.</p>
<br>
<p>Python</p>
<br>
<div class="consoleblock">python3 RangeEncoder.py -c image.bmp compress.dat
python3 RangeEncoder.py -d compress.dat decompress.bmp</div>
<br>
<p>Binary</p>
<br>
<div class="consoleblock">.\range_win.exe -c image.bmp compress.dat
.\range_win.exe -d compress.dat decompress.bmp</div>
<br>
<p>And below are our results from compressing the <a href="http://corpus.canterbury.ac.nz/descriptions/#calgary">calgary corpus</a>.
Indeed, our compression ratios are on par with similarly equipped range/arithmetic encoders.</p>
<br>
<table class="datatable headerrow">
<tr><td>File</td><td>Original Size</td><td>Compressed Size</td><td>% Smaller</td></tr>
<tr><td>bib</td><td>111,261</td><td>72,730</td><td>34%</td></tr>
<tr><td>book1</td><td>768,771</td><td>435,870</td><td>43%</td></tr>
<tr><td>book2</td><td>610,856</td><td>360,136</td><td>41%</td></tr>
<tr><td>geo</td><td>102,400</td><td>72,629</td><td>29%</td></tr>
<tr><td>news</td><td>377,109</td><td>241,538</td><td>35%</td></tr>
<tr><td>obj1</td><td>21,504</td><td>15,174</td><td>29%</td></tr>
<tr><td>obj2</td><td>246,814</td><td>180,750</td><td>26%</td></tr>
<tr><td>paper1</td><td>53,161</td><td>32,524</td><td>38%</td></tr>
<tr><td>paper2</td><td>82,199</td><td>47,340</td><td>42%</td></tr>
<tr><td>pic</td><td>513,216</td><td>70,021</td><td>86%</td></tr>
<tr><td>progc</td><td>39,611</td><td>25,513</td><td>35%</td></tr>
<tr><td>progl</td><td>71,646</td><td>41,833</td><td>41%</td></tr>
<tr><td>progp</td><td>49,379</td><td>29,604</td><td>40%</td></tr>
<tr><td>trans</td><td>93,695</td><td>62,856</td><td>32%</td></tr>
<tr><td>=</td><td>3,141,622</td><td>1,688,518</td><td>46%</td></tr>
</table>
</div>

<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Proof of Concept ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div class="content"><h1>Proof of Concept</h1>
<p>When learning about range encoding, the overall concept can be eclipsed by all of the details that a
practical implementation demands. In truth, range encoders are based off of the fairly simple
concept of scaling one interval to fit inside another. Thus, we'll use this first section to go over
an example of encoding and decoding a message with a simplified range encoder in order to explain
the idea behind it. In the next section, we'll go over our real-world implementation.</p>
<br>
<p>Our end goal with a range encoder is to turn a sequence of intervals into a number in the interval
<i>[0,1)</i>. When we give someone else this number, they will be able to determine what interval was
encoded at each step. By mapping these intervals to symbols (ex: letters, numbers, bytes, etc) we
can encode and decode a sequence of symbols.</p>
<br>
<p>There are many intervals we can choose to encode a message, but because our goal is data
compression, our intervals will actually be chosen by the probability of each symbol. For instance,
assume our message will only be composed of the symbols A, B, C, and D, and we already know their
probabilities of occurring in a message, which are given below.</p>
<br>
<table class="datatable headerrow">
<tr><td>Symbol</td><td>Probability</td></tr>
<tr><td>A</td><td>0.20</td></tr>
<tr><td>B</td><td>0.10</td></tr>
<tr><td>C</td><td>0.25</td></tr>
<tr><td>D</td><td>0.45</td></tr>
</table>
<br>
<p>To derive the intervals for this set of symbols, we'll first visualize them as lines whose heights
are equal to their symbol's probability</p>
<br>
<svg version="1.1" viewBox="0 0 1000 400" class="diagram">
<g transform="translate(308,30)" stroke="none">
	<rect x="0" y="190" width="6" height="146" fill="#ff0000"/>
	<rect x="125" y="263" width="6" height="73" fill="#008000"/>
	<rect x="250" y="153" width="6" height="183" fill="#0000ff"/>
	<rect x="375" y="6" width="6" height="330" fill="#ffa000"/>
	<g text-anchor="middle" style="font-size:125%">
		<text x="3" y="355">A</text>
		<text x="128" y="355">B</text>
		<text x="253" y="355">C</text>
		<text x="378" y="355">D</text>
	</g>
	<g text-anchor="middle">
		<text x="3" y="183">0.20</text>
		<text x="128" y="255">0.10</text>
		<text x="253" y="146">0.25</text>
		<text x="378" y="0">0.45</text>
	</g>
</g>
</svg>
<br>
<p>Next, we'll stack the lines that we've drawn and add their heights.</p>
<br>
<svg version="1.1" viewBox="0 0 1000 600" class="diagram">
<g transform="translate(450,10)" stroke="none">
	<rect x="20" y="5.0" width="5" height="251.0" fill="#ffa000"/>
	<rect x="20" y="260.0" width="5" height="140.0" fill="#0000ff"/>
	<rect x="20" y="404.0" width="5" height="56.0" fill="#008000"/>
	<rect x="20" y="464.0" width="5" height="112.0" fill="#ff0000"/>
	<rect x="20" y="0.0" width="22" height="5"/>
	<rect x="20" y="255.0" width="22" height="5"/>
	<rect x="20" y="399.0" width="22" height="5"/>
	<rect x="20" y="459.0" width="22" height="5"/>
	<rect x="20" y="575.0" width="22" height="5"/>
	<g style="font-size:125%">
		<text x="0" y="130.0" dy="0.4em">D</text>
		<text x="0" y="329.0" dy="0.4em">C</text>
		<text x="0" y="431.0" dy="0.4em">B</text>
		<text x="0" y="520.0" dy="0.4em">A</text>
	</g>
	<g style="font-size:85%">
		<text x="46" y="3.0" dy="0.4em">1.00</text>
		<text x="46" y="257.0" dy="0.4em">0.55</text>
		<text x="46" y="401.0" dy="0.4em">0.30</text>
		<text x="46" y="462.0" dy="0.4em">0.20</text>
		<text x="46" y="578.0" dy="0.4em">0.00</text>
	</g>
</g>
</svg>
<br>
<p>This line from 0 to 1 represents the intervals we'll be mapping to each symbol, and it will form the
backbone of our encoding and decoding endeavors. Particular to each symbol are the values
immediately above and below it. For future reference, we'll call the value above each symbol the
'high' value, and the value below each symbol the 'low' value. Written out, they would be</p>
<br>
<table class="datatable headerrow">
<tr><td>Name</td><td>Value</td><td>Name</td><td>Value</td></tr>
<tr><td>D<sub>low</sub></td><td>0.55</td><td>D<sub>high</sub></td><td>1.00</td></tr>
<tr><td>C<sub>low</sub></td><td>0.30</td><td>C<sub>high</sub></td><td>0.55</td></tr>
<tr><td>B<sub>low</sub></td><td>0.20</td><td>B<sub>high</sub></td><td>0.30</td></tr>
<tr><td>A<sub>low</sub></td><td>0.00</td><td>A<sub>high</sub></td><td>0.20</td></tr>
</table>
<br>
<p>We will say that a value <i>x</i> is in a symbol's interval if <i>S<sub>low</sub>&le;x&lt;S<sub>high</sub></i> for some symbol <i>S</i>. Note that by
defining the intervals this way, there are no overlaps or gaps between symbols. That is, if <i>x</i> is in
<i>A</i>'s interval, it can't also be in <i>B</i>'s interval. And if <i>0&le;x&lt;1</i>, then it has to be in some symbol's
interval.</p>
<br>
<p>Our reasoning for choosing intervals based on symbol probabilities will become clear in the actual
implementation. But to be brief, the range will shrink proportionally to the size of the interval
we are encoding, which is something we want to minimize. By choosing our intervals based on each
symbol's probability, we minimize this shrinking.</p>
<br>
<p>With the our interval definitions in order, we're now ready to encode and decode messages.</p>
<br>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Encoding ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h2>Encoding</h2>
<br>
<p>The end goal of encoding a message is to turn it into a number (the code) that the decoder can turn
back into the original message. We already know from the introduction that we can encode intervals,
and we have already mapped our intervals to symbols, so our process will be to look at each symbol
in the message and encode its interval. To do this, we'll follow these four steps:</p>
<br>
<table class="listtable">
<tr><td>1.</td><td>When we begin, define <i>low = 0</i> and <i>range = 1</i>.</td></tr>
<tr><td>2.</td><td>When we want to encode a symbol, scale the original symbol intervals to fit in the
current range using the equation <i>P<sub>new</sub> = P<sub>orig</sub>*range+low</i>.</td></tr>
<tr><td>3.</td><td>After encoding a symbol, scale our range to the symbol's new interval. That is, let
<i>low = S<sub>low</sub></i> and <i>range = S<sub>high</sub> - S<sub>low</sub></i> for the encoded symbol <i>S</i>.</td></tr>
<tr><td>4.</td><td>When we are done encoding all symbols, we may output any code that satisfies
<i>low &le; code &lt; low+range</i>. This code can then be given to a decoder.</td></tr>
</table>
<br>
<p>We'll use these steps to encode the example message <i>ABAD</i>.</p>
<br>
<p>We begin with step 1: let <i>low = 0</i> and <i>range = 1</i>.</p>
<br>
<p>We now want to encode the first symbol, <i>A</i>. So, according to step 2, we scale the symbol intervals
using <i>P<sub>new</sub> = P<sub>orig</sub>*range+low = P<sub>orig</sub>*1.0+0.0</i>. If we use this to scale the interval endpoints we drew
above, we will get the following new endpoints:</p>
<br>
<table class="datatable headerrow">
<tr><td>P<sub>orig</sub></td><td>Scale</td><td>P<sub>new</sub></td></tr>
<tr><td>1.00</td><td>1.00*1.0+0.0</td><td>1.00</td></tr>
<tr><td>0.55</td><td>0.55*1.0+0.0</td><td>0.55</td></tr>
<tr><td>0.30</td><td>0.30*1.0+0.0</td><td>0.30</td></tr>
<tr><td>0.20</td><td>0.20*1.0+0.0</td><td>0.20</td></tr>
<tr><td>0.00</td><td>0.00*1.0+0.0</td><td>0.00</td></tr>
</table>
<br>
<p>Because of the values of <i>low</i> and <i>range</i> this scaling operation results in no changes to the
intervals. We simply perform the operation to remain consistent with later encoding operations.</p>
<br>
<p>It will help us to understand the encoding operation by drawing the symbol intervals and also
drawing where the range will advance to.</p>
<br>
<svg version="1.1" viewBox="0 0 1000 600" class="diagram">
<g transform="translate(395,10)" stroke="none">
	<line x1="150" y1="580" x2="150" y2="459.0" stroke-dasharray="6,6" stroke-width="3" class="fgstroke"/>
	<rect x="20" y="5.0" width="5" height="251.0" fill="#ffa000"/>
	<rect x="20" y="260.0" width="5" height="140.0" fill="#0000ff"/>
	<rect x="20" y="404.0" width="5" height="56.0" fill="#008000"/>
	<rect x="20" y="464.0" width="5" height="112.0" fill="#ff0000"/>
	<rect x="20" y="0.0" width="22" height="5"/>
	<rect x="20" y="255.0" width="22" height="5"/>
	<rect x="20" y="399.0" width="22" height="5"/>
	<rect x="20" y="459.0" width="22" height="5"/>
	<rect x="20" y="575.0" width="22" height="5"/>
	<g style="font-size:125%">
		<text x="0" y="130.0" dy="0.4em">D</text>
		<text x="0" y="329.0" dy="0.4em">C</text>
		<text x="0" y="431.0" dy="0.4em">B</text>
		<text x="0" y="520.0" dy="0.4em">A</text>
	</g>
	<g style="font-size:85%">
		<text x="46" y="3.0" dy="0.4em">1.00</text>
		<text x="46" y="257.0" dy="0.4em">0.55</text>
		<text x="46" y="401.0" dy="0.4em">0.30</text>
		<text x="46" y="462.0" dy="0.4em">0.20</text>
		<text x="46" y="578.0" dy="0.4em">0.00</text>
		<text x="157" y="520.0" dy="0.4em">range</text>
		<text x="157" y="580.0" dy="0.4em">low</text>
	</g>
</g>
</svg>
<br>
<p>According to step 3, we finish our encoding of <i>A</i> by setting <i>low = A<sub>low</sub> = 0.0</i>
and <i>range = A<sub>high</sub> - A<sub>low</sub> = 0.2 - 0.0 = 0.2</i>. These are the same values
denoted by "low" and "range" in the diagram above.</p>
<br>
<p>To encode the second symbol of <i>ABAD</i>, <i>B</i>, we will start by scaling our original symbol intervals to
fit in the range. According to step 2, we will do this with <i>P<sub>new</sub> = P<sub>orig</sub>*range+low = P<sub>orig</sub>*0.2+0.0</i>.
Mathematically, this gives us the following interval endpoints:</p>
<br>
<table class="datatable headerrow">
<tr><td>P<sub>orig</sub></td><td>Scale</td><td>P<sub>new</sub></td></tr>
<tr><td>1.00</td><td>1.00*0.2+0.0</td><td>0.20</td></tr>
<tr><td>0.55</td><td>0.55*0.2+0.0</td><td>0.11</td></tr>
<tr><td>0.30</td><td>0.30*0.2+0.0</td><td>0.06</td></tr>
<tr><td>0.20</td><td>0.20*0.2+0.0</td><td>0.04</td></tr>
<tr><td>0.00</td><td>0.00*0.2+0.0</td><td>0.00</td></tr>
</table>
<br>
<p>We will draw this new set of intervals alongside the previous set. Note that the previous set's
intervals have some portions drawn disproportionately small in order to save screen space. The
important information to get from this diagram is that this new set of intervals fits inside the
previous interval for <i>A</i>.</p>
<br>
<svg version="1.1" viewBox="0 0 1000 600" class="diagram">
<g transform="translate(330,10)" stroke="none">
	<line x1="280" y1="480.2" x2="280" y2="423.0" stroke-dasharray="6,6" stroke-width="3" class="fgstroke"/>
	<rect x="20" y="5.0" width="5" height="23.0" fill="#ffa000"/>
	<rect x="20" y="32.0" width="5" height="23.0" fill="#0000ff"/>
	<rect x="20" y="59.0" width="5" height="23.0" fill="#008000"/>
	<rect x="20" y="86.0" width="5" height="490.0" fill="#ff0000"/>
	<rect x="20" y="0.0" width="22" height="5"/>
	<rect x="20" y="27.0" width="22" height="5"/>
	<rect x="20" y="54.0" width="22" height="5"/>
	<rect x="20" y="81.0" width="22" height="5"/>
	<rect x="20" y="575.0" width="22" height="5"/>
	<rect x="150" y="86.0" width="5" height="214.0" fill="#ffa000"/>
	<rect x="150" y="304.0" width="5" height="120.0" fill="#0000ff"/>
	<rect x="150" y="428.0" width="5" height="48.0" fill="#008000"/>
	<rect x="150" y="480.0" width="5" height="96.0" fill="#ff0000"/>
	<rect x="150" y="81.0" width="22" height="5"/>
	<rect x="150" y="299.0" width="22" height="5"/>
	<rect x="150" y="423.0" width="22" height="5"/>
	<rect x="150" y="475.0" width="22" height="5"/>
	<rect x="150" y="575.0" width="22" height="5"/>
	<g style="font-size:125%">
		<text x="0" y="16.0" dy="0.4em">D</text>
		<text x="0" y="43.0" dy="0.4em">C</text>
		<text x="0" y="70.0" dy="0.4em">B</text>
		<text x="0" y="331.0" dy="0.4em">A</text>
		<text x="130" y="193.0" dy="0.4em">D</text>
		<text x="130" y="364.0" dy="0.4em">C</text>
		<text x="130" y="452.0" dy="0.4em">B</text>
		<text x="130" y="528.0" dy="0.4em">A</text>
	</g>
	<g style="font-size:85%">
		<text x="46" y="3.0" dy="0.4em">1.00</text>
		<text x="46" y="30.0" dy="0.4em">0.55</text>
		<text x="46" y="57.0" dy="0.4em">0.30</text>
		<text x="46" y="84.0" dy="0.4em">0.20</text>
		<text x="46" y="578.0" dy="0.4em">0.00</text>
		<text x="176" y="84.0" dy="0.4em">0.20</text>
		<text x="176" y="302.0" dy="0.4em">0.11</text>
		<text x="176" y="425.0" dy="0.4em">0.06</text>
		<text x="176" y="478.0" dy="0.4em">0.04</text>
		<text x="176" y="578.0" dy="0.4em">0.00</text>
		<text x="287" y="452.0" dy="0.4em">range</text>
		<text x="287" y="480.0" dy="0.4em">low</text>
	</g>
</g>
</svg>
<br>
<p>According to step 3, we finish our encoding of <i>B</i> by setting <i>low = B<sub>low</sub> = 0.04</i> and
<i>range = B<sub>high</sub> - B<sub>low</sub> = 0.06 - 0.04 = 0.02</i>.</p>
<br>
<p>To encode the third symbol of <i>ABAD</i>, <i>A</i>, we will start by scaling our original symbol intervals to fit
in the range. According to step 2, we will do this with <i>P<sub>new</sub> = P<sub>orig</sub>*range+low = P<sub>orig</sub>*0.02+0.04</i>.
Mathematically, this gives us the following interval endpoints:</p>
<br>
<table class="datatable headerrow">
<tr><td>P<sub>orig</sub></td><td>Scale</td><td>P<sub>new</sub></td></tr>
<tr><td>1.00</td><td>1.00*0.02+0.04</td><td>0.060</td></tr>
<tr><td>0.55</td><td>0.55*0.02+0.04</td><td>0.051</td></tr>
<tr><td>0.30</td><td>0.30*0.02+0.04</td><td>0.046</td></tr>
<tr><td>0.20</td><td>0.20*0.02+0.04</td><td>0.044</td></tr>
<tr><td>0.00</td><td>0.00*0.02+0.04</td><td>0.040</td></tr>
</table>
<br>
<p>Again, we'll draw this new set of intervals alongside the previous two. As with the previous
diagram, the unused symbols in the previous two sets have their portions drawn small to save screen
space.</p>
<br>
<svg version="1.1" viewBox="0 0 1000 600" class="diagram">
<g transform="translate(265,10)" stroke="none">
	<line x1="410" y1="553" x2="410" y2="464.0" stroke-dasharray="6,6" stroke-width="3" class="fgstroke"/>
	<rect x="20" y="5.0" width="5" height="23.0" fill="#ffa000"/>
	<rect x="20" y="32.0" width="5" height="23.0" fill="#0000ff"/>
	<rect x="20" y="59.0" width="5" height="23.0" fill="#008000"/>
	<rect x="20" y="86.0" width="5" height="490.0" fill="#ff0000"/>
	<rect x="20" y="0.0" width="22" height="5"/>
	<rect x="20" y="27.0" width="22" height="5"/>
	<rect x="20" y="54.0" width="22" height="5"/>
	<rect x="20" y="81.0" width="22" height="5"/>
	<rect x="20" y="575.0" width="22" height="5"/>
	<rect x="150" y="86.0" width="5" height="23.0" fill="#ffa000"/>
	<rect x="150" y="113.0" width="5" height="23.0" fill="#0000ff"/>
	<rect x="150" y="140.0" width="5" height="409.0" fill="#008000"/>
	<rect x="150" y="553.0" width="5" height="23.0" fill="#ff0000"/>
	<rect x="150" y="81.0" width="22" height="5"/>
	<rect x="150" y="108.0" width="22" height="5"/>
	<rect x="150" y="135.0" width="22" height="5"/>
	<rect x="150" y="548.0" width="22" height="5"/>
	<rect x="150" y="575.0" width="22" height="5"/>
	<rect x="280" y="140.0" width="5" height="178.0" fill="#ffa000"/>
	<rect x="280" y="322.0" width="5" height="99.0" fill="#0000ff"/>
	<rect x="280" y="425.0" width="5" height="40.0" fill="#008000"/>
	<rect x="280" y="469.0" width="5" height="80.0" fill="#ff0000"/>
	<rect x="280" y="135.0" width="22" height="5"/>
	<rect x="280" y="317.0" width="22" height="5"/>
	<rect x="280" y="420.0" width="22" height="5"/>
	<rect x="280" y="464.0" width="22" height="5"/>
	<rect x="280" y="548.0" width="22" height="5"/>
	<g style="font-size:125%">
		<text x="0" y="16.0" dy="0.4em">D</text>
		<text x="0" y="43.0" dy="0.4em">C</text>
		<text x="0" y="70.0" dy="0.4em">B</text>
		<text x="0" y="331.0" dy="0.4em">A</text>
		<text x="130" y="97.0" dy="0.4em">D</text>
		<text x="130" y="124.0" dy="0.4em">C</text>
		<text x="130" y="344.0" dy="0.4em">B</text>
		<text x="130" y="564.0" dy="0.4em">A</text>
		<text x="260" y="228.0" dy="0.4em">D</text>
		<text x="260" y="371.0" dy="0.4em">C</text>
		<text x="260" y="445.0" dy="0.4em">B</text>
		<text x="260" y="509.0" dy="0.4em">A</text>
	</g>
	<g style="font-size:85%">
		<text x="46" y="3.0" dy="0.4em">1.00</text>
		<text x="46" y="30.0" dy="0.4em">0.55</text>
		<text x="46" y="57.0" dy="0.4em">0.30</text>
		<text x="46" y="84.0" dy="0.4em">0.20</text>
		<text x="46" y="578.0" dy="0.4em">0.00</text>
		<text x="176" y="84.0" dy="0.4em">0.20</text>
		<text x="176" y="111.0" dy="0.4em">0.11</text>
		<text x="176" y="138.0" dy="0.4em">0.06</text>
		<text x="176" y="551.0" dy="0.4em">0.04</text>
		<text x="176" y="578.0" dy="0.4em">0.00</text>
		<text x="306" y="138.0" dy="0.4em">0.060</text>
		<text x="306" y="319.0" dy="0.4em">0.051</text>
		<text x="306" y="423.0" dy="0.4em">0.046</text>
		<text x="306" y="467.0" dy="0.4em">0.044</text>
		<text x="306" y="551.0" dy="0.4em">0.040</text>
		<text x="417" y="509.0" dy="0.4em">range</text>
		<text x="417" y="553.0" dy="0.4em">low</text>
	</g>
</g>
</svg>
<br>
<p>According to step 3, we finish our encoding of <i>A</i> by setting <i>low = A<sub>low</sub> = 0.040</i> and
<i>range = A<sub>high</sub> - A<sub>low</sub> = 0.044 - 0.040 = 0.004</i>.</p>
<br>
<p>To encode our fourth and final symbol of <i>ABAD</i>, <i>D</i>, we will start by scaling our original symbol
intervals to fit in the range. According to step 2, we will do this with <i>P<sub>new</sub> = P<sub>orig</sub>*range+low =</i>
<i>P<sub>orig</sub>*0.004+0.040</i>. Mathematically, this gives us the following interval endpoints:</p>
<br>
<table class="datatable headerrow">
<tr><td>P<sub>orig</sub></td><td>Scale</td><td>P<sub>new</sub></td></tr>
<tr><td>1.00</td><td>1.00*0.004+0.040</td><td>0.0440</td></tr>
<tr><td>0.55</td><td>0.55*0.004+0.040</td><td>0.0422</td></tr>
<tr><td>0.30</td><td>0.30*0.004+0.040</td><td>0.0412</td></tr>
<tr><td>0.20</td><td>0.20*0.004+0.040</td><td>0.0408</td></tr>
<tr><td>0.00</td><td>0.00*0.004+0.040</td><td>0.0400</td></tr>
</table>
<br>
<p>Drawing this set of intervals alongside the previous three gives us this diagram.</p>
<br>
<svg version="1.1" viewBox="0 0 1000 600" class="diagram">
<g transform="translate(200,10)" stroke="none">
	<line x1="540" y1="366.4" x2="540" y2="216.0" stroke-dasharray="6,6" stroke-width="3" class="fgstroke"/>
	<rect x="20" y="5.0" width="5" height="23.0" fill="#ffa000"/>
	<rect x="20" y="32.0" width="5" height="23.0" fill="#0000ff"/>
	<rect x="20" y="59.0" width="5" height="23.0" fill="#008000"/>
	<rect x="20" y="86.0" width="5" height="490.0" fill="#ff0000"/>
	<rect x="20" y="0.0" width="22" height="5"/>
	<rect x="20" y="27.0" width="22" height="5"/>
	<rect x="20" y="54.0" width="22" height="5"/>
	<rect x="20" y="81.0" width="22" height="5"/>
	<rect x="20" y="575.0" width="22" height="5"/>
	<rect x="150" y="86.0" width="5" height="23.0" fill="#ffa000"/>
	<rect x="150" y="113.0" width="5" height="23.0" fill="#0000ff"/>
	<rect x="150" y="140.0" width="5" height="409.0" fill="#008000"/>
	<rect x="150" y="553.0" width="5" height="23.0" fill="#ff0000"/>
	<rect x="150" y="81.0" width="22" height="5"/>
	<rect x="150" y="108.0" width="22" height="5"/>
	<rect x="150" y="135.0" width="22" height="5"/>
	<rect x="150" y="548.0" width="22" height="5"/>
	<rect x="150" y="575.0" width="22" height="5"/>
	<rect x="280" y="140.0" width="5" height="23.0" fill="#ffa000"/>
	<rect x="280" y="167.0" width="5" height="23.0" fill="#0000ff"/>
	<rect x="280" y="194.0" width="5" height="23.0" fill="#008000"/>
	<rect x="280" y="221.0" width="5" height="328.0" fill="#ff0000"/>
	<rect x="280" y="135.0" width="22" height="5"/>
	<rect x="280" y="162.0" width="22" height="5"/>
	<rect x="280" y="189.0" width="22" height="5"/>
	<rect x="280" y="216.0" width="22" height="5"/>
	<rect x="280" y="548.0" width="22" height="5"/>
	<rect x="410" y="221.0" width="5" height="141.0" fill="#ffa000"/>
	<rect x="410" y="366.0" width="5" height="79.0" fill="#0000ff"/>
	<rect x="410" y="449.0" width="5" height="32.0" fill="#008000"/>
	<rect x="410" y="486.0" width="5" height="63.0" fill="#ff0000"/>
	<rect x="410" y="216.0" width="22" height="5"/>
	<rect x="410" y="361.0" width="22" height="5"/>
	<rect x="410" y="444.0" width="22" height="5"/>
	<rect x="410" y="481.0" width="22" height="5"/>
	<rect x="410" y="548.0" width="22" height="5"/>
	<g style="font-size:125%">
		<text x="0" y="16.0" dy="0.4em">D</text>
		<text x="0" y="43.0" dy="0.4em">C</text>
		<text x="0" y="70.0" dy="0.4em">B</text>
		<text x="0" y="331.0" dy="0.4em">A</text>
		<text x="130" y="97.0" dy="0.4em">D</text>
		<text x="130" y="124.0" dy="0.4em">C</text>
		<text x="130" y="344.0" dy="0.4em">B</text>
		<text x="130" y="564.0" dy="0.4em">A</text>
		<text x="260" y="151.0" dy="0.4em">D</text>
		<text x="260" y="178.0" dy="0.4em">C</text>
		<text x="260" y="205.0" dy="0.4em">B</text>
		<text x="260" y="385.0" dy="0.4em">A</text>
		<text x="390" y="291.0" dy="0.4em">D</text>
		<text x="390" y="405.0" dy="0.4em">C</text>
		<text x="390" y="465.0" dy="0.4em">B</text>
		<text x="390" y="517.0" dy="0.4em">A</text>
	</g>
	<g style="font-size:85%">
		<text x="46" y="3.0" dy="0.4em">1.00</text>
		<text x="46" y="30.0" dy="0.4em">0.55</text>
		<text x="46" y="57.0" dy="0.4em">0.30</text>
		<text x="46" y="84.0" dy="0.4em">0.20</text>
		<text x="46" y="578.0" dy="0.4em">0.00</text>
		<text x="176" y="84.0" dy="0.4em">0.20</text>
		<text x="176" y="111.0" dy="0.4em">0.11</text>
		<text x="176" y="138.0" dy="0.4em">0.06</text>
		<text x="176" y="551.0" dy="0.4em">0.04</text>
		<text x="176" y="578.0" dy="0.4em">0.00</text>
		<text x="306" y="138.0" dy="0.4em">0.060</text>
		<text x="306" y="165.0" dy="0.4em">0.051</text>
		<text x="306" y="192.0" dy="0.4em">0.046</text>
		<text x="306" y="219.0" dy="0.4em">0.044</text>
		<text x="306" y="551.0" dy="0.4em">0.040</text>
		<text x="436" y="219.0" dy="0.4em">0.0440</text>
		<text x="436" y="364.0" dy="0.4em">0.0422</text>
		<text x="436" y="447.0" dy="0.4em">0.0412</text>
		<text x="436" y="483.0" dy="0.4em">0.0408</text>
		<text x="436" y="551.0" dy="0.4em">0.0400</text>
		<text x="547" y="291.0" dy="0.4em">range</text>
		<text x="547" y="366.0" dy="0.4em">low</text>
	</g>
</g>
</svg>
<br>
<p>According to step 3, we finish our encoding of <i>D</i> by setting <i>low = D<sub>low</sub> = 0.0422</i> and
<i>range = D<sub>high</sub> - D<sub>low</sub> = 0.0440 - 0.0422 = 0.0018</i>.</p>
<br>
<p>We are finally ready finish encoding our message. According to step 4, we can now output any code in
<i>low &le; code &lt; low+range &rArr; 0.0422 &le; code &lt; 0.0440</i>. Our choice for <i>code</i> is completely arbitrary here
so, for simplicity, we will choose to output <i>code = low = 0.0422</i> for the message <i>ABAD</i>.</p>
<br>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Decoding ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h2>Decoding</h2>
<br>
<p>Assume that we have the original symbol intervals given above, and now someone has handed us the
code <i>0.0422</i> and told us it encodes a message of 4 symbols. How do we go about retrieving the
original message?</p>
<br>
<table class="listtable">
<tr><td>1.</td><td>When we begin, define <i>low = 0</i> and <i>range = 1</i>.</td></tr>
<tr><td>2.</td><td>When we want to decode a symbol, scale the original symbol intervals to fit in the
current range with the equation <i>P<sub>new</sub> = P<sub>orig</sub>*range+low</i>.</td></tr>
<tr><td>3.</td><td>Find the new symbol interval that the code value falls into. This is the decoded symbol.</td></tr>
<tr><td>4.</td><td>After decoding a symbol, scale our range to the symbol's new interval. That is, let
<i>low = S<sub>low</sub></i> and <i>range = S<sub>high</sub> - S<sub>low</sub></i> for the decoded symbol <i>S</i>.</td></tr>
</table>
<br>
<p>We begin with step 1: let <i>low = 0</i> and <i>range = 1</i>.</p>
<br>
<p>We now want to decode the first symbol. So, according to step 2, we scale the symbol intervals using
<i>P<sub>new</sub> = P<sub>orig</sub>*range+low = P<sub>orig</sub>*1.0+0.0</i>. Mathematically, this gives us the following interval
endpoints.</p>
<br>
<table class="datatable headerrow">
<tr><td>P<sub>orig</sub></td><td>Scale</td><td>P<sub>new</sub></td></tr>
<tr><td>1.00</td><td>1.00*1.0+0.0</td><td>1.00</td></tr>
<tr><td>0.55</td><td>0.55*1.0+0.0</td><td>0.55</td></tr>
<tr><td>0.30</td><td>0.30*1.0+0.0</td><td>0.30</td></tr>
<tr><td>0.20</td><td>0.20*1.0+0.0</td><td>0.20</td></tr>
<tr><td>0.00</td><td>0.00*1.0+0.0</td><td>0.00</td></tr>
</table>
<br>
<p>Because of the values of <i>low</i> and <i>range</i> this scaling operation results in no changes to the
intervals. We simply perform the operation to remain consistent with later decoding operations.</p>
<br>
<p>As with the encoding operations in the previous section, we will draw a diagram of the symbols
intervals as well as a line showing where <i>code = 0.0422</i> lies in the intervals.</p>
<br>
<svg version="1.1" viewBox="0 0 1000 600" class="diagram">
<g transform="translate(395,10)" stroke="none">
	<line x1="0" y1="551.969" x2="138" y2="551.969" stroke-dasharray="6,6" stroke-width="3" class="fgstroke"/>
	<rect x="20" y="5.0" width="5" height="251.0" fill="#ffa000"/>
	<rect x="20" y="260.0" width="5" height="140.0" fill="#0000ff"/>
	<rect x="20" y="404.0" width="5" height="56.0" fill="#008000"/>
	<rect x="20" y="464.0" width="5" height="112.0" fill="#ff0000"/>
	<rect x="20" y="0.0" width="22" height="5"/>
	<rect x="20" y="255.0" width="22" height="5"/>
	<rect x="20" y="399.0" width="22" height="5"/>
	<rect x="20" y="459.0" width="22" height="5"/>
	<rect x="20" y="575.0" width="22" height="5"/>
	<g style="font-size:125%">
		<text x="0" y="130.0" dy="0.4em">D</text>
		<text x="0" y="329.0" dy="0.4em">C</text>
		<text x="0" y="431.0" dy="0.4em">B</text>
		<text x="0" y="520.0" dy="0.4em">A</text>
	</g>
	<g style="font-size:85%">
		<text x="46" y="3.0" dy="0.4em">1.00</text>
		<text x="46" y="257.0" dy="0.4em">0.55</text>
		<text x="46" y="401.0" dy="0.4em">0.30</text>
		<text x="46" y="462.0" dy="0.4em">0.20</text>
		<text x="46" y="578.0" dy="0.4em">0.00</text>
		<text x="145" y="551.969" dy="0.4em">0.0422</text>
	</g>
</g>
</svg>
<br>
<p>According to step 3, the symbol interval that the code falls into is our decoded symbol. In this
case, it falls in <i>A</i>. Since <i>A<sub>low</sub> = 0.0</i> and <i>A<sub>high</sub> = 0.2</i>, we may also say mathematically that
<i>A<sub>low</sub> &le; code &lt; A<sub>high</sub></i>.</p>
<br>
<p>According to step 4, to finish our decoding of <i>A</i>, we set <i>low = A<sub>low</sub> = 0.0</i> and
<i>range = A<sub>high</sub> - A<sub>low</sub> = 0.2 - 0.0 = 0.2</i>.</p>
<br>
<p>So far, our decoded message is <i>A***</i>, so we will now decode the second symbol. According to step 2,
we need to scale the symbol intervals using <i>P<sub>new</sub> = P<sub>orig</sub>*range+low = P<sub>orig</sub>*0.2+0.0</i>. Mathematically,
this gives us the following interval endpoints.</p>
<br>
<table class="datatable headerrow">
<tr><td>P<sub>orig</sub></td><td>Scale</td><td>P<sub>new</sub></td></tr>
<tr><td>1.00</td><td>1.00*0.2+0.0</td><td>0.20</td></tr>
<tr><td>0.55</td><td>0.55*0.2+0.0</td><td>0.11</td></tr>
<tr><td>0.30</td><td>0.30*0.2+0.0</td><td>0.06</td></tr>
<tr><td>0.20</td><td>0.20*0.2+0.0</td><td>0.04</td></tr>
<tr><td>0.00</td><td>0.00*0.2+0.0</td><td>0.00</td></tr>
</table>
<br>
<p>To see how these newly scaled intervals fit into the previous intervals, we will draw them side by
side along with a line showing where <i>code = 0.0422</i> lies in the intervals. Note that the previous
set's intervals have some portions drawn disproportionately small in order to save screen space.</p>
<br>
<svg version="1.1" viewBox="0 0 1000 600" class="diagram">
<g transform="translate(330,10)" stroke="none">
	<line x1="0" y1="471.386" x2="268" y2="471.386" stroke-dasharray="6,6" stroke-width="3" class="fgstroke"/>
	<rect x="20" y="5.0" width="5" height="23.0" fill="#ffa000"/>
	<rect x="20" y="32.0" width="5" height="23.0" fill="#0000ff"/>
	<rect x="20" y="59.0" width="5" height="23.0" fill="#008000"/>
	<rect x="20" y="86.0" width="5" height="490.0" fill="#ff0000"/>
	<rect x="20" y="0.0" width="22" height="5"/>
	<rect x="20" y="27.0" width="22" height="5"/>
	<rect x="20" y="54.0" width="22" height="5"/>
	<rect x="20" y="81.0" width="22" height="5"/>
	<rect x="20" y="575.0" width="22" height="5"/>
	<rect x="150" y="86.0" width="5" height="214.0" fill="#ffa000"/>
	<rect x="150" y="304.0" width="5" height="120.0" fill="#0000ff"/>
	<rect x="150" y="428.0" width="5" height="48.0" fill="#008000"/>
	<rect x="150" y="480.0" width="5" height="96.0" fill="#ff0000"/>
	<rect x="150" y="81.0" width="22" height="5"/>
	<rect x="150" y="299.0" width="22" height="5"/>
	<rect x="150" y="423.0" width="22" height="5"/>
	<rect x="150" y="475.0" width="22" height="5"/>
	<rect x="150" y="575.0" width="22" height="5"/>
	<g style="font-size:125%">
		<text x="0" y="16.0" dy="0.4em">D</text>
		<text x="0" y="43.0" dy="0.4em">C</text>
		<text x="0" y="70.0" dy="0.4em">B</text>
		<text x="0" y="331.0" dy="0.4em">A</text>
		<text x="130" y="193.0" dy="0.4em">D</text>
		<text x="130" y="364.0" dy="0.4em">C</text>
		<text x="130" y="452.0" dy="0.4em">B</text>
		<text x="130" y="528.0" dy="0.4em">A</text>
	</g>
	<g style="font-size:85%">
		<text x="46" y="3.0" dy="0.4em">1.00</text>
		<text x="46" y="30.0" dy="0.4em">0.55</text>
		<text x="46" y="57.0" dy="0.4em">0.30</text>
		<text x="46" y="84.0" dy="0.4em">0.20</text>
		<text x="46" y="578.0" dy="0.4em">0.00</text>
		<text x="176" y="84.0" dy="0.4em">0.20</text>
		<text x="176" y="302.0" dy="0.4em">0.11</text>
		<text x="176" y="425.0" dy="0.4em">0.06</text>
		<text x="176" y="478.0" dy="0.4em">0.04</text>
		<text x="176" y="578.0" dy="0.4em">0.00</text>
		<text x="275" y="471.386" dy="0.4em">0.0422</text>
	</g>
</g>
</svg>
<br>
<p>According to step 3, the symbol interval that the code falls into is our decoded symbol. In this
case, it falls in <i>B</i>. Since <i>B<sub>low</sub> = 0.04</i> and <i>B<sub>high</sub> = 0.06</i>, we may also say mathematically that
<i>B<sub>low</sub> &le; code &lt; B<sub>high</sub></i>.</p>
<br>
<p>According to step 4, to finish our decoding of <i>B</i>, we set <i>low = B<sub>low</sub> = 0.04</i> and
<i>range = B<sub>high</sub> - B<sub>low</sub> = 0.06 - 0.04 = 0.02</i>.</p>
<br>
<p>So far, our decoded message is <i>AB**</i>, so we will now decode the third symbol. According to step 2, we
need to scale the symbol intervals using <i>P<sub>new</sub> = P<sub>orig</sub>*range+low = P<sub>orig</sub>*0.02+0.04</i>. Mathematically,
this gives us the following interval endpoints.</p>
<br>
<table class="datatable headerrow">
<tr><td>P<sub>orig</sub></td><td>Scale</td><td>P<sub>new</sub></td></tr>
<tr><td>1.00</td><td>1.00*0.02+0.04</td><td>0.060</td></tr>
<tr><td>0.55</td><td>0.55*0.02+0.04</td><td>0.051</td></tr>
<tr><td>0.30</td><td>0.30*0.02+0.04</td><td>0.046</td></tr>
<tr><td>0.20</td><td>0.20*0.02+0.04</td><td>0.044</td></tr>
<tr><td>0.00</td><td>0.00*0.02+0.04</td><td>0.040</td></tr>
</table>
<br>
<p>Once again, we will see how these newly scaled intervals fit into the previous intervals by drawing
them side by side, along with a line showing where <i>code = 0.0422</i> lies in the intervals.</p>
<br>
<svg version="1.1" viewBox="0 0 1000 600" class="diagram">
<g transform="translate(265,10)" stroke="none">
	<line x1="0" y1="501.77" x2="398" y2="501.77" stroke-dasharray="6,6" stroke-width="3" class="fgstroke"/>
	<rect x="20" y="5.0" width="5" height="23.0" fill="#ffa000"/>
	<rect x="20" y="32.0" width="5" height="23.0" fill="#0000ff"/>
	<rect x="20" y="59.0" width="5" height="23.0" fill="#008000"/>
	<rect x="20" y="86.0" width="5" height="490.0" fill="#ff0000"/>
	<rect x="20" y="0.0" width="22" height="5"/>
	<rect x="20" y="27.0" width="22" height="5"/>
	<rect x="20" y="54.0" width="22" height="5"/>
	<rect x="20" y="81.0" width="22" height="5"/>
	<rect x="20" y="575.0" width="22" height="5"/>
	<rect x="150" y="86.0" width="5" height="23.0" fill="#ffa000"/>
	<rect x="150" y="113.0" width="5" height="23.0" fill="#0000ff"/>
	<rect x="150" y="140.0" width="5" height="409.0" fill="#008000"/>
	<rect x="150" y="553.0" width="5" height="23.0" fill="#ff0000"/>
	<rect x="150" y="81.0" width="22" height="5"/>
	<rect x="150" y="108.0" width="22" height="5"/>
	<rect x="150" y="135.0" width="22" height="5"/>
	<rect x="150" y="548.0" width="22" height="5"/>
	<rect x="150" y="575.0" width="22" height="5"/>
	<rect x="280" y="140.0" width="5" height="178.0" fill="#ffa000"/>
	<rect x="280" y="322.0" width="5" height="99.0" fill="#0000ff"/>
	<rect x="280" y="425.0" width="5" height="40.0" fill="#008000"/>
	<rect x="280" y="469.0" width="5" height="80.0" fill="#ff0000"/>
	<rect x="280" y="135.0" width="22" height="5"/>
	<rect x="280" y="317.0" width="22" height="5"/>
	<rect x="280" y="420.0" width="22" height="5"/>
	<rect x="280" y="464.0" width="22" height="5"/>
	<rect x="280" y="548.0" width="22" height="5"/>
	<g style="font-size:125%">
		<text x="0" y="16.0" dy="0.4em">D</text>
		<text x="0" y="43.0" dy="0.4em">C</text>
		<text x="0" y="70.0" dy="0.4em">B</text>
		<text x="0" y="331.0" dy="0.4em">A</text>
		<text x="130" y="97.0" dy="0.4em">D</text>
		<text x="130" y="124.0" dy="0.4em">C</text>
		<text x="130" y="344.0" dy="0.4em">B</text>
		<text x="130" y="564.0" dy="0.4em">A</text>
		<text x="260" y="228.0" dy="0.4em">D</text>
		<text x="260" y="371.0" dy="0.4em">C</text>
		<text x="260" y="445.0" dy="0.4em">B</text>
		<text x="260" y="509.0" dy="0.4em">A</text>
	</g>
	<g style="font-size:85%">
		<text x="46" y="3.0" dy="0.4em">1.00</text>
		<text x="46" y="30.0" dy="0.4em">0.55</text>
		<text x="46" y="57.0" dy="0.4em">0.30</text>
		<text x="46" y="84.0" dy="0.4em">0.20</text>
		<text x="46" y="578.0" dy="0.4em">0.00</text>
		<text x="176" y="84.0" dy="0.4em">0.20</text>
		<text x="176" y="111.0" dy="0.4em">0.11</text>
		<text x="176" y="138.0" dy="0.4em">0.06</text>
		<text x="176" y="551.0" dy="0.4em">0.04</text>
		<text x="176" y="578.0" dy="0.4em">0.00</text>
		<text x="306" y="138.0" dy="0.4em">0.060</text>
		<text x="306" y="319.0" dy="0.4em">0.051</text>
		<text x="306" y="423.0" dy="0.4em">0.046</text>
		<text x="306" y="467.0" dy="0.4em">0.044</text>
		<text x="306" y="551.0" dy="0.4em">0.040</text>
		<text x="405" y="501.77" dy="0.4em">0.0422</text>
	</g>
</g>
</svg>
<br>
<p>According to step 3, the symbol interval that the code falls into is our decoded symbol. In this
case, it falls in <i>A</i>. Since <i>A<sub>low</sub> = 0.040</i> and <i>A<sub>high</sub> = 0.044</i>, we may also say mathematically that
<i>A<sub>low</sub> &le; code &lt; A<sub>high</sub></i>.</p>
<br>
<p>According to step 4, to finish our decoding of <i>A</i>, we set <i>low = A<sub>low</sub> = 0.040</i> and
<i>range = A<sub>high</sub> - A<sub>low</sub> = 0.044 - 0.040 = 0.004</i>.</p>
<br>
<p>So far, our decoded message is <i>ABA*</i>, so we will now decode the fourth symbol. According to step 2,
we need to scale the symbol intervals using <i>P<sub>new</sub> = P<sub>orig</sub>*range+low = P<sub>orig</sub>*0.004+0.040</i>.
Mathematically, this gives us the following interval endpoints.</p>
<br>
<table class="datatable headerrow">
<tr><td>P<sub>orig</sub></td><td>Scale</td><td>P<sub>new</sub></td></tr>
<tr><td>1.00</td><td>1.00*0.004+0.040</td><td>0.0440</td></tr>
<tr><td>0.55</td><td>0.55*0.004+0.040</td><td>0.0422</td></tr>
<tr><td>0.30</td><td>0.30*0.004+0.040</td><td>0.0412</td></tr>
<tr><td>0.20</td><td>0.20*0.004+0.040</td><td>0.0408</td></tr>
<tr><td>0.00</td><td>0.00*0.004+0.040</td><td>0.0400</td></tr>
</table>
<br>
<p>We can see how these newly scaled intervals fit into the previous intervals by drawing them side by
side, along with a line showing where <i>code = 0.0422</i> lies in the intervals.</p>
<br>
<svg version="1.1" viewBox="0 0 1000 600" class="diagram">
<g transform="translate(200,10)" stroke="none">
	<line x1="0" y1="363.9" x2="420" y2="363.9" stroke-dasharray="6,6" stroke-width="3" class="fgstroke"/>
	<line x1="490" y1="363.9" x2="528" y2="363.9" stroke-dasharray="6,6" stroke-width="3" class="fgstroke"/>
	<rect x="20" y="5.0" width="5" height="23.0" fill="#ffa000"/>
	<rect x="20" y="32.0" width="5" height="23.0" fill="#0000ff"/>
	<rect x="20" y="59.0" width="5" height="23.0" fill="#008000"/>
	<rect x="20" y="86.0" width="5" height="490.0" fill="#ff0000"/>
	<rect x="20" y="0.0" width="22" height="5"/>
	<rect x="20" y="27.0" width="22" height="5"/>
	<rect x="20" y="54.0" width="22" height="5"/>
	<rect x="20" y="81.0" width="22" height="5"/>
	<rect x="20" y="575.0" width="22" height="5"/>
	<rect x="150" y="86.0" width="5" height="23.0" fill="#ffa000"/>
	<rect x="150" y="113.0" width="5" height="23.0" fill="#0000ff"/>
	<rect x="150" y="140.0" width="5" height="409.0" fill="#008000"/>
	<rect x="150" y="553.0" width="5" height="23.0" fill="#ff0000"/>
	<rect x="150" y="81.0" width="22" height="5"/>
	<rect x="150" y="108.0" width="22" height="5"/>
	<rect x="150" y="135.0" width="22" height="5"/>
	<rect x="150" y="548.0" width="22" height="5"/>
	<rect x="150" y="575.0" width="22" height="5"/>
	<rect x="280" y="140.0" width="5" height="23.0" fill="#ffa000"/>
	<rect x="280" y="167.0" width="5" height="23.0" fill="#0000ff"/>
	<rect x="280" y="194.0" width="5" height="23.0" fill="#008000"/>
	<rect x="280" y="221.0" width="5" height="328.0" fill="#ff0000"/>
	<rect x="280" y="135.0" width="22" height="5"/>
	<rect x="280" y="162.0" width="22" height="5"/>
	<rect x="280" y="189.0" width="22" height="5"/>
	<rect x="280" y="216.0" width="22" height="5"/>
	<rect x="280" y="548.0" width="22" height="5"/>
	<rect x="410" y="221.0" width="5" height="141.0" fill="#ffa000"/>
	<rect x="410" y="366.0" width="5" height="79.0" fill="#0000ff"/>
	<rect x="410" y="449.0" width="5" height="32.0" fill="#008000"/>
	<rect x="410" y="486.0" width="5" height="63.0" fill="#ff0000"/>
	<rect x="410" y="216.0" width="22" height="5"/>
	<rect x="410" y="361.0" width="22" height="5"/>
	<rect x="410" y="444.0" width="22" height="5"/>
	<rect x="410" y="481.0" width="22" height="5"/>
	<rect x="410" y="548.0" width="22" height="5"/>
	<g style="font-size:125%">
		<text x="0" y="16.0" dy="0.4em">D</text>
		<text x="0" y="43.0" dy="0.4em">C</text>
		<text x="0" y="70.0" dy="0.4em">B</text>
		<text x="0" y="331.0" dy="0.4em">A</text>
		<text x="130" y="97.0" dy="0.4em">D</text>
		<text x="130" y="124.0" dy="0.4em">C</text>
		<text x="130" y="344.0" dy="0.4em">B</text>
		<text x="130" y="564.0" dy="0.4em">A</text>
		<text x="260" y="151.0" dy="0.4em">D</text>
		<text x="260" y="178.0" dy="0.4em">C</text>
		<text x="260" y="205.0" dy="0.4em">B</text>
		<text x="260" y="385.0" dy="0.4em">A</text>
		<text x="390" y="291.0" dy="0.4em">D</text>
		<text x="390" y="405.0" dy="0.4em">C</text>
		<text x="390" y="465.0" dy="0.4em">B</text>
		<text x="390" y="517.0" dy="0.4em">A</text>
	</g>
	<g style="font-size:85%">
		<text x="46" y="3.0" dy="0.4em">1.00</text>
		<text x="46" y="30.0" dy="0.4em">0.55</text>
		<text x="46" y="57.0" dy="0.4em">0.30</text>
		<text x="46" y="84.0" dy="0.4em">0.20</text>
		<text x="46" y="578.0" dy="0.4em">0.00</text>
		<text x="176" y="84.0" dy="0.4em">0.20</text>
		<text x="176" y="111.0" dy="0.4em">0.11</text>
		<text x="176" y="138.0" dy="0.4em">0.06</text>
		<text x="176" y="551.0" dy="0.4em">0.04</text>
		<text x="176" y="578.0" dy="0.4em">0.00</text>
		<text x="306" y="138.0" dy="0.4em">0.060</text>
		<text x="306" y="165.0" dy="0.4em">0.051</text>
		<text x="306" y="192.0" dy="0.4em">0.046</text>
		<text x="306" y="219.0" dy="0.4em">0.044</text>
		<text x="306" y="551.0" dy="0.4em">0.040</text>
		<text x="436" y="219.0" dy="0.4em">0.0440</text>
		<text x="436" y="364.0" dy="0.4em">0.0422</text>
		<text x="436" y="447.0" dy="0.4em">0.0412</text>
		<text x="436" y="483.0" dy="0.4em">0.0408</text>
		<text x="436" y="551.0" dy="0.4em">0.0400</text>
		<text x="535" y="363.9" dy="0.4em">0.0422</text>
	</g>
</g>
</svg>
<br>
<p>According to step 3, the symbol interval that the code falls into is our decoded symbol. In this
case, it falls in <i>D</i>. Since <i>D<sub>low</sub> = 0.0422</i> and <i>D<sub>high</sub> = 0.0440</i>, we may also say mathematically that
<i>D<sub>low</sub> &le; code &lt; D<sub>high</sub></i>.</p>
<br>
<p>According to step 4, to finish our decoding of <i>D</i>, we set <i>low = D<sub>low</sub> = 0.0422</i> and
<i>range = D<sub>high</sub> - D<sub>low</sub> = 0.0440 - 0.0422 = 0.0018</i>.</p>
<br>
<p>We have decoded the final symbol to yield the message <i>ABAD</i>. We could actually keep decoding
indefinitely by following the steps we used for our first 4 symbols. However, since we know our
message is only 4 symbols long, these extra symbols would just be gibberish and thus we stop
decoding here.</p>
</div>

<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Explanation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div class="content"><h1>Explanation</h1>
<p>The biggest problem that an actual range encoder implementation faces is the use of finite precision
arithmetic, in particular, fixed size integers. Ideally, we would use real numbers or arbitrarily
sized bignum's, but one is unavailable on computers and the other will add a significant amount of
computation time. That being said, using fixed size integers will add less than 0.1% overhead
compared to a theoretically optimal implementation, so we don't need to worry too much.</p>
<br>
<p>Our use of only integers means low, range, and all of the symbol intervals will also need to be
integers as well. The intervals will be handled by using an implied denominator. That is, if our
denominator for the intervals above is 100, then their endpoints become:</p>
<br>
<table class="datatable headerrow">
<tr><td>Old</td><td>New</td></tr>
<tr><td>1.00</td><td>100</td></tr>
<tr><td>0.55</td><td>55</td></tr>
<tr><td>0.30</td><td>30</td></tr>
<tr><td>0.20</td><td>20</td></tr>
<tr><td>0.00</td><td>0</td></tr>
</table>
<br>
<p>Handling <i>low</i> and <i>range</i> as integers, on the other hand, will require some explanations and proofs.
The most important point to convey is that <i>low</i> holds the bits we want to output, and each encoding
operation small amounts to it. Since <i>low</i> and <i>range</i> have a fixed size we will only be adding to a
particular portion of low's bits. When range becomes too small to perform calculations, we must
shift down to a lower portion of <i>low</i>'s bits. This has the effect of increasing the value of range we
can use and declaring <i>low</i>'s upper bits to be settled and ready for output.</p>
<br>
<p>It will be easier to discuss the operation of the range encoder by seeing its main loop first, in
its entirety:</p>
<br>
<div class="codeblock langpython">norm=1&lt;&lt;bits
half=norm//2

#Shift the range. Expects 0&lt;range&lt;=norm.
while range&lt;=half:
	output_bit(low&gt;&gt;(bits-1))
	low&=half-1
	low+=low
	range+=range

#Scale the range. Expects norm/2&lt;range&lt;=norm.
off=(range*intlow)//intden
low+=off
range=(range*inthigh)//intden-off

#If we need to carry.
if low&gt;=norm:
	low-=norm
	carry_bit()</div>
<br>
<p><i>bits</i> reflects the accuracy we want the encoder to have, and is typically 32. We will refer to an
interval's low and high values with <i>intlow</i> and <i>inthigh</i>, and the denominator for all intervals
will be <i>intden</i>. We will also assume <i>0 &lt;= intlow &lt; inthigh &lt;= intden &lt;= norm/2+1</i>. The range
encoder's state will also be tracked with the integers <i>low</i> and <i>range</i>.</p>
<br>
<p>We will now explain the various portions of the loop.</p>
<br>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Shifting ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h2>Shifting</h2>
<br>
<div class="codeblock langpython">#Shift the range. Expects 0&lt;range&lt;=norm.
while range&lt;=half:
	output_bit(low&gt;&gt;(bits-1))
	low&=half-1
	low+=low
	range+=range</div>
<br>
<p>The purpose of shifting is to slide the window of the portion of <i>low</i> that we're working on. That is,
we can view the process of range encoding as adding small values to a the decimal representation of
<i>low</i>. As digits become settled and our range becomes smaller, we shift our window down to a lower
point on <i>low</i> and thus enlarge the range. If <i>range</i> becomes too small, then we will never be able to
enlarge it, thus we require <i>range &gt; 0</i>.</p>
<br>
<div class="codeblock">      [    settled   ][    working   ][ insignificant digits ]
low=0.10111001010100001110100100011101000000000000000000000000...
</div>
<br>
<p>In general, our goal is to keep <i>range</i> in the bounds <i>norm/2 &lt; range &lt;= norm</i>. Whenever <i>range</i> is
equal to or below <i>norm/2</i>, then we consider the high bit of <i>low</i> settled, so we output it and
shift down.</p>
<br>
<p>Our choice for keeping range in <i>norm/2 &lt; range &lt;= norm</i> allows us to output binary digits,
which work well with computers. If we wanted to, we could actually change the bounds to output in
any number base.</p>
<br>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Scaling ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h2>Scaling</h2>
<br>
<div class="codeblock langpython">#Scale the range. Expects norm/2&lt;range&lt;=norm.
off=(range*intlow)//intden
low+=off
range=(range*inthigh)//intden-off</div>
<br>
<p>The process of encoding an interval into the range is effectively the same as scaling it (as in step
3 of the encoding proof-of-concept). There are two main ways to perform it depending on the speed
and accuracy desired. Inaccurate scaling looks like so:</p>
<br>
<div class="codeblock">range//=intden
low+=range*intlow
range*=inthigh-intlow</div>
<br>
<p>Inaccurate scaling has the advantages of being easy to implement with fixed precision integers as
well as being fast. Its disadvantages lie in its loss of accuracy (hence the name) and inability to
decode malformed input streams. Although, this latter disadvantage may be considered irrelevant,
since a malformed input stream is a sign of a corrupt input.</p>
<br>
<p>Accurate scaling, which is what our range encoder uses, has the following form:</p>
<br>
<div class="codeblock">off=(range*intlow)//intden
low+=off
range=(range*inthigh)//intden-off</div>
<br>
<p>Accurate scaling is slower than inaccurate and runs the risk overflowing its integer type. Its
advantages to inaccurate scaling, however, can be seen when measuring the error relative to a
theoretical optimal encoding.</p>
<br>
<img src="accuracy.svg" alt="accuracy graph" style="width:100%">
<br>
<br>
<p>Error here is measured by encoding intervals with denominators in the interval [1,2<sup>31</sup>], with the
accurate and inaccurate encoders using varying levels of state bits. We can see that the error for
accurate scaling is nearly 0.000175 for all values of <i>bits &gt;= 32</i>, whereas inaccurate scaling needs
<i>bits &gt;= 44</i> to match it.</p>
<br>
<p>The choice to use accurate or inaccurate is dependent on the implementations needs, but either one
will work. That being said, one form of scaling that must be avoided is this:</p>
<br>
<div class="codeblock">low+=(range*intlow)//intden
range=(range*(inthigh-intlow))//intden</div>
<br>
<p>If it worked, it would offer the best accuracy possible for integers. This method of scaling will
even pass most encoding/decoding tests that are thrown at it. The error that it has lies in the
expression <i>range=(range*(inthigh-intlow))//intden</i>, which mixes the individual probability of the
interval with the cumulative probabilities that it is supposed to be using. Using this method will,
sooner or later, result in an improperly decoded message. Thus, we avoid using it.</p>
<br>
<p>We now need to prove that our current scaling algorithm will result in well defined behavior. To
prove the first set of inequalities we need to account for, let <i>range'=&lfloor;(range*H)/D&rfloor;-&lfloor;(range*L)/D&rfloor;</i>
be the value of <i>range</i> after scaling. Then we need to show that <i>0&lt;range'&lt;=norm</i>.</p>
<br>
<p>Proof: Assume</p>
<br>
<div class="codeblock">L=intlow, H=inthigh, D=intden
0&lt;=L&lt;H&lt;=D&lt;=norm/2+1
0&lt;=norm/2+1&lt;range&lt;=norm</div>
<br>
<p>and consider the expression <i>range*(H-L)-(range*H%D)+(range*L%D)</i>. Then given <i>range&lt;=norm</i> and
<i>1&lt;=H-L&lt;=D</i>, we have the inequality</p>
<br>
<div class="codeblock">range*1-(D-1) &lt;= range*(H-L)-(range*H%D)+(range*L%D) &lt;= norm*D+(D-1)</div>
<br>
<p>Since <i>D&lt;=norm/2+1&lt;=range</i>, <i>D-(D-1)&lt;=range*1-(D-1)</i>, and we have</p>
<br>
<div class="codeblock">D-(D-1) &lt;= range*(H-L)-(range*H%D)+(range*L%D)         &lt;= norm*D+D-1
      1 &lt;= range*(H-L)-(range*H%D)+(range*L%D)         &lt;= norm*D+D-1
      0 &lt;  range*(H-L)-(range*H%D)+(range*L%D)         &lt;= norm*D+D-1
      0 &lt;  (range*H-(range*H%D))-(range*L-(range*L%D)) &lt;= norm*D+D-1</div>
<br>
<p>Divide by <i>D</i>. Note that <i>(range*H-(range*H%D))</i> and <i>(range*L-(range*L%D))</i> are both multiples of <i>D</i>, so
we may split the division between them.</p>
<br>
<div class="codeblock">0 &lt; (range*H-(range*H%D))/D-(range*L-(range*L%D))/D &lt;= &lfloor;(norm*D+D-1)/D&rfloor;
0 &lt; &lfloor;(range*H)/D&rfloor;-&lfloor;(range*L)/D&rfloor; &lt;= &lfloor;(norm*D+D-1)/D&rfloor;
0 &lt; range' &lt;= norm</div>
<br>
<p>As desired.</p>
<br>
<p>The second set of inequalities we need to prove deals with whether or not successive ranges are
contained within their parent ranges. This can be seen in the proof-of-concept diagrams, where each
range is contained by a range to its left. If we cannot prove this property, then it will be
possible for a child range to "escape" its boundaries and change the interval that a parent range
encoded. More formally, if we shifted the child range by <i>s</i> bits and scaled it to get <i>low'</i> and
<i>range'</i>, then we want to show that <i>[low',low'+range')</i> is in
<i>[low*2<sup>s</sup>,low*2<sup>s</sup>+range*2<sup>s</sup>)</i>.</p>
<br>
<p>Proof: We make the same assumptions about <i>L</i>, <i>H</i>, <i>D</i>, and <i>range</i> as in the previous proof and let <i>m=2<sup>s</sup></i>.
To show the child range is in its parent range, it suffices to show <i>low*m&lt;=low'</i> and
<i>low'+range'&lt;=low*m+range*m</i>. We have</p>
<br>
<div class="codeblock">off=&lfloor;(range*m*L)/D&rfloor;
low'=low*m+off
range'=&lfloor;(range*m*H)/D&rfloor;-off</div>
<br>
<p>Since <i>off&gt;=0</i>, we have</p>
<br>
<div class="codeblock">    0 &lt;= off
low*m &lt;= low*m+off
low*m &lt;= low'</div>
<br>
<p>Thus our first bound is satisfied. <i>Since H&lt;=D</i></p>
<br>
<div class="codeblock">                            H &lt;= D
                    range*m*H &lt;= range*m*D
              &lfloor;(range*m*H)/D&rfloor; &lt;= range*m
        low*m+&lfloor;(range*m*H)/D&rfloor; &lt;= low*m+range*m
low*m+off+&lfloor;(range*m*H)/D&rfloor;-off &lt;= low*m+range*m
                  low'+range' &lt;= low*m+range*m</div>
<br>
<p>Hence, child ranges will always be contained in their parent's range.</p>
<br>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Carrying ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h2>Carrying</h2>
<br>
<div class="codeblock langpython">#If we need to carry.
if low&gt;=norm:
	low-=norm
	carry_bit()</div>
<br>
<p>In practice, we will sometimes shift bits before they become settled. This can lead to the scaling
operation producing a value <i>low&gt;=norm</i>. In other words, it will produce a carry bit that must be
propagated up our output bits.</p>
<br>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Flushing ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h2>Flushing</h2>
<br>
<p>After encoding all of our input intervals, there will still be some information left in <i>low</i> that is
needed to decode the message. Most arithmetic and range encoders take the stance of outputting all
of <i>low</i> regardless of how much information is actually useful.</p>
<br>
<p>For example, consider <i>low</i> being 2048 bits long. Then we would need to output all 2048 bits when only
a few are settled in <i>[low,low+range)</i>. Instead we can output only a few necessary bits and then pad
the remainder with a tail sequence to put <i>low+tail</i> in <i>[low,low+range)</i>. Since both the encoder and
decoder will know the tail sequence, it can be omitted from the output to save space. When the
decoder reaches the end of the input stream, it can substitute any bytes it would request with the
tail sequence.</p>
<br>
<p>The tail sequence can be anything we want, however, in practice the final output stream will be
packed into bytes and the output length will also be reported in bytes. This means that when the
decoder reaches the end of the input stream, it will need to determine where in the tail sequence it
should start reading from, since the encoder may have began padding the last byte with 0-7 bits of
the tail sequence.</p>
<br>
<p>This can be remedied by:</p>
<br>
<table class="listtable">
<tr><td>&bull;</td><td>Only starting the tail sequence at the start of a byte.</td></tr>
<tr><td>&bull;</td><td>Transmitting where the tail sequence starts.</td></tr>
<tr><td>&bull;</td><td>Using a tail sequence of one repeating bit (0 or 1).</td></tr>
</table>
<br>
<p>For simplicity of the encoder and decoder, we choose to make the tail a single repeating bit.
Cutting off the final <i>low</i> value and padding it with 0's or 1's can be calculated by</p>
<br>
<div class="codeblock">low0=low&~mask
low1=low|mask</div>
<br>
<p>For some <i>mask=011...1111</i>. We want the new <i>low</i>, <i>low'</i>, such that <i>low&lt;=low'&lt;low+range</i>. It can be seen
that if we choose to pad with 0's, then we can only begin padding after we have output all set bits.
Otherwise, we will make <i>low'&lt;low</i> by clearing a set bit. After testing, with <i>norm=2<sup>8</sup></i>, the average
minimum number of output bits were thus:</p>
<br>
<table class="datatable headerrow">
<tr><td>Pad</td><td>Bits</td></tr>
<tr><td>0</td><td>7.003906</td></tr>
<tr><td>1</td><td>0.980469</td></tr>
</table>
<br>
<p>Therefore, we will pad with 1's. When the decoder is pulling bits from the stream, it will always
add a 1 bit if there are no bits left in the stream.</p>
<br>
<p>By calculating the highest bit different in <i>low^(low+range)</i>, we can find the highest bit that is not
settled, and still needs to be output from <i>low</i>. For example:</p>
<br>
<div class="codeblock">      low=1001011
    range=0011010
low+range=1100101
      dif=low^(low+range)
      dif=0101111
</div>
<br>
<p>The first difference occurs at bit 2 from the top, thus output 2 bits of <i>low</i> and pad with 1's.</p>
<br>
<p>The final bit before padding should always be 0, but we can't exploit this because of byte alignment
syncing.</p>
<br>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Decoding ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h2>Decoding</h2>
<br>
<p>Shifting and scaling, when decoding, work in much the same way that they do when encoding. The main
difference is that we subtract from <i>low</i> instead of adding to it when scaling. If we did not do this,
then we would have to maintain a separate <i>code</i> value in addition to <i>low</i> and <i>range</i>. All references to
<i>code</i> would look like <i>code-low</i>, so it is simpler to just omit <i>code</i> and subtract everything from <i>low</i>.
This change also allows us to ignore carrying, which would affect previous decoding operations.
Thus, the decoding operation looks like so</p>
<br>
<div class="codeblock langpython">norm=1&lt;&lt;bits
half=norm//2

#Shift the range. Expects 0&lt;range&lt;=norm.
while range&lt;=half:
	low+=low+input_bit()
	range+=range

#Scale the range. Expects norm/2&lt;range&lt;=norm.
off=(range*intlow)//intden
low-=off
range=(range*inthigh)//intden-off

#Output a value in intlow&lt;=code&lt;inthigh.
decode=(low*intden+intden-1)//range</div>
<br>
<p>Our main challenge, to ensure proper decoding, is to prove that <i>decode</i> will in fact satisfy
<i>intlow&lt;=decode&lt;inthigh</i> if and only if <i>&lfloor;(range*intlow)/intden&rfloor;&lt;=low&lt;&lfloor;(range*inthigh)/intden&rfloor;</i>.</p>
<br>
<p>Proof: Let <i>L=intlow</i>, <i>H=inthigh</i>, and <i>D=intden</i> for <i>0&lt;=L&lt;H&lt;=D&lt;=range</i>. We let <i>decode=&lfloor;(low*D+D-1)/range&rfloor;</i>
and assume <i>&lfloor;(range*L)/D&rfloor;&lt;=low&lt;&lfloor;(range*H)/D&rfloor;</i>. We want to show <i>L&lt;=decode&lt;H</i>.</p>
<br>
<div class="codeblock">&lfloor;(range*L)/D&rfloor;&lt;=low&lt;&lfloor;(range*H)/D&rfloor;</div>
<br>
<p>Shift by <i>-1</i> to change <i>&lt;</i> to <i>&lt;=</i>.</p>
<br>
<div class="codeblock">&lfloor;(range*L)/D&rfloor;&lt;=low&lt;=&lfloor;(range*H)/D&rfloor;-1
&lfloor;(range*L)/D&rfloor;&lt;=low&lt;=&lfloor;(range*H-D)/D&rfloor;</div>
<br>
<p>Round down to remove rounding brackets.</p>
<br>
<div class="codeblock">(range*L-(range*L%D))/D&lt;=low&lt;=(range*H-D-(range*H-D%D))/D
range*L-(range*L%D)&lt;=low*D&lt;=range*H-D-(range*H%D)
range*L-(D-1)&lt;=low*D&lt;=range*H-D
range*L&lt;=low*D+D-1&lt;=range*H-1
L&lt;=&lfloor;(low*D+D-1)/range&rfloor;&lt;=&lfloor;(range*H-1)/range&rfloor;</div>
<br>
<p>Round down to remove rounding brackets.</p>
<br>
<div class="codeblock">L&lt;=decode&lt;=&lfloor;(range*H-1)/range&rfloor;
L&lt;=decode&lt;=(range*H-1-(range*H-1%range))/range
L&lt;=decode&lt;=(range*H-1-(range-1))/range
L&lt;=decode&lt;=(range*H-range)/range
L&lt;=decode&lt;=H-1
L&lt;=decode&lt;H</div>
<br>
<p>Assume <i>L&lt;=decode&lt;H</i>. We want to show <i>&lfloor;(range*L)/D&rfloor;&lt;=low&lt;&lfloor;(range*H)/D&rfloor;</i>.</p>
<br>
<div class="codeblock">L&lt;=decode&lt;H
L&lt;=&lfloor;(low*D+D-1)/range&rfloor;&lt;H
range*L-(D-1)&lt;=low*D&lt;range*H-(D-1)
  range*L-D+1&lt;=low*D&lt;range*H-D+1</div>
<br>
<p>Shift by <i>+-1</i> to change <i>&lt;=</i> and <i>&lt;</i>.</p>
<br>
<div class="codeblock">      range*L-D&lt;low*D&lt;=range*H-D
&lfloor;(range*L-D)/D&rfloor;&lt;low  &lt;=&lfloor;(range*H-D)/D&rfloor;
&lfloor;(range*L)/D&rfloor;-1&lt;low  &lt;=&lfloor;(range*H)/D&rfloor;-1</div>
<br>
<p>Shift by <i>+-1</i> to change <i>&lt;=</i> and <i>&lt;</i>.</p>
<br>
<div class="codeblock">&lfloor;(range*L)/D&rfloor;&lt;=low&lt;&lfloor;(range*H)/D&rfloor;</div>
<br>
<p>And we are done. We must also note that when <i>input_bit()</i> has read past the end of the input stream,
it begins returning 1's. This is to complement our policy for ending the encoding stream by padding
it with 1's bits.</p>
<br>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Queuing ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h2>Queueing</h2>
<br>
<p>In the background of encoding and decoding is the input/output queue that our encoder uses. If we
were to naively output settled bits to an awaiting file or other output stream, we would run in to
issues when we needed to propagate a carry up the queue. The main problem with propagating a carry
is that all preceeding 1's bits will be flipped and the next highest 0 bit will also be flipped.
Although the random chance of trail of 1's bits being n bits long is 2<sup>-n</sup>, we must be able to handle
arbitrary length trails.</p>
<br>
<p>For this reason, the encoder maintains a circular array with each even position denoting how many 0
bits need to be output, and each odd position denoting how many 1 bits need to be output. If the
bits 1101000111 were pushed to the queue, it would look something like this:</p>
<br>
<table class="datatable headercol">
<tr><td>pos</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr>
<tr><td>count</td><td>2</td><td>1</td><td>1</td><td>3</td><td>3</td></tr>
</table>
<br>
<p>When a carry occurs, we only need to look at the last 1 or 2 counts in the queue. If the last count
is on an odd position, it means all those 1 bits will be flipped to 0, and a single 0 bit from the
previous section will be flipped to 1. For instance, if we want to carry a bit up 1101000111, it
would become 1101001000. Their respective queues would be:</p>
<br>
<table class="datatable headercol">
<tr><td>pos</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td></tr>
<tr><td>original</td><td>2</td><td>1</td><td>1</td><td>3</td><td>3</td><td></td></tr>
<tr><td>carried</td><td>2</td><td>1</td><td>1</td><td>2</td><td>1</td><td>3</td></tr>
</table>
<br>
<p>On the other hand, if the last count is on an even position, only a single 0 bit will be flipped,
and a new 1 bit will be added. If we wanted to carry a bit up 1101000, it would become 1101001. The
queues would be:</p>
<br>
<table class="datatable headercol">
<tr><td>pos</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr>
<tr><td>original</td><td>2</td><td>1</td><td>1</td><td>3</td><td></td></tr>
<tr><td>carried</td><td>2</td><td>1</td><td>1</td><td>2</td><td>1</td></tr>
</table>
<br>
<p>A special case occurs when the last position only has a count of 1. In this case, the last position
will be deleted and 1 will be added to the previous position. Since we only need to remember 2
positions at most, and we need at least 8 bits in the queue to have any data to output, we simply
wait until 10 positions are in the queue before outputting any data.</p>
<br>
<p>The decoding input queue, by contrast, doesn't need to worry about carrying. Thus, it simply holds
the exact bits that are ready to be added to <i>low</i>. When the input stream has no more data in it, the
input queue is filled with 1's since that's what the encoder expects it to be padded with.</p>
</div>

<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Notes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div class="content"><h1>Notes</h1>
<p>One of the most needlessly complex parts of the range encoder is the input/output queue we use.
Future versions might use a different queue provided it is simpler and can handle carries up
arbitrarily long chains in constant time. Although, the current queue works fine as is.</p>
<br>
<p>Most range encoders work at the byte level as opposed to the bit level we use. This is briefly
mentioned in the article when we say that range encoders can work for arbitrary number bases. This
change of base, however, lowers the working space of the range and thus reduces its precision and
efficiency. So we don't use it.</p>
<br>
<p>Anyone who's researched this area of data compression has most likely come across range encoding's
twin, arithmetic encoding. There is a prevailing myth that arithmetic encoding offers better
compression ratios, but this is mostly a symptom of popular range encoders operating at the byte
level, and arithmetic encoders operating at the bit level. The other difference in implementation is
during the shifting step, in which arithmetic encoders judge settled bits by comparing low and high
values, and must also track overflow and underflow. Range encoding, by contrast, only needs to track
overflow, or 'carrying'. In reality, they're both different ways of performing the same task.</p>
</div>

<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Footer ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div id="footer">Created on 27 Apr 2018 - Modified on 13 Jul 2022<br>
Questions and comments: akdee<b>OBFUS</b>144@g<b>CATE</b>mail.com<br>
<a href="../index.html">Alec Dee's Homepage</a></div>
</body>
</html>
